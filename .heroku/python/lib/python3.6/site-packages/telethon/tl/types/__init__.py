"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from typing import Optional, List, Union, TYPE_CHECKING
from . import help, storage, auth, contacts, messages, updates, photos, upload, account, channels, payments, phone
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeBool, Typedouble, Typefuture_salt
    from ...tl.types.contacts import TypeLink
    pass



class AccountDaysTTL(TLObject):
    CONSTRUCTOR_ID = 0xb8d0afdf
    SUBCLASS_OF_ID = 0xbaa39d88

    def __init__(self, days):
        """
        :param int days:

        Constructor for AccountDaysTTL: Instance of AccountDaysTTL.
        """
        super().__init__()

        self.days = days  # type: int

    def to_dict(self):
        return {
            '_': 'AccountDaysTTL',
            'days': self.days
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf\xaf\xd0\xb8',
            struct.pack('<i', self.days),
        ))

    @staticmethod
    def from_reader(reader):
        _days = reader.read_int()
        return AccountDaysTTL(days=_days)


class Authorization(TLObject):
    CONSTRUCTOR_ID = 0x7bf2e6f6
    SUBCLASS_OF_ID = 0xc913c01a

    def __init__(self, hash, flags, device_model, platform, system_version, api_id, app_name, app_version, date_created, date_active, ip, country, region):
        """
        :param int hash:
        :param int flags:
        :param str device_model:
        :param str platform:
        :param str system_version:
        :param int api_id:
        :param str app_name:
        :param str app_version:
        :param int date_created:
        :param int date_active:
        :param str ip:
        :param str country:
        :param str region:

        Constructor for Authorization: Instance of Authorization.
        """
        super().__init__()

        self.hash = hash  # type: int
        self.flags = flags  # type: int
        self.device_model = device_model  # type: str
        self.platform = platform  # type: str
        self.system_version = system_version  # type: str
        self.api_id = api_id  # type: int
        self.app_name = app_name  # type: str
        self.app_version = app_version  # type: str
        self.date_created = date_created  # type: int
        self.date_active = date_active  # type: int
        self.ip = ip  # type: str
        self.country = country  # type: str
        self.region = region  # type: str

    def to_dict(self):
        return {
            '_': 'Authorization',
            'hash': self.hash,
            'flags': self.flags,
            'device_model': self.device_model,
            'platform': self.platform,
            'system_version': self.system_version,
            'api_id': self.api_id,
            'app_name': self.app_name,
            'app_version': self.app_version,
            'date_created': self.date_created,
            'date_active': self.date_active,
            'ip': self.ip,
            'country': self.country,
            'region': self.region
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xe6\xf2{',
            struct.pack('<q', self.hash),
            struct.pack('<i', self.flags),
            TLObject.serialize_bytes(self.device_model),
            TLObject.serialize_bytes(self.platform),
            TLObject.serialize_bytes(self.system_version),
            struct.pack('<i', self.api_id),
            TLObject.serialize_bytes(self.app_name),
            TLObject.serialize_bytes(self.app_version),
            struct.pack('<i', self.date_created),
            struct.pack('<i', self.date_active),
            TLObject.serialize_bytes(self.ip),
            TLObject.serialize_bytes(self.country),
            TLObject.serialize_bytes(self.region),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_long()
        _flags = reader.read_int()
        _device_model = reader.tgread_string()
        _platform = reader.tgread_string()
        _system_version = reader.tgread_string()
        _api_id = reader.read_int()
        _app_name = reader.tgread_string()
        _app_version = reader.tgread_string()
        _date_created = reader.read_int()
        _date_active = reader.read_int()
        _ip = reader.tgread_string()
        _country = reader.tgread_string()
        _region = reader.tgread_string()
        return Authorization(hash=_hash, flags=_flags, device_model=_device_model, platform=_platform, system_version=_system_version, api_id=_api_id, app_name=_app_name, app_version=_app_version, date_created=_date_created, date_active=_date_active, ip=_ip, country=_country, region=_region)


class BadMsgNotification(TLObject):
    CONSTRUCTOR_ID = 0xa7eff811
    SUBCLASS_OF_ID = 0xcebaa157

    def __init__(self, bad_msg_id, bad_msg_seqno, error_code):
        """
        :param int bad_msg_id:
        :param int bad_msg_seqno:
        :param int error_code:

        Constructor for BadMsgNotification: Instance of either BadMsgNotification, BadServerSalt.
        """
        super().__init__()

        self.bad_msg_id = bad_msg_id  # type: int
        self.bad_msg_seqno = bad_msg_seqno  # type: int
        self.error_code = error_code  # type: int

    def to_dict(self):
        return {
            '_': 'BadMsgNotification',
            'bad_msg_id': self.bad_msg_id,
            'bad_msg_seqno': self.bad_msg_seqno,
            'error_code': self.error_code
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xf8\xef\xa7',
            struct.pack('<q', self.bad_msg_id),
            struct.pack('<i', self.bad_msg_seqno),
            struct.pack('<i', self.error_code),
        ))

    @staticmethod
    def from_reader(reader):
        _bad_msg_id = reader.read_long()
        _bad_msg_seqno = reader.read_int()
        _error_code = reader.read_int()
        return BadMsgNotification(bad_msg_id=_bad_msg_id, bad_msg_seqno=_bad_msg_seqno, error_code=_error_code)


class BadServerSalt(TLObject):
    CONSTRUCTOR_ID = 0xedab447b
    SUBCLASS_OF_ID = 0xcebaa157

    def __init__(self, bad_msg_id, bad_msg_seqno, error_code, new_server_salt):
        """
        :param int bad_msg_id:
        :param int bad_msg_seqno:
        :param int error_code:
        :param int new_server_salt:

        Constructor for BadMsgNotification: Instance of either BadMsgNotification, BadServerSalt.
        """
        super().__init__()

        self.bad_msg_id = bad_msg_id  # type: int
        self.bad_msg_seqno = bad_msg_seqno  # type: int
        self.error_code = error_code  # type: int
        self.new_server_salt = new_server_salt  # type: int

    def to_dict(self):
        return {
            '_': 'BadServerSalt',
            'bad_msg_id': self.bad_msg_id,
            'bad_msg_seqno': self.bad_msg_seqno,
            'error_code': self.error_code,
            'new_server_salt': self.new_server_salt
        }

    def __bytes__(self):
        return b''.join((
            b'{D\xab\xed',
            struct.pack('<q', self.bad_msg_id),
            struct.pack('<i', self.bad_msg_seqno),
            struct.pack('<i', self.error_code),
            struct.pack('<q', self.new_server_salt),
        ))

    @staticmethod
    def from_reader(reader):
        _bad_msg_id = reader.read_long()
        _bad_msg_seqno = reader.read_int()
        _error_code = reader.read_int()
        _new_server_salt = reader.read_long()
        return BadServerSalt(bad_msg_id=_bad_msg_id, bad_msg_seqno=_bad_msg_seqno, error_code=_error_code, new_server_salt=_new_server_salt)


class BotCommand(TLObject):
    CONSTRUCTOR_ID = 0xc27ac8c7
    SUBCLASS_OF_ID = 0xe1e62c2

    def __init__(self, command, description):
        """
        :param str command:
        :param str description:

        Constructor for BotCommand: Instance of BotCommand.
        """
        super().__init__()

        self.command = command  # type: str
        self.description = description  # type: str

    def to_dict(self):
        return {
            '_': 'BotCommand',
            'command': self.command,
            'description': self.description
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\xc8z\xc2',
            TLObject.serialize_bytes(self.command),
            TLObject.serialize_bytes(self.description),
        ))

    @staticmethod
    def from_reader(reader):
        _command = reader.tgread_string()
        _description = reader.tgread_string()
        return BotCommand(command=_command, description=_description)


class BotInfo(TLObject):
    CONSTRUCTOR_ID = 0x98e81d3a
    SUBCLASS_OF_ID = 0xf1f701db

    def __init__(self, user_id, description, commands):
        """
        :param int user_id:
        :param str description:
        :param list[BotCommand] commands:

        Constructor for BotInfo: Instance of BotInfo.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.description = description  # type: str
        self.commands = commands  # type: List[TypeBotCommand]

    def to_dict(self):
        return {
            '_': 'BotInfo',
            'user_id': self.user_id,
            'description': self.description,
            'commands': [] if self.commands is None else [None if x is None else x.to_dict() for x in self.commands]
        }

    def __bytes__(self):
        return b''.join((
            b':\x1d\xe8\x98',
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.description),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.commands)),b''.join(bytes(x) for x in self.commands),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _description = reader.tgread_string()
        reader.read_int()
        _commands = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _commands.append(_x)

        return BotInfo(user_id=_user_id, description=_description, commands=_commands)


class BotInlineMediaResult(TLObject):
    CONSTRUCTOR_ID = 0x17db940b
    SUBCLASS_OF_ID = 0x3832b3d5

    def __init__(self, id, type, send_message, photo=None, document=None, title=None, description=None):
        """
        :param str id:
        :param str type:
        :param Photo | None photo:
        :param Document | None document:
        :param str | None title:
        :param str | None description:
        :param BotInlineMessage send_message:

        Constructor for BotInlineResult: Instance of either BotInlineResult, BotInlineMediaResult.
        """
        super().__init__()

        self.id = id  # type: str
        self.type = type  # type: str
        self.photo = photo  # type: Optional[TypePhoto]
        self.document = document  # type: Optional[TypeDocument]
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.send_message = send_message  # type: TypeBotInlineMessage

    def to_dict(self):
        return {
            '_': 'BotInlineMediaResult',
            'id': self.id,
            'type': self.type,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict(),
            'title': self.title,
            'description': self.description,
            'send_message': None if self.send_message is None else self.send_message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x0b\x94\xdb\x17',
            struct.pack('<I', (0 if self.photo is None or self.photo is False else 1) | (0 if self.document is None or self.document is False else 2) | (0 if self.title is None or self.title is False else 4) | (0 if self.description is None or self.description is False else 8)),
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.document is None or self.document is False else (bytes(self.document)),
            b'' if self.title is None or self.title is False else (TLObject.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (TLObject.serialize_bytes(self.description)),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 2:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 4:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 8:
            _description = reader.tgread_string()
        else:
            _description = None
        _send_message = reader.tgread_object()
        return BotInlineMediaResult(id=_id, type=_type, send_message=_send_message, photo=_photo, document=_document, title=_title, description=_description)


class BotInlineMessageMediaAuto(TLObject):
    CONSTRUCTOR_ID = 0x764cf810
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, message, entities=None, reply_markup=None):
        """
        :param str message:
        :param list[MessageEntity] | None entities:
        :param ReplyMarkup | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageMediaAuto',
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x10\xf8Lv',
            struct.pack('<I', (0 if self.entities is None or self.entities is False else 2) | (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            TLObject.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageMediaAuto(message=_message, entities=_entities, reply_markup=_reply_markup)


class BotInlineMessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0x35edb4d4
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, phone_number, first_name, last_name, reply_markup=None):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param ReplyMarkup | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.phone_number = phone_number  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageMediaContact',
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd4\xb4\xed5',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            TLObject.serialize_bytes(self.phone_number),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageMediaContact(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, reply_markup=_reply_markup)


class BotInlineMessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0xb722de65
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, geo, period, reply_markup=None):
        """
        :param GeoPoint geo:
        :param int period:
        :param ReplyMarkup | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.geo = geo  # type: TypeGeoPoint
        self.period = period  # type: int
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageMediaGeo',
            'geo': None if self.geo is None else self.geo.to_dict(),
            'period': self.period,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'e\xde"\xb7',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            bytes(self.geo),
            struct.pack('<i', self.period),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _geo = reader.tgread_object()
        _period = reader.read_int()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageMediaGeo(geo=_geo, period=_period, reply_markup=_reply_markup)


class BotInlineMessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0x4366232e
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, geo, title, address, provider, venue_id, reply_markup=None):
        """
        :param GeoPoint geo:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param ReplyMarkup | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.geo = geo  # type: TypeGeoPoint
        self.title = title  # type: str
        self.address = address  # type: str
        self.provider = provider  # type: str
        self.venue_id = venue_id  # type: str
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageMediaVenue',
            'geo': None if self.geo is None else self.geo.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'.#fC',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            bytes(self.geo),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.address),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.venue_id),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _geo = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageMediaVenue(geo=_geo, title=_title, address=_address, provider=_provider, venue_id=_venue_id, reply_markup=_reply_markup)


class BotInlineMessageText(TLObject):
    CONSTRUCTOR_ID = 0x8c7f65e2
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, message, no_webpage=None, entities=None, reply_markup=None):
        """
        :param bool | None no_webpage:
        :param str message:
        :param list[MessageEntity] | None entities:
        :param ReplyMarkup | None reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        super().__init__()

        self.no_webpage = no_webpage  # type: Optional[bool]
        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageText',
            'no_webpage': self.no_webpage,
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe2e\x7f\x8c',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 1) | (0 if self.entities is None or self.entities is False else 2) | (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            TLObject.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 1)
        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return BotInlineMessageText(message=_message, no_webpage=_no_webpage, entities=_entities, reply_markup=_reply_markup)


class BotInlineResult(TLObject):
    CONSTRUCTOR_ID = 0x9bebaeb9
    SUBCLASS_OF_ID = 0x3832b3d5

    def __init__(self, id, type, send_message, title=None, description=None, url=None, thumb_url=None, content_url=None, content_type=None, w=None, h=None, duration=None):
        """
        :param str id:
        :param str type:
        :param str | None title:
        :param str | None description:
        :param str | None url:
        :param str | None thumb_url:
        :param str | None content_url:
        :param str | None content_type:
        :param int | None w:
        :param int | None h:
        :param int | None duration:
        :param BotInlineMessage send_message:

        Constructor for BotInlineResult: Instance of either BotInlineResult, BotInlineMediaResult.
        """
        super().__init__()

        self.id = id  # type: str
        self.type = type  # type: str
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.url = url  # type: Optional[str]
        self.thumb_url = thumb_url  # type: Optional[str]
        self.content_url = content_url  # type: Optional[str]
        self.content_type = content_type  # type: Optional[str]
        self.w = w  # type: Optional[int]
        self.h = h  # type: Optional[int]
        self.duration = duration  # type: Optional[int]
        self.send_message = send_message  # type: TypeBotInlineMessage

    def to_dict(self):
        return {
            '_': 'BotInlineResult',
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h,
            'duration': self.duration,
            'send_message': None if self.send_message is None else self.send_message.to_dict()
        }

    def __bytes__(self):
        assert ((self.content_url or self.content_url is not None) and (self.content_type or self.content_type is not None)) or ((self.content_url is None or self.content_url is False) and (self.content_type is None or self.content_type is False)), 'content_url, content_type parameters must all be False-y (like None) or all me True-y'
        assert ((self.w or self.w is not None) and (self.h or self.h is not None)) or ((self.w is None or self.w is False) and (self.h is None or self.h is False)), 'w, h parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xb9\xae\xeb\x9b',
            struct.pack('<I', (0 if self.title is None or self.title is False else 2) | (0 if self.description is None or self.description is False else 4) | (0 if self.url is None or self.url is False else 8) | (0 if self.thumb_url is None or self.thumb_url is False else 16) | (0 if self.content_url is None or self.content_url is False else 32) | (0 if self.content_type is None or self.content_type is False else 32) | (0 if self.w is None or self.w is False else 64) | (0 if self.h is None or self.h is False else 64) | (0 if self.duration is None or self.duration is False else 128)),
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            b'' if self.title is None or self.title is False else (TLObject.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (TLObject.serialize_bytes(self.description)),
            b'' if self.url is None or self.url is False else (TLObject.serialize_bytes(self.url)),
            b'' if self.thumb_url is None or self.thumb_url is False else (TLObject.serialize_bytes(self.thumb_url)),
            b'' if self.content_url is None or self.content_url is False else (TLObject.serialize_bytes(self.content_url)),
            b'' if self.content_type is None or self.content_type is False else (TLObject.serialize_bytes(self.content_type)),
            b'' if self.w is None or self.w is False else (struct.pack('<i', self.w)),
            b'' if self.h is None or self.h is False else (struct.pack('<i', self.h)),
            b'' if self.duration is None or self.duration is False else (struct.pack('<i', self.duration)),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 8:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 16:
            _thumb_url = reader.tgread_string()
        else:
            _thumb_url = None
        if flags & 32:
            _content_url = reader.tgread_string()
        else:
            _content_url = None
        if flags & 32:
            _content_type = reader.tgread_string()
        else:
            _content_type = None
        if flags & 64:
            _w = reader.read_int()
        else:
            _w = None
        if flags & 64:
            _h = reader.read_int()
        else:
            _h = None
        if flags & 128:
            _duration = reader.read_int()
        else:
            _duration = None
        _send_message = reader.tgread_object()
        return BotInlineResult(id=_id, type=_type, send_message=_send_message, title=_title, description=_description, url=_url, thumb_url=_thumb_url, content_url=_content_url, content_type=_content_type, w=_w, h=_h, duration=_duration)


class CdnConfig(TLObject):
    CONSTRUCTOR_ID = 0x5725e40a
    SUBCLASS_OF_ID = 0xecda397c

    def __init__(self, public_keys):
        """
        :param list[CdnPublicKey] public_keys:

        Constructor for CdnConfig: Instance of CdnConfig.
        """
        super().__init__()

        self.public_keys = public_keys  # type: List[TypeCdnPublicKey]

    def to_dict(self):
        return {
            '_': 'CdnConfig',
            'public_keys': [] if self.public_keys is None else [None if x is None else x.to_dict() for x in self.public_keys]
        }

    def __bytes__(self):
        return b''.join((
            b'\n\xe4%W',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.public_keys)),b''.join(bytes(x) for x in self.public_keys),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _public_keys = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _public_keys.append(_x)

        return CdnConfig(public_keys=_public_keys)


class CdnFileHash(TLObject):
    CONSTRUCTOR_ID = 0x77eec38f
    SUBCLASS_OF_ID = 0xe776d7e4

    def __init__(self, offset, limit, hash):
        """
        :param int offset:
        :param int limit:
        :param bytes hash:

        Constructor for CdnFileHash: Instance of CdnFileHash.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.limit = limit  # type: int
        self.hash = hash  # type: bytes

    def to_dict(self):
        return {
            '_': 'CdnFileHash',
            'offset': self.offset,
            'limit': self.limit,
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x8f\xc3\xeew',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.limit),
            TLObject.serialize_bytes(self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _limit = reader.read_int()
        _hash = reader.tgread_bytes()
        return CdnFileHash(offset=_offset, limit=_limit, hash=_hash)


class CdnPublicKey(TLObject):
    CONSTRUCTOR_ID = 0xc982eaba
    SUBCLASS_OF_ID = 0x16db47f3

    def __init__(self, dc_id, public_key):
        """
        :param int dc_id:
        :param str public_key:

        Constructor for CdnPublicKey: Instance of CdnPublicKey.
        """
        super().__init__()

        self.dc_id = dc_id  # type: int
        self.public_key = public_key  # type: str

    def to_dict(self):
        return {
            '_': 'CdnPublicKey',
            'dc_id': self.dc_id,
            'public_key': self.public_key
        }

    def __bytes__(self):
        return b''.join((
            b'\xba\xea\x82\xc9',
            struct.pack('<i', self.dc_id),
            TLObject.serialize_bytes(self.public_key),
        ))

    @staticmethod
    def from_reader(reader):
        _dc_id = reader.read_int()
        _public_key = reader.tgread_string()
        return CdnPublicKey(dc_id=_dc_id, public_key=_public_key)


class Channel(TLObject):
    CONSTRUCTOR_ID = 0x450b7115
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title, photo, date, version, creator=None, left=None, editor=None, broadcast=None, verified=None, megagroup=None, restricted=None, democracy=None, signatures=None, min=None, access_hash=None, username=None, restriction_reason=None, admin_rights=None, banned_rights=None, participants_count=None):
        """
        :param bool | None creator:
        :param bool | None left:
        :param bool | None editor:
        :param bool | None broadcast:
        :param bool | None verified:
        :param bool | None megagroup:
        :param bool | None restricted:
        :param bool | None democracy:
        :param bool | None signatures:
        :param bool | None min:
        :param int id:
        :param int | None access_hash:
        :param str title:
        :param str | None username:
        :param ChatPhoto photo:
        :param datetime.datetime | None date:
        :param int version:
        :param str | None restriction_reason:
        :param ChannelAdminRights | None admin_rights:
        :param ChannelBannedRights | None banned_rights:
        :param int | None participants_count:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.creator = creator  # type: Optional[bool]
        self.left = left  # type: Optional[bool]
        self.editor = editor  # type: Optional[bool]
        self.broadcast = broadcast  # type: Optional[bool]
        self.verified = verified  # type: Optional[bool]
        self.megagroup = megagroup  # type: Optional[bool]
        self.restricted = restricted  # type: Optional[bool]
        self.democracy = democracy  # type: Optional[bool]
        self.signatures = signatures  # type: Optional[bool]
        self.min = min  # type: Optional[bool]
        self.id = id  # type: int
        self.access_hash = access_hash  # type: Optional[int]
        self.title = title  # type: str
        self.username = username  # type: Optional[str]
        self.photo = photo  # type: TypeChatPhoto
        self.date = date  # type: Optional[datetime]
        self.version = version  # type: int
        self.restriction_reason = restriction_reason  # type: Optional[str]
        self.admin_rights = admin_rights  # type: Optional[TypeChannelAdminRights]
        self.banned_rights = banned_rights  # type: Optional[TypeChannelBannedRights]
        self.participants_count = participants_count  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'Channel',
            'creator': self.creator,
            'left': self.left,
            'editor': self.editor,
            'broadcast': self.broadcast,
            'verified': self.verified,
            'megagroup': self.megagroup,
            'restricted': self.restricted,
            'democracy': self.democracy,
            'signatures': self.signatures,
            'min': self.min,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'username': self.username,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'date': self.date,
            'version': self.version,
            'restriction_reason': self.restriction_reason,
            'admin_rights': None if self.admin_rights is None else self.admin_rights.to_dict(),
            'banned_rights': None if self.banned_rights is None else self.banned_rights.to_dict(),
            'participants_count': self.participants_count
        }

    def __bytes__(self):
        assert ((self.restricted or self.restricted is not None) and (self.restriction_reason or self.restriction_reason is not None)) or ((self.restricted is None or self.restricted is False) and (self.restriction_reason is None or self.restriction_reason is False)), 'restricted, restriction_reason parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\x15q\x0bE',
            struct.pack('<I', (0 if self.creator is None or self.creator is False else 1) | (0 if self.left is None or self.left is False else 4) | (0 if self.editor is None or self.editor is False else 8) | (0 if self.broadcast is None or self.broadcast is False else 32) | (0 if self.verified is None or self.verified is False else 128) | (0 if self.megagroup is None or self.megagroup is False else 256) | (0 if self.restricted is None or self.restricted is False else 512) | (0 if self.democracy is None or self.democracy is False else 1024) | (0 if self.signatures is None or self.signatures is False else 2048) | (0 if self.min is None or self.min is False else 4096) | (0 if self.access_hash is None or self.access_hash is False else 8192) | (0 if self.username is None or self.username is False else 64) | (0 if self.restriction_reason is None or self.restriction_reason is False else 512) | (0 if self.admin_rights is None or self.admin_rights is False else 16384) | (0 if self.banned_rights is None or self.banned_rights is False else 32768) | (0 if self.participants_count is None or self.participants_count is False else 131072)),
            struct.pack('<i', self.id),
            b'' if self.access_hash is None or self.access_hash is False else (struct.pack('<q', self.access_hash)),
            TLObject.serialize_bytes(self.title),
            b'' if self.username is None or self.username is False else (TLObject.serialize_bytes(self.username)),
            bytes(self.photo),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.version),
            b'' if self.restriction_reason is None or self.restriction_reason is False else (TLObject.serialize_bytes(self.restriction_reason)),
            b'' if self.admin_rights is None or self.admin_rights is False else (bytes(self.admin_rights)),
            b'' if self.banned_rights is None or self.banned_rights is False else (bytes(self.banned_rights)),
            b'' if self.participants_count is None or self.participants_count is False else (struct.pack('<i', self.participants_count)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _creator = bool(flags & 1)
        _left = bool(flags & 4)
        _editor = bool(flags & 8)
        _broadcast = bool(flags & 32)
        _verified = bool(flags & 128)
        _megagroup = bool(flags & 256)
        _restricted = bool(flags & 512)
        _democracy = bool(flags & 1024)
        _signatures = bool(flags & 2048)
        _min = bool(flags & 4096)
        _id = reader.read_int()
        if flags & 8192:
            _access_hash = reader.read_long()
        else:
            _access_hash = None
        _title = reader.tgread_string()
        if flags & 64:
            _username = reader.tgread_string()
        else:
            _username = None
        _photo = reader.tgread_object()
        _date = reader.tgread_date()
        _version = reader.read_int()
        if flags & 512:
            _restriction_reason = reader.tgread_string()
        else:
            _restriction_reason = None
        if flags & 16384:
            _admin_rights = reader.tgread_object()
        else:
            _admin_rights = None
        if flags & 32768:
            _banned_rights = reader.tgread_object()
        else:
            _banned_rights = None
        if flags & 131072:
            _participants_count = reader.read_int()
        else:
            _participants_count = None
        return Channel(id=_id, title=_title, photo=_photo, date=_date, version=_version, creator=_creator, left=_left, editor=_editor, broadcast=_broadcast, verified=_verified, megagroup=_megagroup, restricted=_restricted, democracy=_democracy, signatures=_signatures, min=_min, access_hash=_access_hash, username=_username, restriction_reason=_restriction_reason, admin_rights=_admin_rights, banned_rights=_banned_rights, participants_count=_participants_count)


class ChannelAdminLogEvent(TLObject):
    CONSTRUCTOR_ID = 0x3b5a3e40
    SUBCLASS_OF_ID = 0x408f0999

    def __init__(self, id, date, user_id, action):
        """
        :param int id:
        :param datetime.datetime | None date:
        :param int user_id:
        :param ChannelAdminLogEventAction action:

        Constructor for ChannelAdminLogEvent: Instance of ChannelAdminLogEvent.
        """
        super().__init__()

        self.id = id  # type: int
        self.date = date  # type: Optional[datetime]
        self.user_id = user_id  # type: int
        self.action = action  # type: TypeChannelAdminLogEventAction

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEvent',
            'id': self.id,
            'date': self.date,
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'@>Z;',
            struct.pack('<q', self.id),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _date = reader.tgread_date()
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return ChannelAdminLogEvent(id=_id, date=_date, user_id=_user_id, action=_action)


class ChannelAdminLogEventActionChangeAbout(TLObject):
    CONSTRUCTOR_ID = 0x55188a2e
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.prev_value = prev_value  # type: str
        self.new_value = new_value  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangeAbout',
            'prev_value': self.prev_value,
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'.\x8a\x18U',
            TLObject.serialize_bytes(self.prev_value),
            TLObject.serialize_bytes(self.new_value),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return ChannelAdminLogEventActionChangeAbout(prev_value=_prev_value, new_value=_new_value)


class ChannelAdminLogEventActionChangePhoto(TLObject):
    CONSTRUCTOR_ID = 0xb82f55c3
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_photo, new_photo):
        """
        :param ChatPhoto prev_photo:
        :param ChatPhoto new_photo:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.prev_photo = prev_photo  # type: TypeChatPhoto
        self.new_photo = new_photo  # type: TypeChatPhoto

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangePhoto',
            'prev_photo': None if self.prev_photo is None else self.prev_photo.to_dict(),
            'new_photo': None if self.new_photo is None else self.new_photo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3U/\xb8',
            bytes(self.prev_photo),
            bytes(self.new_photo),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_photo = reader.tgread_object()
        _new_photo = reader.tgread_object()
        return ChannelAdminLogEventActionChangePhoto(prev_photo=_prev_photo, new_photo=_new_photo)


class ChannelAdminLogEventActionChangeStickerSet(TLObject):
    CONSTRUCTOR_ID = 0xb1c3caa7
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_stickerset, new_stickerset):
        """
        :param InputStickerSet prev_stickerset:
        :param InputStickerSet new_stickerset:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.prev_stickerset = prev_stickerset  # type: TypeInputStickerSet
        self.new_stickerset = new_stickerset  # type: TypeInputStickerSet

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangeStickerSet',
            'prev_stickerset': None if self.prev_stickerset is None else self.prev_stickerset.to_dict(),
            'new_stickerset': None if self.new_stickerset is None else self.new_stickerset.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xa7\xca\xc3\xb1',
            bytes(self.prev_stickerset),
            bytes(self.new_stickerset),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_stickerset = reader.tgread_object()
        _new_stickerset = reader.tgread_object()
        return ChannelAdminLogEventActionChangeStickerSet(prev_stickerset=_prev_stickerset, new_stickerset=_new_stickerset)


class ChannelAdminLogEventActionChangeTitle(TLObject):
    CONSTRUCTOR_ID = 0xe6dfb825
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.prev_value = prev_value  # type: str
        self.new_value = new_value  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangeTitle',
            'prev_value': self.prev_value,
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'%\xb8\xdf\xe6',
            TLObject.serialize_bytes(self.prev_value),
            TLObject.serialize_bytes(self.new_value),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return ChannelAdminLogEventActionChangeTitle(prev_value=_prev_value, new_value=_new_value)


class ChannelAdminLogEventActionChangeUsername(TLObject):
    CONSTRUCTOR_ID = 0x6a4afc38
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.prev_value = prev_value  # type: str
        self.new_value = new_value  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangeUsername',
            'prev_value': self.prev_value,
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'8\xfcJj',
            TLObject.serialize_bytes(self.prev_value),
            TLObject.serialize_bytes(self.new_value),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return ChannelAdminLogEventActionChangeUsername(prev_value=_prev_value, new_value=_new_value)


class ChannelAdminLogEventActionDeleteMessage(TLObject):
    CONSTRUCTOR_ID = 0x42e047bb
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, message):
        """
        :param Message message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.message = message  # type: TypeMessage

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionDeleteMessage',
            'message': None if self.message is None else self.message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xbbG\xe0B',
            bytes(self.message),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        return ChannelAdminLogEventActionDeleteMessage(message=_message)


class ChannelAdminLogEventActionEditMessage(TLObject):
    CONSTRUCTOR_ID = 0x709b2405
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_message, new_message):
        """
        :param Message prev_message:
        :param Message new_message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.prev_message = prev_message  # type: TypeMessage
        self.new_message = new_message  # type: TypeMessage

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionEditMessage',
            'prev_message': None if self.prev_message is None else self.prev_message.to_dict(),
            'new_message': None if self.new_message is None else self.new_message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x05$\x9bp',
            bytes(self.prev_message),
            bytes(self.new_message),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_message = reader.tgread_object()
        _new_message = reader.tgread_object()
        return ChannelAdminLogEventActionEditMessage(prev_message=_prev_message, new_message=_new_message)


class ChannelAdminLogEventActionParticipantInvite(TLObject):
    CONSTRUCTOR_ID = 0xe31c34d8
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, participant):
        """
        :param ChannelParticipant participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.participant = participant  # type: TypeChannelParticipant

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantInvite',
            'participant': None if self.participant is None else self.participant.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd84\x1c\xe3',
            bytes(self.participant),
        ))

    @staticmethod
    def from_reader(reader):
        _participant = reader.tgread_object()
        return ChannelAdminLogEventActionParticipantInvite(participant=_participant)


class ChannelAdminLogEventActionParticipantJoin(TLObject):
    CONSTRUCTOR_ID = 0x183040d3
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantJoin'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3@0\x18',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelAdminLogEventActionParticipantJoin()


class ChannelAdminLogEventActionParticipantLeave(TLObject):
    CONSTRUCTOR_ID = 0xf89777f2
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantLeave'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf2w\x97\xf8',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelAdminLogEventActionParticipantLeave()


class ChannelAdminLogEventActionParticipantToggleAdmin(TLObject):
    CONSTRUCTOR_ID = 0xd5676710
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_participant, new_participant):
        """
        :param ChannelParticipant prev_participant:
        :param ChannelParticipant new_participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.prev_participant = prev_participant  # type: TypeChannelParticipant
        self.new_participant = new_participant  # type: TypeChannelParticipant

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantToggleAdmin',
            'prev_participant': None if self.prev_participant is None else self.prev_participant.to_dict(),
            'new_participant': None if self.new_participant is None else self.new_participant.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x10gg\xd5',
            bytes(self.prev_participant),
            bytes(self.new_participant),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_participant = reader.tgread_object()
        _new_participant = reader.tgread_object()
        return ChannelAdminLogEventActionParticipantToggleAdmin(prev_participant=_prev_participant, new_participant=_new_participant)


class ChannelAdminLogEventActionParticipantToggleBan(TLObject):
    CONSTRUCTOR_ID = 0xe6d83d7e
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_participant, new_participant):
        """
        :param ChannelParticipant prev_participant:
        :param ChannelParticipant new_participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.prev_participant = prev_participant  # type: TypeChannelParticipant
        self.new_participant = new_participant  # type: TypeChannelParticipant

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantToggleBan',
            'prev_participant': None if self.prev_participant is None else self.prev_participant.to_dict(),
            'new_participant': None if self.new_participant is None else self.new_participant.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'~=\xd8\xe6',
            bytes(self.prev_participant),
            bytes(self.new_participant),
        ))

    @staticmethod
    def from_reader(reader):
        _prev_participant = reader.tgread_object()
        _new_participant = reader.tgread_object()
        return ChannelAdminLogEventActionParticipantToggleBan(prev_participant=_prev_participant, new_participant=_new_participant)


class ChannelAdminLogEventActionToggleInvites(TLObject):
    CONSTRUCTOR_ID = 0x1b7907ae
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param Bool new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.new_value = new_value  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionToggleInvites',
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'\xae\x07y\x1b',
            b'\xb5ur\x99' if self.new_value else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _new_value = reader.tgread_bool()
        return ChannelAdminLogEventActionToggleInvites(new_value=_new_value)


class ChannelAdminLogEventActionTogglePreHistoryHidden(TLObject):
    CONSTRUCTOR_ID = 0x5f5c95f1
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param Bool new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.new_value = new_value  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionTogglePreHistoryHidden',
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'\xf1\x95\\_',
            b'\xb5ur\x99' if self.new_value else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _new_value = reader.tgread_bool()
        return ChannelAdminLogEventActionTogglePreHistoryHidden(new_value=_new_value)


class ChannelAdminLogEventActionToggleSignatures(TLObject):
    CONSTRUCTOR_ID = 0x26ae0971
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param Bool new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.new_value = new_value  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionToggleSignatures',
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'q\t\xae&',
            b'\xb5ur\x99' if self.new_value else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _new_value = reader.tgread_bool()
        return ChannelAdminLogEventActionToggleSignatures(new_value=_new_value)


class ChannelAdminLogEventActionUpdatePinned(TLObject):
    CONSTRUCTOR_ID = 0xe9e82c18
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, message):
        """
        :param Message message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        super().__init__()

        self.message = message  # type: TypeMessage

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionUpdatePinned',
            'message': None if self.message is None else self.message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x18,\xe8\xe9',
            bytes(self.message),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        return ChannelAdminLogEventActionUpdatePinned(message=_message)


class ChannelAdminLogEventsFilter(TLObject):
    CONSTRUCTOR_ID = 0xea107ae4
    SUBCLASS_OF_ID = 0x7cbbf319

    def __init__(self, join=None, leave=None, invite=None, ban=None, unban=None, kick=None, unkick=None, promote=None, demote=None, info=None, settings=None, pinned=None, edit=None, delete=None):
        """
        :param bool | None join:
        :param bool | None leave:
        :param bool | None invite:
        :param bool | None ban:
        :param bool | None unban:
        :param bool | None kick:
        :param bool | None unkick:
        :param bool | None promote:
        :param bool | None demote:
        :param bool | None info:
        :param bool | None settings:
        :param bool | None pinned:
        :param bool | None edit:
        :param bool | None delete:

        Constructor for ChannelAdminLogEventsFilter: Instance of ChannelAdminLogEventsFilter.
        """
        super().__init__()

        self.join = join  # type: Optional[bool]
        self.leave = leave  # type: Optional[bool]
        self.invite = invite  # type: Optional[bool]
        self.ban = ban  # type: Optional[bool]
        self.unban = unban  # type: Optional[bool]
        self.kick = kick  # type: Optional[bool]
        self.unkick = unkick  # type: Optional[bool]
        self.promote = promote  # type: Optional[bool]
        self.demote = demote  # type: Optional[bool]
        self.info = info  # type: Optional[bool]
        self.settings = settings  # type: Optional[bool]
        self.pinned = pinned  # type: Optional[bool]
        self.edit = edit  # type: Optional[bool]
        self.delete = delete  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventsFilter',
            'join': self.join,
            'leave': self.leave,
            'invite': self.invite,
            'ban': self.ban,
            'unban': self.unban,
            'kick': self.kick,
            'unkick': self.unkick,
            'promote': self.promote,
            'demote': self.demote,
            'info': self.info,
            'settings': self.settings,
            'pinned': self.pinned,
            'edit': self.edit,
            'delete': self.delete
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4z\x10\xea',
            struct.pack('<I', (0 if self.join is None or self.join is False else 1) | (0 if self.leave is None or self.leave is False else 2) | (0 if self.invite is None or self.invite is False else 4) | (0 if self.ban is None or self.ban is False else 8) | (0 if self.unban is None or self.unban is False else 16) | (0 if self.kick is None or self.kick is False else 32) | (0 if self.unkick is None or self.unkick is False else 64) | (0 if self.promote is None or self.promote is False else 128) | (0 if self.demote is None or self.demote is False else 256) | (0 if self.info is None or self.info is False else 512) | (0 if self.settings is None or self.settings is False else 1024) | (0 if self.pinned is None or self.pinned is False else 2048) | (0 if self.edit is None or self.edit is False else 4096) | (0 if self.delete is None or self.delete is False else 8192)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _join = bool(flags & 1)
        _leave = bool(flags & 2)
        _invite = bool(flags & 4)
        _ban = bool(flags & 8)
        _unban = bool(flags & 16)
        _kick = bool(flags & 32)
        _unkick = bool(flags & 64)
        _promote = bool(flags & 128)
        _demote = bool(flags & 256)
        _info = bool(flags & 512)
        _settings = bool(flags & 1024)
        _pinned = bool(flags & 2048)
        _edit = bool(flags & 4096)
        _delete = bool(flags & 8192)
        return ChannelAdminLogEventsFilter(join=_join, leave=_leave, invite=_invite, ban=_ban, unban=_unban, kick=_kick, unkick=_unkick, promote=_promote, demote=_demote, info=_info, settings=_settings, pinned=_pinned, edit=_edit, delete=_delete)


class ChannelAdminRights(TLObject):
    CONSTRUCTOR_ID = 0x5d7ceba5
    SUBCLASS_OF_ID = 0x2286545a

    def __init__(self, change_info=None, post_messages=None, edit_messages=None, delete_messages=None, ban_users=None, invite_users=None, invite_link=None, pin_messages=None, add_admins=None):
        """
        :param bool | None change_info:
        :param bool | None post_messages:
        :param bool | None edit_messages:
        :param bool | None delete_messages:
        :param bool | None ban_users:
        :param bool | None invite_users:
        :param bool | None invite_link:
        :param bool | None pin_messages:
        :param bool | None add_admins:

        Constructor for ChannelAdminRights: Instance of ChannelAdminRights.
        """
        super().__init__()

        self.change_info = change_info  # type: Optional[bool]
        self.post_messages = post_messages  # type: Optional[bool]
        self.edit_messages = edit_messages  # type: Optional[bool]
        self.delete_messages = delete_messages  # type: Optional[bool]
        self.ban_users = ban_users  # type: Optional[bool]
        self.invite_users = invite_users  # type: Optional[bool]
        self.invite_link = invite_link  # type: Optional[bool]
        self.pin_messages = pin_messages  # type: Optional[bool]
        self.add_admins = add_admins  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ChannelAdminRights',
            'change_info': self.change_info,
            'post_messages': self.post_messages,
            'edit_messages': self.edit_messages,
            'delete_messages': self.delete_messages,
            'ban_users': self.ban_users,
            'invite_users': self.invite_users,
            'invite_link': self.invite_link,
            'pin_messages': self.pin_messages,
            'add_admins': self.add_admins
        }

    def __bytes__(self):
        return b''.join((
            b'\xa5\xeb|]',
            struct.pack('<I', (0 if self.change_info is None or self.change_info is False else 1) | (0 if self.post_messages is None or self.post_messages is False else 2) | (0 if self.edit_messages is None or self.edit_messages is False else 4) | (0 if self.delete_messages is None or self.delete_messages is False else 8) | (0 if self.ban_users is None or self.ban_users is False else 16) | (0 if self.invite_users is None or self.invite_users is False else 32) | (0 if self.invite_link is None or self.invite_link is False else 64) | (0 if self.pin_messages is None or self.pin_messages is False else 128) | (0 if self.add_admins is None or self.add_admins is False else 512)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _change_info = bool(flags & 1)
        _post_messages = bool(flags & 2)
        _edit_messages = bool(flags & 4)
        _delete_messages = bool(flags & 8)
        _ban_users = bool(flags & 16)
        _invite_users = bool(flags & 32)
        _invite_link = bool(flags & 64)
        _pin_messages = bool(flags & 128)
        _add_admins = bool(flags & 512)
        return ChannelAdminRights(change_info=_change_info, post_messages=_post_messages, edit_messages=_edit_messages, delete_messages=_delete_messages, ban_users=_ban_users, invite_users=_invite_users, invite_link=_invite_link, pin_messages=_pin_messages, add_admins=_add_admins)


class ChannelBannedRights(TLObject):
    CONSTRUCTOR_ID = 0x58cf4249
    SUBCLASS_OF_ID = 0x5c474079

    def __init__(self, until_date, view_messages=None, send_messages=None, send_media=None, send_stickers=None, send_gifs=None, send_games=None, send_inline=None, embed_links=None):
        """
        :param bool | None view_messages:
        :param bool | None send_messages:
        :param bool | None send_media:
        :param bool | None send_stickers:
        :param bool | None send_gifs:
        :param bool | None send_games:
        :param bool | None send_inline:
        :param bool | None embed_links:
        :param datetime.datetime | None until_date:

        Constructor for ChannelBannedRights: Instance of ChannelBannedRights.
        """
        super().__init__()

        self.view_messages = view_messages  # type: Optional[bool]
        self.send_messages = send_messages  # type: Optional[bool]
        self.send_media = send_media  # type: Optional[bool]
        self.send_stickers = send_stickers  # type: Optional[bool]
        self.send_gifs = send_gifs  # type: Optional[bool]
        self.send_games = send_games  # type: Optional[bool]
        self.send_inline = send_inline  # type: Optional[bool]
        self.embed_links = embed_links  # type: Optional[bool]
        self.until_date = until_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChannelBannedRights',
            'view_messages': self.view_messages,
            'send_messages': self.send_messages,
            'send_media': self.send_media,
            'send_stickers': self.send_stickers,
            'send_gifs': self.send_gifs,
            'send_games': self.send_games,
            'send_inline': self.send_inline,
            'embed_links': self.embed_links,
            'until_date': self.until_date
        }

    def __bytes__(self):
        return b''.join((
            b'IB\xcfX',
            struct.pack('<I', (0 if self.view_messages is None or self.view_messages is False else 1) | (0 if self.send_messages is None or self.send_messages is False else 2) | (0 if self.send_media is None or self.send_media is False else 4) | (0 if self.send_stickers is None or self.send_stickers is False else 8) | (0 if self.send_gifs is None or self.send_gifs is False else 16) | (0 if self.send_games is None or self.send_games is False else 32) | (0 if self.send_inline is None or self.send_inline is False else 64) | (0 if self.embed_links is None or self.embed_links is False else 128)),
            TLObject.serialize_datetime(self.until_date),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _view_messages = bool(flags & 1)
        _send_messages = bool(flags & 2)
        _send_media = bool(flags & 4)
        _send_stickers = bool(flags & 8)
        _send_gifs = bool(flags & 16)
        _send_games = bool(flags & 32)
        _send_inline = bool(flags & 64)
        _embed_links = bool(flags & 128)
        _until_date = reader.tgread_date()
        return ChannelBannedRights(until_date=_until_date, view_messages=_view_messages, send_messages=_send_messages, send_media=_send_media, send_stickers=_send_stickers, send_gifs=_send_gifs, send_games=_send_games, send_inline=_send_inline, embed_links=_embed_links)


class ChannelForbidden(TLObject):
    CONSTRUCTOR_ID = 0x289da732
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, access_hash, title, broadcast=None, megagroup=None, until_date=None):
        """
        :param bool | None broadcast:
        :param bool | None megagroup:
        :param int id:
        :param int access_hash:
        :param str title:
        :param datetime.datetime | None until_date:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.broadcast = broadcast  # type: Optional[bool]
        self.megagroup = megagroup  # type: Optional[bool]
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.title = title  # type: str
        self.until_date = until_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChannelForbidden',
            'broadcast': self.broadcast,
            'megagroup': self.megagroup,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'until_date': self.until_date
        }

    def __bytes__(self):
        return b''.join((
            b'2\xa7\x9d(',
            struct.pack('<I', (0 if self.broadcast is None or self.broadcast is False else 32) | (0 if self.megagroup is None or self.megagroup is False else 256) | (0 if self.until_date is None or self.until_date is False else 65536)),
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_bytes(self.title),
            b'' if self.until_date is None or self.until_date is False else (TLObject.serialize_datetime(self.until_date)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _broadcast = bool(flags & 32)
        _megagroup = bool(flags & 256)
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _title = reader.tgread_string()
        if flags & 65536:
            _until_date = reader.tgread_date()
        else:
            _until_date = None
        return ChannelForbidden(id=_id, access_hash=_access_hash, title=_title, broadcast=_broadcast, megagroup=_megagroup, until_date=_until_date)


class ChannelFull(TLObject):
    CONSTRUCTOR_ID = 0x76af5481
    SUBCLASS_OF_ID = 0xd49a2697

    def __init__(self, id, about, read_inbox_max_id, read_outbox_max_id, unread_count, chat_photo, notify_settings, exported_invite, bot_info, can_view_participants=None, can_set_username=None, can_set_stickers=None, hidden_prehistory=None, participants_count=None, admins_count=None, kicked_count=None, banned_count=None, migrated_from_chat_id=None, migrated_from_max_id=None, pinned_msg_id=None, stickerset=None, available_min_id=None):
        """
        :param bool | None can_view_participants:
        :param bool | None can_set_username:
        :param bool | None can_set_stickers:
        :param bool | None hidden_prehistory:
        :param int id:
        :param str about:
        :param int | None participants_count:
        :param int | None admins_count:
        :param int | None kicked_count:
        :param int | None banned_count:
        :param int read_inbox_max_id:
        :param int read_outbox_max_id:
        :param int unread_count:
        :param Photo chat_photo:
        :param PeerNotifySettings notify_settings:
        :param ExportedChatInvite exported_invite:
        :param list[BotInfo] bot_info:
        :param int | None migrated_from_chat_id:
        :param int | None migrated_from_max_id:
        :param int | None pinned_msg_id:
        :param StickerSet | None stickerset:
        :param int | None available_min_id:

        Constructor for ChatFull: Instance of either ChatFull, ChannelFull.
        """
        super().__init__()

        self.can_view_participants = can_view_participants  # type: Optional[bool]
        self.can_set_username = can_set_username  # type: Optional[bool]
        self.can_set_stickers = can_set_stickers  # type: Optional[bool]
        self.hidden_prehistory = hidden_prehistory  # type: Optional[bool]
        self.id = id  # type: int
        self.about = about  # type: str
        self.participants_count = participants_count  # type: Optional[int]
        self.admins_count = admins_count  # type: Optional[int]
        self.kicked_count = kicked_count  # type: Optional[int]
        self.banned_count = banned_count  # type: Optional[int]
        self.read_inbox_max_id = read_inbox_max_id  # type: int
        self.read_outbox_max_id = read_outbox_max_id  # type: int
        self.unread_count = unread_count  # type: int
        self.chat_photo = chat_photo  # type: TypePhoto
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings
        self.exported_invite = exported_invite  # type: TypeExportedChatInvite
        self.bot_info = bot_info  # type: List[TypeBotInfo]
        self.migrated_from_chat_id = migrated_from_chat_id  # type: Optional[int]
        self.migrated_from_max_id = migrated_from_max_id  # type: Optional[int]
        self.pinned_msg_id = pinned_msg_id  # type: Optional[int]
        self.stickerset = stickerset  # type: Optional[TypeStickerSet]
        self.available_min_id = available_min_id  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'ChannelFull',
            'can_view_participants': self.can_view_participants,
            'can_set_username': self.can_set_username,
            'can_set_stickers': self.can_set_stickers,
            'hidden_prehistory': self.hidden_prehistory,
            'id': self.id,
            'about': self.about,
            'participants_count': self.participants_count,
            'admins_count': self.admins_count,
            'kicked_count': self.kicked_count,
            'banned_count': self.banned_count,
            'read_inbox_max_id': self.read_inbox_max_id,
            'read_outbox_max_id': self.read_outbox_max_id,
            'unread_count': self.unread_count,
            'chat_photo': None if self.chat_photo is None else self.chat_photo.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'exported_invite': None if self.exported_invite is None else self.exported_invite.to_dict(),
            'bot_info': [] if self.bot_info is None else [None if x is None else x.to_dict() for x in self.bot_info],
            'migrated_from_chat_id': self.migrated_from_chat_id,
            'migrated_from_max_id': self.migrated_from_max_id,
            'pinned_msg_id': self.pinned_msg_id,
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
            'available_min_id': self.available_min_id
        }

    def __bytes__(self):
        assert ((self.kicked_count or self.kicked_count is not None) and (self.banned_count or self.banned_count is not None)) or ((self.kicked_count is None or self.kicked_count is False) and (self.banned_count is None or self.banned_count is False)), 'kicked_count, banned_count parameters must all be False-y (like None) or all me True-y'
        assert ((self.migrated_from_chat_id or self.migrated_from_chat_id is not None) and (self.migrated_from_max_id or self.migrated_from_max_id is not None)) or ((self.migrated_from_chat_id is None or self.migrated_from_chat_id is False) and (self.migrated_from_max_id is None or self.migrated_from_max_id is False)), 'migrated_from_chat_id, migrated_from_max_id parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\x81T\xafv',
            struct.pack('<I', (0 if self.can_view_participants is None or self.can_view_participants is False else 8) | (0 if self.can_set_username is None or self.can_set_username is False else 64) | (0 if self.can_set_stickers is None or self.can_set_stickers is False else 128) | (0 if self.hidden_prehistory is None or self.hidden_prehistory is False else 1024) | (0 if self.participants_count is None or self.participants_count is False else 1) | (0 if self.admins_count is None or self.admins_count is False else 2) | (0 if self.kicked_count is None or self.kicked_count is False else 4) | (0 if self.banned_count is None or self.banned_count is False else 4) | (0 if self.migrated_from_chat_id is None or self.migrated_from_chat_id is False else 16) | (0 if self.migrated_from_max_id is None or self.migrated_from_max_id is False else 16) | (0 if self.pinned_msg_id is None or self.pinned_msg_id is False else 32) | (0 if self.stickerset is None or self.stickerset is False else 256) | (0 if self.available_min_id is None or self.available_min_id is False else 512)),
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.about),
            b'' if self.participants_count is None or self.participants_count is False else (struct.pack('<i', self.participants_count)),
            b'' if self.admins_count is None or self.admins_count is False else (struct.pack('<i', self.admins_count)),
            b'' if self.kicked_count is None or self.kicked_count is False else (struct.pack('<i', self.kicked_count)),
            b'' if self.banned_count is None or self.banned_count is False else (struct.pack('<i', self.banned_count)),
            struct.pack('<i', self.read_inbox_max_id),
            struct.pack('<i', self.read_outbox_max_id),
            struct.pack('<i', self.unread_count),
            bytes(self.chat_photo),
            bytes(self.notify_settings),
            bytes(self.exported_invite),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.bot_info)),b''.join(bytes(x) for x in self.bot_info),
            b'' if self.migrated_from_chat_id is None or self.migrated_from_chat_id is False else (struct.pack('<i', self.migrated_from_chat_id)),
            b'' if self.migrated_from_max_id is None or self.migrated_from_max_id is False else (struct.pack('<i', self.migrated_from_max_id)),
            b'' if self.pinned_msg_id is None or self.pinned_msg_id is False else (struct.pack('<i', self.pinned_msg_id)),
            b'' if self.stickerset is None or self.stickerset is False else (bytes(self.stickerset)),
            b'' if self.available_min_id is None or self.available_min_id is False else (struct.pack('<i', self.available_min_id)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _can_view_participants = bool(flags & 8)
        _can_set_username = bool(flags & 64)
        _can_set_stickers = bool(flags & 128)
        _hidden_prehistory = bool(flags & 1024)
        _id = reader.read_int()
        _about = reader.tgread_string()
        if flags & 1:
            _participants_count = reader.read_int()
        else:
            _participants_count = None
        if flags & 2:
            _admins_count = reader.read_int()
        else:
            _admins_count = None
        if flags & 4:
            _kicked_count = reader.read_int()
        else:
            _kicked_count = None
        if flags & 4:
            _banned_count = reader.read_int()
        else:
            _banned_count = None
        _read_inbox_max_id = reader.read_int()
        _read_outbox_max_id = reader.read_int()
        _unread_count = reader.read_int()
        _chat_photo = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        _exported_invite = reader.tgread_object()
        reader.read_int()
        _bot_info = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _bot_info.append(_x)

        if flags & 16:
            _migrated_from_chat_id = reader.read_int()
        else:
            _migrated_from_chat_id = None
        if flags & 16:
            _migrated_from_max_id = reader.read_int()
        else:
            _migrated_from_max_id = None
        if flags & 32:
            _pinned_msg_id = reader.read_int()
        else:
            _pinned_msg_id = None
        if flags & 256:
            _stickerset = reader.tgread_object()
        else:
            _stickerset = None
        if flags & 512:
            _available_min_id = reader.read_int()
        else:
            _available_min_id = None
        return ChannelFull(id=_id, about=_about, read_inbox_max_id=_read_inbox_max_id, read_outbox_max_id=_read_outbox_max_id, unread_count=_unread_count, chat_photo=_chat_photo, notify_settings=_notify_settings, exported_invite=_exported_invite, bot_info=_bot_info, can_view_participants=_can_view_participants, can_set_username=_can_set_username, can_set_stickers=_can_set_stickers, hidden_prehistory=_hidden_prehistory, participants_count=_participants_count, admins_count=_admins_count, kicked_count=_kicked_count, banned_count=_banned_count, migrated_from_chat_id=_migrated_from_chat_id, migrated_from_max_id=_migrated_from_max_id, pinned_msg_id=_pinned_msg_id, stickerset=_stickerset, available_min_id=_available_min_id)


class ChannelMessagesFilter(TLObject):
    CONSTRUCTOR_ID = 0xcd77d957
    SUBCLASS_OF_ID = 0x13336a56

    def __init__(self, ranges, exclude_new_messages=None):
        """
        :param bool | None exclude_new_messages:
        :param list[MessageRange] ranges:

        Constructor for ChannelMessagesFilter: Instance of either ChannelMessagesFilterEmpty, ChannelMessagesFilter.
        """
        super().__init__()

        self.exclude_new_messages = exclude_new_messages  # type: Optional[bool]
        self.ranges = ranges  # type: List[TypeMessageRange]

    def to_dict(self):
        return {
            '_': 'ChannelMessagesFilter',
            'exclude_new_messages': self.exclude_new_messages,
            'ranges': [] if self.ranges is None else [None if x is None else x.to_dict() for x in self.ranges]
        }

    def __bytes__(self):
        return b''.join((
            b'W\xd9w\xcd',
            struct.pack('<I', (0 if self.exclude_new_messages is None or self.exclude_new_messages is False else 2)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.ranges)),b''.join(bytes(x) for x in self.ranges),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _exclude_new_messages = bool(flags & 2)
        reader.read_int()
        _ranges = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _ranges.append(_x)

        return ChannelMessagesFilter(ranges=_ranges, exclude_new_messages=_exclude_new_messages)


class ChannelMessagesFilterEmpty(TLObject):
    CONSTRUCTOR_ID = 0x94d42ee7
    SUBCLASS_OF_ID = 0x13336a56

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ChannelMessagesFilterEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe7.\xd4\x94',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelMessagesFilterEmpty()


class ChannelParticipant(TLObject):
    CONSTRUCTOR_ID = 0x15ebac1d
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param datetime.datetime | None date:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChannelParticipant',
            'user_id': self.user_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\x1d\xac\xeb\x15',
            struct.pack('<i', self.user_id),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return ChannelParticipant(user_id=_user_id, date=_date)


class ChannelParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xa82fa898
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, inviter_id, promoted_by, date, admin_rights, can_edit=None):
        """
        :param bool | None can_edit:
        :param int user_id:
        :param int inviter_id:
        :param int promoted_by:
        :param datetime.datetime | None date:
        :param ChannelAdminRights admin_rights:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.can_edit = can_edit  # type: Optional[bool]
        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.promoted_by = promoted_by  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_rights = admin_rights  # type: TypeChannelAdminRights

    def to_dict(self):
        return {
            '_': 'ChannelParticipantAdmin',
            'can_edit': self.can_edit,
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'promoted_by': self.promoted_by,
            'date': self.date,
            'admin_rights': None if self.admin_rights is None else self.admin_rights.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x98\xa8/\xa8',
            struct.pack('<I', (0 if self.can_edit is None or self.can_edit is False else 1)),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            struct.pack('<i', self.promoted_by),
            TLObject.serialize_datetime(self.date),
            bytes(self.admin_rights),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _can_edit = bool(flags & 1)
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _promoted_by = reader.read_int()
        _date = reader.tgread_date()
        _admin_rights = reader.tgread_object()
        return ChannelParticipantAdmin(user_id=_user_id, inviter_id=_inviter_id, promoted_by=_promoted_by, date=_date, admin_rights=_admin_rights, can_edit=_can_edit)


class ChannelParticipantBanned(TLObject):
    CONSTRUCTOR_ID = 0x222c1886
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, kicked_by, date, banned_rights, left=None):
        """
        :param bool | None left:
        :param int user_id:
        :param int kicked_by:
        :param datetime.datetime | None date:
        :param ChannelBannedRights banned_rights:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.left = left  # type: Optional[bool]
        self.user_id = user_id  # type: int
        self.kicked_by = kicked_by  # type: int
        self.date = date  # type: Optional[datetime]
        self.banned_rights = banned_rights  # type: TypeChannelBannedRights

    def to_dict(self):
        return {
            '_': 'ChannelParticipantBanned',
            'left': self.left,
            'user_id': self.user_id,
            'kicked_by': self.kicked_by,
            'date': self.date,
            'banned_rights': None if self.banned_rights is None else self.banned_rights.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\x18,"',
            struct.pack('<I', (0 if self.left is None or self.left is False else 1)),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.kicked_by),
            TLObject.serialize_datetime(self.date),
            bytes(self.banned_rights),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _left = bool(flags & 1)
        _user_id = reader.read_int()
        _kicked_by = reader.read_int()
        _date = reader.tgread_date()
        _banned_rights = reader.tgread_object()
        return ChannelParticipantBanned(user_id=_user_id, kicked_by=_kicked_by, date=_date, banned_rights=_banned_rights, left=_left)


class ChannelParticipantCreator(TLObject):
    CONSTRUCTOR_ID = 0xe3e2e1f9
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'ChannelParticipantCreator',
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xf9\xe1\xe2\xe3',
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        return ChannelParticipantCreator(user_id=_user_id)


class ChannelParticipantSelf(TLObject):
    CONSTRUCTOR_ID = 0xa3289a6d
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param datetime.datetime | None date:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChannelParticipantSelf',
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'm\x9a(\xa3',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return ChannelParticipantSelf(user_id=_user_id, inviter_id=_inviter_id, date=_date)


class ChannelParticipantsAdmins(TLObject):
    CONSTRUCTOR_ID = 0xb4608969
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsAdmins'
        }

    def __bytes__(self):
        return b''.join((
            b'i\x89`\xb4',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelParticipantsAdmins()


class ChannelParticipantsBanned(TLObject):
    CONSTRUCTOR_ID = 0x1427a5e1
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsBanned',
            'q': self.q
        }

    def __bytes__(self):
        return b''.join((
            b"\xe1\xa5'\x14",
            TLObject.serialize_bytes(self.q),
        ))

    @staticmethod
    def from_reader(reader):
        _q = reader.tgread_string()
        return ChannelParticipantsBanned(q=_q)


class ChannelParticipantsBots(TLObject):
    CONSTRUCTOR_ID = 0xb0d1865b
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsBots'
        }

    def __bytes__(self):
        return b''.join((
            b'[\x86\xd1\xb0',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelParticipantsBots()


class ChannelParticipantsKicked(TLObject):
    CONSTRUCTOR_ID = 0xa3b54985
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsKicked',
            'q': self.q
        }

    def __bytes__(self):
        return b''.join((
            b'\x85I\xb5\xa3',
            TLObject.serialize_bytes(self.q),
        ))

    @staticmethod
    def from_reader(reader):
        _q = reader.tgread_string()
        return ChannelParticipantsKicked(q=_q)


class ChannelParticipantsRecent(TLObject):
    CONSTRUCTOR_ID = 0xde3f3c79
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsRecent'
        }

    def __bytes__(self):
        return b''.join((
            b'y<?\xde',
        ))

    @staticmethod
    def from_reader(reader):
        return ChannelParticipantsRecent()


class ChannelParticipantsSearch(TLObject):
    CONSTRUCTOR_ID = 0x656ac4b
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        super().__init__()

        self.q = q  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsSearch',
            'q': self.q
        }

    def __bytes__(self):
        return b''.join((
            b'K\xacV\x06',
            TLObject.serialize_bytes(self.q),
        ))

    @staticmethod
    def from_reader(reader):
        _q = reader.tgread_string()
        return ChannelParticipantsSearch(q=_q)


class Chat(TLObject):
    CONSTRUCTOR_ID = 0xd91cdd54
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title, photo, participants_count, date, version, creator=None, kicked=None, left=None, admins_enabled=None, admin=None, deactivated=None, migrated_to=None):
        """
        :param bool | None creator:
        :param bool | None kicked:
        :param bool | None left:
        :param bool | None admins_enabled:
        :param bool | None admin:
        :param bool | None deactivated:
        :param int id:
        :param str title:
        :param ChatPhoto photo:
        :param int participants_count:
        :param datetime.datetime | None date:
        :param int version:
        :param InputChannel | None migrated_to:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.creator = creator  # type: Optional[bool]
        self.kicked = kicked  # type: Optional[bool]
        self.left = left  # type: Optional[bool]
        self.admins_enabled = admins_enabled  # type: Optional[bool]
        self.admin = admin  # type: Optional[bool]
        self.deactivated = deactivated  # type: Optional[bool]
        self.id = id  # type: int
        self.title = title  # type: str
        self.photo = photo  # type: TypeChatPhoto
        self.participants_count = participants_count  # type: int
        self.date = date  # type: Optional[datetime]
        self.version = version  # type: int
        self.migrated_to = migrated_to  # type: Optional[TypeInputChannel]

    def resolve(self, client, utils):
        self.migrated_to = utils.get_input_channel(client.get_input_entity(self.migrated_to)) if self.migrated_to else None

    def to_dict(self):
        return {
            '_': 'Chat',
            'creator': self.creator,
            'kicked': self.kicked,
            'left': self.left,
            'admins_enabled': self.admins_enabled,
            'admin': self.admin,
            'deactivated': self.deactivated,
            'id': self.id,
            'title': self.title,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'participants_count': self.participants_count,
            'date': self.date,
            'version': self.version,
            'migrated_to': None if self.migrated_to is None else self.migrated_to.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'T\xdd\x1c\xd9',
            struct.pack('<I', (0 if self.creator is None or self.creator is False else 1) | (0 if self.kicked is None or self.kicked is False else 2) | (0 if self.left is None or self.left is False else 4) | (0 if self.admins_enabled is None or self.admins_enabled is False else 8) | (0 if self.admin is None or self.admin is False else 16) | (0 if self.deactivated is None or self.deactivated is False else 32) | (0 if self.migrated_to is None or self.migrated_to is False else 64)),
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.title),
            bytes(self.photo),
            struct.pack('<i', self.participants_count),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.version),
            b'' if self.migrated_to is None or self.migrated_to is False else (bytes(self.migrated_to)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _creator = bool(flags & 1)
        _kicked = bool(flags & 2)
        _left = bool(flags & 4)
        _admins_enabled = bool(flags & 8)
        _admin = bool(flags & 16)
        _deactivated = bool(flags & 32)
        _id = reader.read_int()
        _title = reader.tgread_string()
        _photo = reader.tgread_object()
        _participants_count = reader.read_int()
        _date = reader.tgread_date()
        _version = reader.read_int()
        if flags & 64:
            _migrated_to = reader.tgread_object()
        else:
            _migrated_to = None
        return Chat(id=_id, title=_title, photo=_photo, participants_count=_participants_count, date=_date, version=_version, creator=_creator, kicked=_kicked, left=_left, admins_enabled=_admins_enabled, admin=_admin, deactivated=_deactivated, migrated_to=_migrated_to)


class ChatEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9ba2d800
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id):
        """
        :param int id:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'ChatEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\xd8\xa2\x9b',
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return ChatEmpty(id=_id)


class ChatForbidden(TLObject):
    CONSTRUCTOR_ID = 0x7328bdb
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title):
        """
        :param int id:
        :param str title:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        super().__init__()

        self.id = id  # type: int
        self.title = title  # type: str

    def to_dict(self):
        return {
            '_': 'ChatForbidden',
            'id': self.id,
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\x8b2\x07',
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        return ChatForbidden(id=_id, title=_title)


class ChatFull(TLObject):
    CONSTRUCTOR_ID = 0x2e02a614
    SUBCLASS_OF_ID = 0xd49a2697

    def __init__(self, id, participants, chat_photo, notify_settings, exported_invite, bot_info):
        """
        :param int id:
        :param ChatParticipants participants:
        :param Photo chat_photo:
        :param PeerNotifySettings notify_settings:
        :param ExportedChatInvite exported_invite:
        :param list[BotInfo] bot_info:

        Constructor for ChatFull: Instance of either ChatFull, ChannelFull.
        """
        super().__init__()

        self.id = id  # type: int
        self.participants = participants  # type: TypeChatParticipants
        self.chat_photo = chat_photo  # type: TypePhoto
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings
        self.exported_invite = exported_invite  # type: TypeExportedChatInvite
        self.bot_info = bot_info  # type: List[TypeBotInfo]

    def to_dict(self):
        return {
            '_': 'ChatFull',
            'id': self.id,
            'participants': None if self.participants is None else self.participants.to_dict(),
            'chat_photo': None if self.chat_photo is None else self.chat_photo.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'exported_invite': None if self.exported_invite is None else self.exported_invite.to_dict(),
            'bot_info': [] if self.bot_info is None else [None if x is None else x.to_dict() for x in self.bot_info]
        }

    def __bytes__(self):
        return b''.join((
            b'\x14\xa6\x02.',
            struct.pack('<i', self.id),
            bytes(self.participants),
            bytes(self.chat_photo),
            bytes(self.notify_settings),
            bytes(self.exported_invite),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.bot_info)),b''.join(bytes(x) for x in self.bot_info),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _participants = reader.tgread_object()
        _chat_photo = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        _exported_invite = reader.tgread_object()
        reader.read_int()
        _bot_info = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _bot_info.append(_x)

        return ChatFull(id=_id, participants=_participants, chat_photo=_chat_photo, notify_settings=_notify_settings, exported_invite=_exported_invite, bot_info=_bot_info)


class ChatInvite(TLObject):
    CONSTRUCTOR_ID = 0xdb74f558
    SUBCLASS_OF_ID = 0x4561736

    def __init__(self, title, photo, participants_count, channel=None, broadcast=None, public=None, megagroup=None, participants=None):
        """
        :param bool | None channel:
        :param bool | None broadcast:
        :param bool | None public:
        :param bool | None megagroup:
        :param str title:
        :param ChatPhoto photo:
        :param int participants_count:
        :param list[User] | None participants:

        Constructor for ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()

        self.channel = channel  # type: Optional[bool]
        self.broadcast = broadcast  # type: Optional[bool]
        self.public = public  # type: Optional[bool]
        self.megagroup = megagroup  # type: Optional[bool]
        self.title = title  # type: str
        self.photo = photo  # type: TypeChatPhoto
        self.participants_count = participants_count  # type: int
        self.participants = participants  # type: Optional[List[TypeUser]]

    def to_dict(self):
        return {
            '_': 'ChatInvite',
            'channel': self.channel,
            'broadcast': self.broadcast,
            'public': self.public,
            'megagroup': self.megagroup,
            'title': self.title,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'participants_count': self.participants_count,
            'participants': [] if self.participants is None else [None if x is None else x.to_dict() for x in self.participants]
        }

    def __bytes__(self):
        return b''.join((
            b'X\xf5t\xdb',
            struct.pack('<I', (0 if self.channel is None or self.channel is False else 1) | (0 if self.broadcast is None or self.broadcast is False else 2) | (0 if self.public is None or self.public is False else 4) | (0 if self.megagroup is None or self.megagroup is False else 8) | (0 if self.participants is None or self.participants is False else 16)),
            TLObject.serialize_bytes(self.title),
            bytes(self.photo),
            struct.pack('<i', self.participants_count),
            b'' if self.participants is None or self.participants is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.participants)),b''.join(bytes(x) for x in self.participants))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _channel = bool(flags & 1)
        _broadcast = bool(flags & 2)
        _public = bool(flags & 4)
        _megagroup = bool(flags & 8)
        _title = reader.tgread_string()
        _photo = reader.tgread_object()
        _participants_count = reader.read_int()
        if flags & 16:
            reader.read_int()
            _participants = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _participants.append(_x)

        else:
            _participants = None
        return ChatInvite(title=_title, photo=_photo, participants_count=_participants_count, channel=_channel, broadcast=_broadcast, public=_public, megagroup=_megagroup, participants=_participants)


class ChatInviteAlready(TLObject):
    CONSTRUCTOR_ID = 0x5a686d7c
    SUBCLASS_OF_ID = 0x4561736

    def __init__(self, chat):
        """
        :param Chat chat:

        Constructor for ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        super().__init__()

        self.chat = chat  # type: TypeChat

    def to_dict(self):
        return {
            '_': 'ChatInviteAlready',
            'chat': None if self.chat is None else self.chat.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'|mhZ',
            bytes(self.chat),
        ))

    @staticmethod
    def from_reader(reader):
        _chat = reader.tgread_object()
        return ChatInviteAlready(chat=_chat)


class ChatInviteEmpty(TLObject):
    CONSTRUCTOR_ID = 0x69df3769
    SUBCLASS_OF_ID = 0xb4748a58

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ChatInviteEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'i7\xdfi',
        ))

    @staticmethod
    def from_reader(reader):
        return ChatInviteEmpty()


class ChatInviteExported(TLObject):
    CONSTRUCTOR_ID = 0xfc2e05bc
    SUBCLASS_OF_ID = 0xb4748a58

    def __init__(self, link):
        """
        :param str link:

        Constructor for ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        super().__init__()

        self.link = link  # type: str

    def to_dict(self):
        return {
            '_': 'ChatInviteExported',
            'link': self.link
        }

    def __bytes__(self):
        return b''.join((
            b'\xbc\x05.\xfc',
            TLObject.serialize_bytes(self.link),
        ))

    @staticmethod
    def from_reader(reader):
        _link = reader.tgread_string()
        return ChatInviteExported(link=_link)


class ChatParticipant(TLObject):
    CONSTRUCTOR_ID = 0xc8d7493e
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param datetime.datetime | None date:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChatParticipant',
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'>I\xd7\xc8',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return ChatParticipant(user_id=_user_id, inviter_id=_inviter_id, date=_date)


class ChatParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xe2d6e436
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param datetime.datetime | None date:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChatParticipantAdmin',
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'6\xe4\xd6\xe2',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return ChatParticipantAdmin(user_id=_user_id, inviter_id=_inviter_id, date=_date)


class ChatParticipantCreator(TLObject):
    CONSTRUCTOR_ID = 0xda13538a
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        super().__init__()

        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'ChatParticipantCreator',
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x8aS\x13\xda',
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        return ChatParticipantCreator(user_id=_user_id)


class ChatParticipants(TLObject):
    CONSTRUCTOR_ID = 0x3f460fed
    SUBCLASS_OF_ID = 0x1fa89571

    def __init__(self, chat_id, participants, version):
        """
        :param int chat_id:
        :param list[ChatParticipant] participants:
        :param int version:

        Constructor for ChatParticipants: Instance of either ChatParticipantsForbidden, ChatParticipants.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.participants = participants  # type: List[TypeChatParticipant]
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'ChatParticipants',
            'chat_id': self.chat_id,
            'participants': [] if self.participants is None else [None if x is None else x.to_dict() for x in self.participants],
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'\xed\x0fF?',
            struct.pack('<i', self.chat_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.participants)),b''.join(bytes(x) for x in self.participants),
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        reader.read_int()
        _participants = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _participants.append(_x)

        _version = reader.read_int()
        return ChatParticipants(chat_id=_chat_id, participants=_participants, version=_version)


class ChatParticipantsForbidden(TLObject):
    CONSTRUCTOR_ID = 0xfc900c2b
    SUBCLASS_OF_ID = 0x1fa89571

    def __init__(self, chat_id, self_participant=None):
        """
        :param int chat_id:
        :param ChatParticipant | None self_participant:

        Constructor for ChatParticipants: Instance of either ChatParticipantsForbidden, ChatParticipants.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.self_participant = self_participant  # type: Optional[TypeChatParticipant]

    def to_dict(self):
        return {
            '_': 'ChatParticipantsForbidden',
            'chat_id': self.chat_id,
            'self_participant': None if self.self_participant is None else self.self_participant.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'+\x0c\x90\xfc',
            struct.pack('<I', (0 if self.self_participant is None or self.self_participant is False else 1)),
            struct.pack('<i', self.chat_id),
            b'' if self.self_participant is None or self.self_participant is False else (bytes(self.self_participant)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _chat_id = reader.read_int()
        if flags & 1:
            _self_participant = reader.tgread_object()
        else:
            _self_participant = None
        return ChatParticipantsForbidden(chat_id=_chat_id, self_participant=_self_participant)


class ChatPhoto(TLObject):
    CONSTRUCTOR_ID = 0x6153276a
    SUBCLASS_OF_ID = 0xac3ec4e5

    def __init__(self, photo_small, photo_big):
        """
        :param FileLocation photo_small:
        :param FileLocation photo_big:

        Constructor for ChatPhoto: Instance of either ChatPhotoEmpty, ChatPhoto.
        """
        super().__init__()

        self.photo_small = photo_small  # type: TypeFileLocation
        self.photo_big = photo_big  # type: TypeFileLocation

    def to_dict(self):
        return {
            '_': 'ChatPhoto',
            'photo_small': None if self.photo_small is None else self.photo_small.to_dict(),
            'photo_big': None if self.photo_big is None else self.photo_big.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b"j'Sa",
            bytes(self.photo_small),
            bytes(self.photo_big),
        ))

    @staticmethod
    def from_reader(reader):
        _photo_small = reader.tgread_object()
        _photo_big = reader.tgread_object()
        return ChatPhoto(photo_small=_photo_small, photo_big=_photo_big)


class ChatPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x37c1011c
    SUBCLASS_OF_ID = 0xac3ec4e5

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ChatPhotoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\x01\xc17',
        ))

    @staticmethod
    def from_reader(reader):
        return ChatPhotoEmpty()


class ClientDHInnerData(TLObject):
    CONSTRUCTOR_ID = 0x6643b654
    SUBCLASS_OF_ID = 0xf8eeef6a

    def __init__(self, nonce, server_nonce, retry_id, g_b):
        """
        :param int nonce:
        :param int server_nonce:
        :param int retry_id:
        :param bytes g_b:

        Constructor for Client_DH_Inner_Data: Instance of ClientDHInnerData.
        """
        super().__init__()

        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.retry_id = retry_id  # type: int
        self.g_b = g_b  # type: bytes

    def to_dict(self):
        return {
            '_': 'ClientDHInnerData',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'retry_id': self.retry_id,
            'g_b': self.g_b
        }

    def __bytes__(self):
        return b''.join((
            b'T\xb6Cf',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            struct.pack('<q', self.retry_id),
            TLObject.serialize_bytes(self.g_b),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _retry_id = reader.read_long()
        _g_b = reader.tgread_bytes()
        return ClientDHInnerData(nonce=_nonce, server_nonce=_server_nonce, retry_id=_retry_id, g_b=_g_b)


class Config(TLObject):
    CONSTRUCTOR_ID = 0x9c840964
    SUBCLASS_OF_ID = 0xd3262a4a

    def __init__(self, date, expires, test_mode, this_dc, dc_options, chat_size_max, megagroup_size_max, forwarded_count_max, online_update_period_ms, offline_blur_timeout_ms, offline_idle_timeout_ms, online_cloud_timeout_ms, notify_cloud_delay_ms, notify_default_delay_ms, chat_big_size, push_chat_period_ms, push_chat_limit, saved_gifs_limit, edit_time_limit, rating_e_decay, stickers_recent_limit, stickers_faved_limit, channels_read_media_period, pinned_dialogs_count_max, call_receive_timeout_ms, call_ring_timeout_ms, call_connect_timeout_ms, call_packet_timeout_ms, me_url_prefix, disabled_features, phonecalls_enabled=None, default_p2p_contacts=None, tmp_sessions=None, suggested_lang_code=None, lang_pack_version=None):
        """
        :param bool | None phonecalls_enabled:
        :param bool | None default_p2p_contacts:
        :param datetime.datetime | None date:
        :param datetime.datetime | None expires:
        :param Bool test_mode:
        :param int this_dc:
        :param list[DcOption] dc_options:
        :param int chat_size_max:
        :param int megagroup_size_max:
        :param int forwarded_count_max:
        :param int online_update_period_ms:
        :param int offline_blur_timeout_ms:
        :param int offline_idle_timeout_ms:
        :param int online_cloud_timeout_ms:
        :param int notify_cloud_delay_ms:
        :param int notify_default_delay_ms:
        :param int chat_big_size:
        :param int push_chat_period_ms:
        :param int push_chat_limit:
        :param int saved_gifs_limit:
        :param int edit_time_limit:
        :param int rating_e_decay:
        :param int stickers_recent_limit:
        :param int stickers_faved_limit:
        :param int channels_read_media_period:
        :param int | None tmp_sessions:
        :param int pinned_dialogs_count_max:
        :param int call_receive_timeout_ms:
        :param int call_ring_timeout_ms:
        :param int call_connect_timeout_ms:
        :param int call_packet_timeout_ms:
        :param str me_url_prefix:
        :param str | None suggested_lang_code:
        :param int | None lang_pack_version:
        :param list[DisabledFeature] disabled_features:

        Constructor for Config: Instance of Config.
        """
        super().__init__()

        self.phonecalls_enabled = phonecalls_enabled  # type: Optional[bool]
        self.default_p2p_contacts = default_p2p_contacts  # type: Optional[bool]
        self.date = date  # type: Optional[datetime]
        self.expires = expires  # type: Optional[datetime]
        self.test_mode = test_mode  # type: TypeBool
        self.this_dc = this_dc  # type: int
        self.dc_options = dc_options  # type: List[TypeDcOption]
        self.chat_size_max = chat_size_max  # type: int
        self.megagroup_size_max = megagroup_size_max  # type: int
        self.forwarded_count_max = forwarded_count_max  # type: int
        self.online_update_period_ms = online_update_period_ms  # type: int
        self.offline_blur_timeout_ms = offline_blur_timeout_ms  # type: int
        self.offline_idle_timeout_ms = offline_idle_timeout_ms  # type: int
        self.online_cloud_timeout_ms = online_cloud_timeout_ms  # type: int
        self.notify_cloud_delay_ms = notify_cloud_delay_ms  # type: int
        self.notify_default_delay_ms = notify_default_delay_ms  # type: int
        self.chat_big_size = chat_big_size  # type: int
        self.push_chat_period_ms = push_chat_period_ms  # type: int
        self.push_chat_limit = push_chat_limit  # type: int
        self.saved_gifs_limit = saved_gifs_limit  # type: int
        self.edit_time_limit = edit_time_limit  # type: int
        self.rating_e_decay = rating_e_decay  # type: int
        self.stickers_recent_limit = stickers_recent_limit  # type: int
        self.stickers_faved_limit = stickers_faved_limit  # type: int
        self.channels_read_media_period = channels_read_media_period  # type: int
        self.tmp_sessions = tmp_sessions  # type: Optional[int]
        self.pinned_dialogs_count_max = pinned_dialogs_count_max  # type: int
        self.call_receive_timeout_ms = call_receive_timeout_ms  # type: int
        self.call_ring_timeout_ms = call_ring_timeout_ms  # type: int
        self.call_connect_timeout_ms = call_connect_timeout_ms  # type: int
        self.call_packet_timeout_ms = call_packet_timeout_ms  # type: int
        self.me_url_prefix = me_url_prefix  # type: str
        self.suggested_lang_code = suggested_lang_code  # type: Optional[str]
        self.lang_pack_version = lang_pack_version  # type: Optional[int]
        self.disabled_features = disabled_features  # type: List[TypeDisabledFeature]

    def to_dict(self):
        return {
            '_': 'Config',
            'phonecalls_enabled': self.phonecalls_enabled,
            'default_p2p_contacts': self.default_p2p_contacts,
            'date': self.date,
            'expires': self.expires,
            'test_mode': self.test_mode,
            'this_dc': self.this_dc,
            'dc_options': [] if self.dc_options is None else [None if x is None else x.to_dict() for x in self.dc_options],
            'chat_size_max': self.chat_size_max,
            'megagroup_size_max': self.megagroup_size_max,
            'forwarded_count_max': self.forwarded_count_max,
            'online_update_period_ms': self.online_update_period_ms,
            'offline_blur_timeout_ms': self.offline_blur_timeout_ms,
            'offline_idle_timeout_ms': self.offline_idle_timeout_ms,
            'online_cloud_timeout_ms': self.online_cloud_timeout_ms,
            'notify_cloud_delay_ms': self.notify_cloud_delay_ms,
            'notify_default_delay_ms': self.notify_default_delay_ms,
            'chat_big_size': self.chat_big_size,
            'push_chat_period_ms': self.push_chat_period_ms,
            'push_chat_limit': self.push_chat_limit,
            'saved_gifs_limit': self.saved_gifs_limit,
            'edit_time_limit': self.edit_time_limit,
            'rating_e_decay': self.rating_e_decay,
            'stickers_recent_limit': self.stickers_recent_limit,
            'stickers_faved_limit': self.stickers_faved_limit,
            'channels_read_media_period': self.channels_read_media_period,
            'tmp_sessions': self.tmp_sessions,
            'pinned_dialogs_count_max': self.pinned_dialogs_count_max,
            'call_receive_timeout_ms': self.call_receive_timeout_ms,
            'call_ring_timeout_ms': self.call_ring_timeout_ms,
            'call_connect_timeout_ms': self.call_connect_timeout_ms,
            'call_packet_timeout_ms': self.call_packet_timeout_ms,
            'me_url_prefix': self.me_url_prefix,
            'suggested_lang_code': self.suggested_lang_code,
            'lang_pack_version': self.lang_pack_version,
            'disabled_features': [] if self.disabled_features is None else [None if x is None else x.to_dict() for x in self.disabled_features]
        }

    def __bytes__(self):
        assert ((self.suggested_lang_code or self.suggested_lang_code is not None) and (self.lang_pack_version or self.lang_pack_version is not None)) or ((self.suggested_lang_code is None or self.suggested_lang_code is False) and (self.lang_pack_version is None or self.lang_pack_version is False)), 'suggested_lang_code, lang_pack_version parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'd\t\x84\x9c',
            struct.pack('<I', (0 if self.phonecalls_enabled is None or self.phonecalls_enabled is False else 2) | (0 if self.default_p2p_contacts is None or self.default_p2p_contacts is False else 8) | (0 if self.tmp_sessions is None or self.tmp_sessions is False else 1) | (0 if self.suggested_lang_code is None or self.suggested_lang_code is False else 4) | (0 if self.lang_pack_version is None or self.lang_pack_version is False else 4)),
            TLObject.serialize_datetime(self.date),
            TLObject.serialize_datetime(self.expires),
            b'\xb5ur\x99' if self.test_mode else b'7\x97y\xbc',
            struct.pack('<i', self.this_dc),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dc_options)),b''.join(bytes(x) for x in self.dc_options),
            struct.pack('<i', self.chat_size_max),
            struct.pack('<i', self.megagroup_size_max),
            struct.pack('<i', self.forwarded_count_max),
            struct.pack('<i', self.online_update_period_ms),
            struct.pack('<i', self.offline_blur_timeout_ms),
            struct.pack('<i', self.offline_idle_timeout_ms),
            struct.pack('<i', self.online_cloud_timeout_ms),
            struct.pack('<i', self.notify_cloud_delay_ms),
            struct.pack('<i', self.notify_default_delay_ms),
            struct.pack('<i', self.chat_big_size),
            struct.pack('<i', self.push_chat_period_ms),
            struct.pack('<i', self.push_chat_limit),
            struct.pack('<i', self.saved_gifs_limit),
            struct.pack('<i', self.edit_time_limit),
            struct.pack('<i', self.rating_e_decay),
            struct.pack('<i', self.stickers_recent_limit),
            struct.pack('<i', self.stickers_faved_limit),
            struct.pack('<i', self.channels_read_media_period),
            b'' if self.tmp_sessions is None or self.tmp_sessions is False else (struct.pack('<i', self.tmp_sessions)),
            struct.pack('<i', self.pinned_dialogs_count_max),
            struct.pack('<i', self.call_receive_timeout_ms),
            struct.pack('<i', self.call_ring_timeout_ms),
            struct.pack('<i', self.call_connect_timeout_ms),
            struct.pack('<i', self.call_packet_timeout_ms),
            TLObject.serialize_bytes(self.me_url_prefix),
            b'' if self.suggested_lang_code is None or self.suggested_lang_code is False else (TLObject.serialize_bytes(self.suggested_lang_code)),
            b'' if self.lang_pack_version is None or self.lang_pack_version is False else (struct.pack('<i', self.lang_pack_version)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.disabled_features)),b''.join(bytes(x) for x in self.disabled_features),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _phonecalls_enabled = bool(flags & 2)
        _default_p2p_contacts = bool(flags & 8)
        _date = reader.tgread_date()
        _expires = reader.tgread_date()
        _test_mode = reader.tgread_bool()
        _this_dc = reader.read_int()
        reader.read_int()
        _dc_options = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dc_options.append(_x)

        _chat_size_max = reader.read_int()
        _megagroup_size_max = reader.read_int()
        _forwarded_count_max = reader.read_int()
        _online_update_period_ms = reader.read_int()
        _offline_blur_timeout_ms = reader.read_int()
        _offline_idle_timeout_ms = reader.read_int()
        _online_cloud_timeout_ms = reader.read_int()
        _notify_cloud_delay_ms = reader.read_int()
        _notify_default_delay_ms = reader.read_int()
        _chat_big_size = reader.read_int()
        _push_chat_period_ms = reader.read_int()
        _push_chat_limit = reader.read_int()
        _saved_gifs_limit = reader.read_int()
        _edit_time_limit = reader.read_int()
        _rating_e_decay = reader.read_int()
        _stickers_recent_limit = reader.read_int()
        _stickers_faved_limit = reader.read_int()
        _channels_read_media_period = reader.read_int()
        if flags & 1:
            _tmp_sessions = reader.read_int()
        else:
            _tmp_sessions = None
        _pinned_dialogs_count_max = reader.read_int()
        _call_receive_timeout_ms = reader.read_int()
        _call_ring_timeout_ms = reader.read_int()
        _call_connect_timeout_ms = reader.read_int()
        _call_packet_timeout_ms = reader.read_int()
        _me_url_prefix = reader.tgread_string()
        if flags & 4:
            _suggested_lang_code = reader.tgread_string()
        else:
            _suggested_lang_code = None
        if flags & 4:
            _lang_pack_version = reader.read_int()
        else:
            _lang_pack_version = None
        reader.read_int()
        _disabled_features = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _disabled_features.append(_x)

        return Config(date=_date, expires=_expires, test_mode=_test_mode, this_dc=_this_dc, dc_options=_dc_options, chat_size_max=_chat_size_max, megagroup_size_max=_megagroup_size_max, forwarded_count_max=_forwarded_count_max, online_update_period_ms=_online_update_period_ms, offline_blur_timeout_ms=_offline_blur_timeout_ms, offline_idle_timeout_ms=_offline_idle_timeout_ms, online_cloud_timeout_ms=_online_cloud_timeout_ms, notify_cloud_delay_ms=_notify_cloud_delay_ms, notify_default_delay_ms=_notify_default_delay_ms, chat_big_size=_chat_big_size, push_chat_period_ms=_push_chat_period_ms, push_chat_limit=_push_chat_limit, saved_gifs_limit=_saved_gifs_limit, edit_time_limit=_edit_time_limit, rating_e_decay=_rating_e_decay, stickers_recent_limit=_stickers_recent_limit, stickers_faved_limit=_stickers_faved_limit, channels_read_media_period=_channels_read_media_period, pinned_dialogs_count_max=_pinned_dialogs_count_max, call_receive_timeout_ms=_call_receive_timeout_ms, call_ring_timeout_ms=_call_ring_timeout_ms, call_connect_timeout_ms=_call_connect_timeout_ms, call_packet_timeout_ms=_call_packet_timeout_ms, me_url_prefix=_me_url_prefix, disabled_features=_disabled_features, phonecalls_enabled=_phonecalls_enabled, default_p2p_contacts=_default_p2p_contacts, tmp_sessions=_tmp_sessions, suggested_lang_code=_suggested_lang_code, lang_pack_version=_lang_pack_version)


class Contact(TLObject):
    CONSTRUCTOR_ID = 0xf911c994
    SUBCLASS_OF_ID = 0x83dfdfa4

    def __init__(self, user_id, mutual):
        """
        :param int user_id:
        :param Bool mutual:

        Constructor for Contact: Instance of Contact.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.mutual = mutual  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'Contact',
            'user_id': self.user_id,
            'mutual': self.mutual
        }

    def __bytes__(self):
        return b''.join((
            b'\x94\xc9\x11\xf9',
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.mutual else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _mutual = reader.tgread_bool()
        return Contact(user_id=_user_id, mutual=_mutual)


class ContactBlocked(TLObject):
    CONSTRUCTOR_ID = 0x561bc879
    SUBCLASS_OF_ID = 0xb12d7ac6

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param datetime.datetime | None date:

        Constructor for ContactBlocked: Instance of ContactBlocked.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ContactBlocked',
            'user_id': self.user_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'y\xc8\x1bV',
            struct.pack('<i', self.user_id),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return ContactBlocked(user_id=_user_id, date=_date)


class ContactLinkContact(TLObject):
    CONSTRUCTOR_ID = 0xd502c2d0
    SUBCLASS_OF_ID = 0xa053c1da

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ContactLinkContact'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\xc2\x02\xd5',
        ))

    @staticmethod
    def from_reader(reader):
        return ContactLinkContact()


class ContactLinkHasPhone(TLObject):
    CONSTRUCTOR_ID = 0x268f3f59
    SUBCLASS_OF_ID = 0xa053c1da

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ContactLinkHasPhone'
        }

    def __bytes__(self):
        return b''.join((
            b'Y?\x8f&',
        ))

    @staticmethod
    def from_reader(reader):
        return ContactLinkHasPhone()


class ContactLinkNone(TLObject):
    CONSTRUCTOR_ID = 0xfeedd3ad
    SUBCLASS_OF_ID = 0xa053c1da

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ContactLinkNone'
        }

    def __bytes__(self):
        return b''.join((
            b'\xad\xd3\xed\xfe',
        ))

    @staticmethod
    def from_reader(reader):
        return ContactLinkNone()


class ContactLinkUnknown(TLObject):
    CONSTRUCTOR_ID = 0x5f4f9247
    SUBCLASS_OF_ID = 0xa053c1da

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'ContactLinkUnknown'
        }

    def __bytes__(self):
        return b''.join((
            b'G\x92O_',
        ))

    @staticmethod
    def from_reader(reader):
        return ContactLinkUnknown()


class ContactStatus(TLObject):
    CONSTRUCTOR_ID = 0xd3680c61
    SUBCLASS_OF_ID = 0x68c0d74c

    def __init__(self, user_id, status):
        """
        :param int user_id:
        :param UserStatus status:

        Constructor for ContactStatus: Instance of ContactStatus.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.status = status  # type: TypeUserStatus

    def to_dict(self):
        return {
            '_': 'ContactStatus',
            'user_id': self.user_id,
            'status': None if self.status is None else self.status.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'a\x0ch\xd3',
            struct.pack('<i', self.user_id),
            bytes(self.status),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _status = reader.tgread_object()
        return ContactStatus(user_id=_user_id, status=_status)


class DataJSON(TLObject):
    CONSTRUCTOR_ID = 0x7d748d04
    SUBCLASS_OF_ID = 0xad0352e8

    def __init__(self, data):
        """
        :param str data:

        Constructor for DataJSON: Instance of DataJSON.
        """
        super().__init__()

        self.data = data  # type: str

    def to_dict(self):
        return {
            '_': 'DataJSON',
            'data': self.data
        }

    def __bytes__(self):
        return b''.join((
            b'\x04\x8dt}',
            TLObject.serialize_bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _data = reader.tgread_string()
        return DataJSON(data=_data)


class DcOption(TLObject):
    CONSTRUCTOR_ID = 0x5d8c6cc
    SUBCLASS_OF_ID = 0x9e43e123

    def __init__(self, id, ip_address, port, ipv6=None, media_only=None, tcpo_only=None, cdn=None, static=None):
        """
        :param bool | None ipv6:
        :param bool | None media_only:
        :param bool | None tcpo_only:
        :param bool | None cdn:
        :param bool | None static:
        :param int id:
        :param str ip_address:
        :param int port:

        Constructor for DcOption: Instance of DcOption.
        """
        super().__init__()

        self.ipv6 = ipv6  # type: Optional[bool]
        self.media_only = media_only  # type: Optional[bool]
        self.tcpo_only = tcpo_only  # type: Optional[bool]
        self.cdn = cdn  # type: Optional[bool]
        self.static = static  # type: Optional[bool]
        self.id = id  # type: int
        self.ip_address = ip_address  # type: str
        self.port = port  # type: int

    def to_dict(self):
        return {
            '_': 'DcOption',
            'ipv6': self.ipv6,
            'media_only': self.media_only,
            'tcpo_only': self.tcpo_only,
            'cdn': self.cdn,
            'static': self.static,
            'id': self.id,
            'ip_address': self.ip_address,
            'port': self.port
        }

    def __bytes__(self):
        return b''.join((
            b'\xcc\xc6\xd8\x05',
            struct.pack('<I', (0 if self.ipv6 is None or self.ipv6 is False else 1) | (0 if self.media_only is None or self.media_only is False else 2) | (0 if self.tcpo_only is None or self.tcpo_only is False else 4) | (0 if self.cdn is None or self.cdn is False else 8) | (0 if self.static is None or self.static is False else 16)),
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.ip_address),
            struct.pack('<i', self.port),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _ipv6 = bool(flags & 1)
        _media_only = bool(flags & 2)
        _tcpo_only = bool(flags & 4)
        _cdn = bool(flags & 8)
        _static = bool(flags & 16)
        _id = reader.read_int()
        _ip_address = reader.tgread_string()
        _port = reader.read_int()
        return DcOption(id=_id, ip_address=_ip_address, port=_port, ipv6=_ipv6, media_only=_media_only, tcpo_only=_tcpo_only, cdn=_cdn, static=_static)


class DestroyAuthKeyFail(TLObject):
    CONSTRUCTOR_ID = 0xea109b13
    SUBCLASS_OF_ID = 0x8291e68e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'DestroyAuthKeyFail'
        }

    def __bytes__(self):
        return b''.join((
            b'\x13\x9b\x10\xea',
        ))

    @staticmethod
    def from_reader(reader):
        return DestroyAuthKeyFail()


class DestroyAuthKeyNone(TLObject):
    CONSTRUCTOR_ID = 0xa9f2259
    SUBCLASS_OF_ID = 0x8291e68e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'DestroyAuthKeyNone'
        }

    def __bytes__(self):
        return b''.join((
            b'Y"\x9f\n',
        ))

    @staticmethod
    def from_reader(reader):
        return DestroyAuthKeyNone()


class DestroyAuthKeyOk(TLObject):
    CONSTRUCTOR_ID = 0xf660e1d4
    SUBCLASS_OF_ID = 0x8291e68e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'DestroyAuthKeyOk'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd4\xe1`\xf6',
        ))

    @staticmethod
    def from_reader(reader):
        return DestroyAuthKeyOk()


class DestroySessionNone(TLObject):
    CONSTRUCTOR_ID = 0x62d350c9
    SUBCLASS_OF_ID = 0xaf0ce7bd

    def __init__(self, session_id):
        """
        :param int session_id:

        Constructor for DestroySessionRes: Instance of either DestroySessionOk, DestroySessionNone.
        """
        super().__init__()

        self.session_id = session_id  # type: int

    def to_dict(self):
        return {
            '_': 'DestroySessionNone',
            'session_id': self.session_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9P\xd3b',
            struct.pack('<q', self.session_id),
        ))

    @staticmethod
    def from_reader(reader):
        _session_id = reader.read_long()
        return DestroySessionNone(session_id=_session_id)


class DestroySessionOk(TLObject):
    CONSTRUCTOR_ID = 0xe22045fc
    SUBCLASS_OF_ID = 0xaf0ce7bd

    def __init__(self, session_id):
        """
        :param int session_id:

        Constructor for DestroySessionRes: Instance of either DestroySessionOk, DestroySessionNone.
        """
        super().__init__()

        self.session_id = session_id  # type: int

    def to_dict(self):
        return {
            '_': 'DestroySessionOk',
            'session_id': self.session_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xfcE \xe2',
            struct.pack('<q', self.session_id),
        ))

    @staticmethod
    def from_reader(reader):
        _session_id = reader.read_long()
        return DestroySessionOk(session_id=_session_id)


class DhGenFail(TLObject):
    CONSTRUCTOR_ID = 0xa69dae02
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash3):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash3:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce_hash3 = new_nonce_hash3  # type: int

    def to_dict(self):
        return {
            '_': 'DhGenFail',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash3': self.new_nonce_hash3
        }

    def __bytes__(self):
        return b''.join((
            b'\x02\xae\x9d\xa6',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash3.to_bytes(16, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash3 = reader.read_large_int(bits=128)
        return DhGenFail(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash3=_new_nonce_hash3)


class DhGenOk(TLObject):
    CONSTRUCTOR_ID = 0x3bcbf734
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash1):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash1:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce_hash1 = new_nonce_hash1  # type: int

    def to_dict(self):
        return {
            '_': 'DhGenOk',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash1': self.new_nonce_hash1
        }

    def __bytes__(self):
        return b''.join((
            b'4\xf7\xcb;',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash1.to_bytes(16, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash1 = reader.read_large_int(bits=128)
        return DhGenOk(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash1=_new_nonce_hash1)


class DhGenRetry(TLObject):
    CONSTRUCTOR_ID = 0x46dc1fb9
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash2):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash2:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        super().__init__()

        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce_hash2 = new_nonce_hash2  # type: int

    def to_dict(self):
        return {
            '_': 'DhGenRetry',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash2': self.new_nonce_hash2
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\x1f\xdcF',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash2.to_bytes(16, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash2 = reader.read_large_int(bits=128)
        return DhGenRetry(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash2=_new_nonce_hash2)


class Dialog(TLObject):
    CONSTRUCTOR_ID = 0xe4def5db
    SUBCLASS_OF_ID = 0x42cddd54

    def __init__(self, peer, top_message, read_inbox_max_id, read_outbox_max_id, unread_count, unread_mentions_count, notify_settings, pinned=None, pts=None, draft=None):
        """
        :param bool | None pinned:
        :param Peer peer:
        :param int top_message:
        :param int read_inbox_max_id:
        :param int read_outbox_max_id:
        :param int unread_count:
        :param int unread_mentions_count:
        :param PeerNotifySettings notify_settings:
        :param int | None pts:
        :param DraftMessage | None draft:

        Constructor for Dialog: Instance of Dialog.
        """
        super().__init__()

        self.pinned = pinned  # type: Optional[bool]
        self.peer = peer  # type: TypePeer
        self.top_message = top_message  # type: int
        self.read_inbox_max_id = read_inbox_max_id  # type: int
        self.read_outbox_max_id = read_outbox_max_id  # type: int
        self.unread_count = unread_count  # type: int
        self.unread_mentions_count = unread_mentions_count  # type: int
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings
        self.pts = pts  # type: Optional[int]
        self.draft = draft  # type: Optional[TypeDraftMessage]

    def to_dict(self):
        return {
            '_': 'Dialog',
            'pinned': self.pinned,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'top_message': self.top_message,
            'read_inbox_max_id': self.read_inbox_max_id,
            'read_outbox_max_id': self.read_outbox_max_id,
            'unread_count': self.unread_count,
            'unread_mentions_count': self.unread_mentions_count,
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'pts': self.pts,
            'draft': None if self.draft is None else self.draft.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\xf5\xde\xe4',
            struct.pack('<I', (0 if self.pinned is None or self.pinned is False else 4) | (0 if self.pts is None or self.pts is False else 1) | (0 if self.draft is None or self.draft is False else 2)),
            bytes(self.peer),
            struct.pack('<i', self.top_message),
            struct.pack('<i', self.read_inbox_max_id),
            struct.pack('<i', self.read_outbox_max_id),
            struct.pack('<i', self.unread_count),
            struct.pack('<i', self.unread_mentions_count),
            bytes(self.notify_settings),
            b'' if self.pts is None or self.pts is False else (struct.pack('<i', self.pts)),
            b'' if self.draft is None or self.draft is False else (bytes(self.draft)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _pinned = bool(flags & 4)
        _peer = reader.tgread_object()
        _top_message = reader.read_int()
        _read_inbox_max_id = reader.read_int()
        _read_outbox_max_id = reader.read_int()
        _unread_count = reader.read_int()
        _unread_mentions_count = reader.read_int()
        _notify_settings = reader.tgread_object()
        if flags & 1:
            _pts = reader.read_int()
        else:
            _pts = None
        if flags & 2:
            _draft = reader.tgread_object()
        else:
            _draft = None
        return Dialog(peer=_peer, top_message=_top_message, read_inbox_max_id=_read_inbox_max_id, read_outbox_max_id=_read_outbox_max_id, unread_count=_unread_count, unread_mentions_count=_unread_mentions_count, notify_settings=_notify_settings, pinned=_pinned, pts=_pts, draft=_draft)


class DisabledFeature(TLObject):
    CONSTRUCTOR_ID = 0xae636f24
    SUBCLASS_OF_ID = 0xcd266f94

    def __init__(self, feature, description):
        """
        :param str feature:
        :param str description:

        Constructor for DisabledFeature: Instance of DisabledFeature.
        """
        super().__init__()

        self.feature = feature  # type: str
        self.description = description  # type: str

    def to_dict(self):
        return {
            '_': 'DisabledFeature',
            'feature': self.feature,
            'description': self.description
        }

    def __bytes__(self):
        return b''.join((
            b'$oc\xae',
            TLObject.serialize_bytes(self.feature),
            TLObject.serialize_bytes(self.description),
        ))

    @staticmethod
    def from_reader(reader):
        _feature = reader.tgread_string()
        _description = reader.tgread_string()
        return DisabledFeature(feature=_feature, description=_description)


class Document(TLObject):
    CONSTRUCTOR_ID = 0x87232bc7
    SUBCLASS_OF_ID = 0x211fe820

    def __init__(self, id, access_hash, date, mime_type, size, thumb, dc_id, version, attributes):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param str mime_type:
        :param int size:
        :param PhotoSize thumb:
        :param int dc_id:
        :param int version:
        :param list[DocumentAttribute] attributes:

        Constructor for Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.mime_type = mime_type  # type: str
        self.size = size  # type: int
        self.thumb = thumb  # type: TypePhotoSize
        self.dc_id = dc_id  # type: int
        self.version = version  # type: int
        self.attributes = attributes  # type: List[TypeDocumentAttribute]

    def to_dict(self):
        return {
            '_': 'Document',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'mime_type': self.mime_type,
            'size': self.size,
            'thumb': None if self.thumb is None else self.thumb.to_dict(),
            'dc_id': self.dc_id,
            'version': self.version,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7+#\x87',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            TLObject.serialize_bytes(self.mime_type),
            struct.pack('<i', self.size),
            bytes(self.thumb),
            struct.pack('<i', self.dc_id),
            struct.pack('<i', self.version),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _mime_type = reader.tgread_string()
        _size = reader.read_int()
        _thumb = reader.tgread_object()
        _dc_id = reader.read_int()
        _version = reader.read_int()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        return Document(id=_id, access_hash=_access_hash, date=_date, mime_type=_mime_type, size=_size, thumb=_thumb, dc_id=_dc_id, version=_version, attributes=_attributes)


class DocumentAttributeAnimated(TLObject):
    CONSTRUCTOR_ID = 0x11b58939
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'DocumentAttributeAnimated'
        }

    def __bytes__(self):
        return b''.join((
            b'9\x89\xb5\x11',
        ))

    @staticmethod
    def from_reader(reader):
        return DocumentAttributeAnimated()


class DocumentAttributeAudio(TLObject):
    CONSTRUCTOR_ID = 0x9852f9c6
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, duration, voice=None, title=None, performer=None, waveform=None):
        """
        :param bool | None voice:
        :param int duration:
        :param str | None title:
        :param str | None performer:
        :param bytes | None waveform:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.voice = voice  # type: Optional[bool]
        self.duration = duration  # type: int
        self.title = title  # type: Optional[str]
        self.performer = performer  # type: Optional[str]
        self.waveform = waveform  # type: Optional[bytes]

    def to_dict(self):
        return {
            '_': 'DocumentAttributeAudio',
            'voice': self.voice,
            'duration': self.duration,
            'title': self.title,
            'performer': self.performer,
            'waveform': self.waveform
        }

    def __bytes__(self):
        return b''.join((
            b'\xc6\xf9R\x98',
            struct.pack('<I', (0 if self.voice is None or self.voice is False else 1024) | (0 if self.title is None or self.title is False else 1) | (0 if self.performer is None or self.performer is False else 2) | (0 if self.waveform is None or self.waveform is False else 4)),
            struct.pack('<i', self.duration),
            b'' if self.title is None or self.title is False else (TLObject.serialize_bytes(self.title)),
            b'' if self.performer is None or self.performer is False else (TLObject.serialize_bytes(self.performer)),
            b'' if self.waveform is None or self.waveform is False else (TLObject.serialize_bytes(self.waveform)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _voice = bool(flags & 1024)
        _duration = reader.read_int()
        if flags & 1:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 2:
            _performer = reader.tgread_string()
        else:
            _performer = None
        if flags & 4:
            _waveform = reader.tgread_bytes()
        else:
            _waveform = None
        return DocumentAttributeAudio(duration=_duration, voice=_voice, title=_title, performer=_performer, waveform=_waveform)


class DocumentAttributeFilename(TLObject):
    CONSTRUCTOR_ID = 0x15590068
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, file_name):
        """
        :param str file_name:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.file_name = file_name  # type: str

    def to_dict(self):
        return {
            '_': 'DocumentAttributeFilename',
            'file_name': self.file_name
        }

    def __bytes__(self):
        return b''.join((
            b'h\x00Y\x15',
            TLObject.serialize_bytes(self.file_name),
        ))

    @staticmethod
    def from_reader(reader):
        _file_name = reader.tgread_string()
        return DocumentAttributeFilename(file_name=_file_name)


class DocumentAttributeHasStickers(TLObject):
    CONSTRUCTOR_ID = 0x9801d2f7
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'DocumentAttributeHasStickers'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf7\xd2\x01\x98',
        ))

    @staticmethod
    def from_reader(reader):
        return DocumentAttributeHasStickers()


class DocumentAttributeImageSize(TLObject):
    CONSTRUCTOR_ID = 0x6c37c15c
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, w, h):
        """
        :param int w:
        :param int h:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.w = w  # type: int
        self.h = h  # type: int

    def to_dict(self):
        return {
            '_': 'DocumentAttributeImageSize',
            'w': self.w,
            'h': self.h
        }

    def __bytes__(self):
        return b''.join((
            b'\\\xc17l',
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @staticmethod
    def from_reader(reader):
        _w = reader.read_int()
        _h = reader.read_int()
        return DocumentAttributeImageSize(w=_w, h=_h)


class DocumentAttributeSticker(TLObject):
    CONSTRUCTOR_ID = 0x6319d612
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, alt, stickerset, mask=None, mask_coords=None):
        """
        :param bool | None mask:
        :param str alt:
        :param InputStickerSet stickerset:
        :param MaskCoords | None mask_coords:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.mask = mask  # type: Optional[bool]
        self.alt = alt  # type: str
        self.stickerset = stickerset  # type: TypeInputStickerSet
        self.mask_coords = mask_coords  # type: Optional[TypeMaskCoords]

    def to_dict(self):
        return {
            '_': 'DocumentAttributeSticker',
            'mask': self.mask,
            'alt': self.alt,
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
            'mask_coords': None if self.mask_coords is None else self.mask_coords.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x12\xd6\x19c',
            struct.pack('<I', (0 if self.mask is None or self.mask is False else 2) | (0 if self.mask_coords is None or self.mask_coords is False else 1)),
            TLObject.serialize_bytes(self.alt),
            bytes(self.stickerset),
            b'' if self.mask_coords is None or self.mask_coords is False else (bytes(self.mask_coords)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _mask = bool(flags & 2)
        _alt = reader.tgread_string()
        _stickerset = reader.tgread_object()
        if flags & 1:
            _mask_coords = reader.tgread_object()
        else:
            _mask_coords = None
        return DocumentAttributeSticker(alt=_alt, stickerset=_stickerset, mask=_mask, mask_coords=_mask_coords)


class DocumentAttributeVideo(TLObject):
    CONSTRUCTOR_ID = 0xef02ce6
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, duration, w, h, round_message=None):
        """
        :param bool | None round_message:
        :param int duration:
        :param int w:
        :param int h:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        super().__init__()

        self.round_message = round_message  # type: Optional[bool]
        self.duration = duration  # type: int
        self.w = w  # type: int
        self.h = h  # type: int

    def to_dict(self):
        return {
            '_': 'DocumentAttributeVideo',
            'round_message': self.round_message,
            'duration': self.duration,
            'w': self.w,
            'h': self.h
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6,\xf0\x0e',
            struct.pack('<I', (0 if self.round_message is None or self.round_message is False else 1)),
            struct.pack('<i', self.duration),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _round_message = bool(flags & 1)
        _duration = reader.read_int()
        _w = reader.read_int()
        _h = reader.read_int()
        return DocumentAttributeVideo(duration=_duration, w=_w, h=_h, round_message=_round_message)


class DocumentEmpty(TLObject):
    CONSTRUCTOR_ID = 0x36f8c871
    SUBCLASS_OF_ID = 0x211fe820

    def __init__(self, id):
        """
        :param int id:

        Constructor for Document: Instance of either DocumentEmpty, Document.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'DocumentEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'q\xc8\xf86',
            struct.pack('<q', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        return DocumentEmpty(id=_id)


class DraftMessage(TLObject):
    CONSTRUCTOR_ID = 0xfd8e711f
    SUBCLASS_OF_ID = 0x33d47f45

    def __init__(self, message, date, no_webpage=None, reply_to_msg_id=None, entities=None):
        """
        :param bool | None no_webpage:
        :param int | None reply_to_msg_id:
        :param str message:
        :param list[MessageEntity] | None entities:
        :param datetime.datetime | None date:

        Constructor for DraftMessage: Instance of either DraftMessageEmpty, DraftMessage.
        """
        super().__init__()

        self.no_webpage = no_webpage  # type: Optional[bool]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'DraftMessage',
            'no_webpage': self.no_webpage,
            'reply_to_msg_id': self.reply_to_msg_id,
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\x1fq\x8e\xfd',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 2) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 1) | (0 if self.entities is None or self.entities is False else 8)),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            TLObject.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _message = reader.tgread_string()
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        _date = reader.tgread_date()
        return DraftMessage(message=_message, date=_date, no_webpage=_no_webpage, reply_to_msg_id=_reply_to_msg_id, entities=_entities)


class DraftMessageEmpty(TLObject):
    CONSTRUCTOR_ID = 0xba4baec5
    SUBCLASS_OF_ID = 0x33d47f45

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'DraftMessageEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5\xaeK\xba',
        ))

    @staticmethod
    def from_reader(reader):
        return DraftMessageEmpty()


class EncryptedChat(TLObject):
    CONSTRUCTOR_ID = 0xfa56ce36
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_or_b, key_fingerprint):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_or_b:
        :param int key_fingerprint:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_a_or_b = g_a_or_b  # type: bytes
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedChat',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_or_b': self.g_a_or_b,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'6\xceV\xfa',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_a_or_b),
            struct.pack('<q', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_or_b = reader.tgread_bytes()
        _key_fingerprint = reader.read_long()
        return EncryptedChat(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_or_b=_g_a_or_b, key_fingerprint=_key_fingerprint)


class EncryptedChatDiscarded(TLObject):
    CONSTRUCTOR_ID = 0x13d6dd27
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id):
        """
        :param int id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedChatDiscarded',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b"'\xdd\xd6\x13",
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return EncryptedChatDiscarded(id=_id)


class EncryptedChatEmpty(TLObject):
    CONSTRUCTOR_ID = 0xab7ec0a0
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id):
        """
        :param int id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedChatEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc0~\xab',
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return EncryptedChatEmpty(id=_id)


class EncryptedChatRequested(TLObject):
    CONSTRUCTOR_ID = 0xc878527e
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_a = g_a  # type: bytes

    def to_dict(self):
        return {
            '_': 'EncryptedChatRequested',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a': self.g_a
        }

    def __bytes__(self):
        return b''.join((
            b'~Rx\xc8',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_a),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a = reader.tgread_bytes()
        return EncryptedChatRequested(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a=_g_a)


class EncryptedChatWaiting(TLObject):
    CONSTRUCTOR_ID = 0x3bf703dc
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedChatWaiting',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xdc\x03\xf7;',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        return EncryptedChatWaiting(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id)


class EncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x4a70994c
    SUBCLASS_OF_ID = 0x842a67c0

    def __init__(self, id, access_hash, size, dc_id, key_fingerprint):
        """
        :param int id:
        :param int access_hash:
        :param int size:
        :param int dc_id:
        :param int key_fingerprint:

        Constructor for EncryptedFile: Instance of either EncryptedFileEmpty, EncryptedFile.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.size = size  # type: int
        self.dc_id = dc_id  # type: int
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedFile',
            'id': self.id,
            'access_hash': self.access_hash,
            'size': self.size,
            'dc_id': self.dc_id,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'L\x99pJ',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.size),
            struct.pack('<i', self.dc_id),
            struct.pack('<i', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _size = reader.read_int()
        _dc_id = reader.read_int()
        _key_fingerprint = reader.read_int()
        return EncryptedFile(id=_id, access_hash=_access_hash, size=_size, dc_id=_dc_id, key_fingerprint=_key_fingerprint)


class EncryptedFileEmpty(TLObject):
    CONSTRUCTOR_ID = 0xc21f497e
    SUBCLASS_OF_ID = 0x842a67c0

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'EncryptedFileEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'~I\x1f\xc2',
        ))

    @staticmethod
    def from_reader(reader):
        return EncryptedFileEmpty()


class EncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0xed18c118
    SUBCLASS_OF_ID = 0x239f2e51

    def __init__(self, chat_id, date, bytes, file, random_id=None):
        """
        :param int random_id:
        :param int chat_id:
        :param datetime.datetime | None date:
        :param bytes bytes:
        :param EncryptedFile file:

        Constructor for EncryptedMessage: Instance of either EncryptedMessage, EncryptedMessageService.
        """
        super().__init__()

        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.chat_id = chat_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.bytes = bytes  # type: bytes
        self.file = file  # type: TypeEncryptedFile

    def to_dict(self):
        return {
            '_': 'EncryptedMessage',
            'random_id': self.random_id,
            'chat_id': self.chat_id,
            'date': self.date,
            'bytes': self.bytes,
            'file': None if self.file is None else self.file.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x18\xc1\x18\xed',
            struct.pack('<q', self.random_id),
            struct.pack('<i', self.chat_id),
            TLObject.serialize_datetime(self.date),
            TLObject.serialize_bytes(self.bytes),
            bytes(self.file),
        ))

    @staticmethod
    def from_reader(reader):
        _random_id = reader.read_long()
        _chat_id = reader.read_int()
        _date = reader.tgread_date()
        _bytes = reader.tgread_bytes()
        _file = reader.tgread_object()
        return EncryptedMessage(chat_id=_chat_id, date=_date, bytes=_bytes, file=_file, random_id=_random_id)


class EncryptedMessageService(TLObject):
    CONSTRUCTOR_ID = 0x23734b06
    SUBCLASS_OF_ID = 0x239f2e51

    def __init__(self, chat_id, date, bytes, random_id=None):
        """
        :param int random_id:
        :param int chat_id:
        :param datetime.datetime | None date:
        :param bytes bytes:

        Constructor for EncryptedMessage: Instance of either EncryptedMessage, EncryptedMessageService.
        """
        super().__init__()

        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.chat_id = chat_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.bytes = bytes  # type: bytes

    def to_dict(self):
        return {
            '_': 'EncryptedMessageService',
            'random_id': self.random_id,
            'chat_id': self.chat_id,
            'date': self.date,
            'bytes': self.bytes
        }

    def __bytes__(self):
        return b''.join((
            b'\x06Ks#',
            struct.pack('<q', self.random_id),
            struct.pack('<i', self.chat_id),
            TLObject.serialize_datetime(self.date),
            TLObject.serialize_bytes(self.bytes),
        ))

    @staticmethod
    def from_reader(reader):
        _random_id = reader.read_long()
        _chat_id = reader.read_int()
        _date = reader.tgread_date()
        _bytes = reader.tgread_bytes()
        return EncryptedMessageService(chat_id=_chat_id, date=_date, bytes=_bytes, random_id=_random_id)


class Error(TLObject):
    CONSTRUCTOR_ID = 0xc4b9f9bb
    SUBCLASS_OF_ID = 0x9c1c9375

    def __init__(self, code, text):
        """
        :param int code:
        :param str text:

        Constructor for Error: Instance of Error.
        """
        super().__init__()

        self.code = code  # type: int
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'Error',
            'code': self.code,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\xf9\xb9\xc4',
            struct.pack('<i', self.code),
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _code = reader.read_int()
        _text = reader.tgread_string()
        return Error(code=_code, text=_text)


class ExportedMessageLink(TLObject):
    CONSTRUCTOR_ID = 0x5dab1af4
    SUBCLASS_OF_ID = 0xdee644cc

    def __init__(self, link, html):
        """
        :param str link:
        :param str html:

        Constructor for ExportedMessageLink: Instance of ExportedMessageLink.
        """
        super().__init__()

        self.link = link  # type: str
        self.html = html  # type: str

    def to_dict(self):
        return {
            '_': 'ExportedMessageLink',
            'link': self.link,
            'html': self.html
        }

    def __bytes__(self):
        return b''.join((
            b'\xf4\x1a\xab]',
            TLObject.serialize_bytes(self.link),
            TLObject.serialize_bytes(self.html),
        ))

    @staticmethod
    def from_reader(reader):
        _link = reader.tgread_string()
        _html = reader.tgread_string()
        return ExportedMessageLink(link=_link, html=_html)


class FileLocation(TLObject):
    CONSTRUCTOR_ID = 0x53d69076
    SUBCLASS_OF_ID = 0x90f76823

    def __init__(self, dc_id, volume_id, local_id, secret):
        """
        :param int dc_id:
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for FileLocation: Instance of either FileLocationUnavailable, FileLocation.
        """
        super().__init__()

        self.dc_id = dc_id  # type: int
        self.volume_id = volume_id  # type: int
        self.local_id = local_id  # type: int
        self.secret = secret  # type: int

    def to_dict(self):
        return {
            '_': 'FileLocation',
            'dc_id': self.dc_id,
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'v\x90\xd6S',
            struct.pack('<i', self.dc_id),
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @staticmethod
    def from_reader(reader):
        _dc_id = reader.read_int()
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return FileLocation(dc_id=_dc_id, volume_id=_volume_id, local_id=_local_id, secret=_secret)


class FileLocationUnavailable(TLObject):
    CONSTRUCTOR_ID = 0x7c596b46
    SUBCLASS_OF_ID = 0x90f76823

    def __init__(self, volume_id, local_id, secret):
        """
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for FileLocation: Instance of either FileLocationUnavailable, FileLocation.
        """
        super().__init__()

        self.volume_id = volume_id  # type: int
        self.local_id = local_id  # type: int
        self.secret = secret  # type: int

    def to_dict(self):
        return {
            '_': 'FileLocationUnavailable',
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'FkY|',
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @staticmethod
    def from_reader(reader):
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return FileLocationUnavailable(volume_id=_volume_id, local_id=_local_id, secret=_secret)


class FoundGif(TLObject):
    CONSTRUCTOR_ID = 0x162ecc1f
    SUBCLASS_OF_ID = 0x5bbc92c3

    def __init__(self, url, thumb_url, content_url, content_type, w, h):
        """
        :param str url:
        :param str thumb_url:
        :param str content_url:
        :param str content_type:
        :param int w:
        :param int h:

        Constructor for FoundGif: Instance of either FoundGif, FoundGifCached.
        """
        super().__init__()

        self.url = url  # type: str
        self.thumb_url = thumb_url  # type: str
        self.content_url = content_url  # type: str
        self.content_type = content_type  # type: str
        self.w = w  # type: int
        self.h = h  # type: int

    def to_dict(self):
        return {
            '_': 'FoundGif',
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\xcc.\x16',
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.thumb_url),
            TLObject.serialize_bytes(self.content_url),
            TLObject.serialize_bytes(self.content_type),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _thumb_url = reader.tgread_string()
        _content_url = reader.tgread_string()
        _content_type = reader.tgread_string()
        _w = reader.read_int()
        _h = reader.read_int()
        return FoundGif(url=_url, thumb_url=_thumb_url, content_url=_content_url, content_type=_content_type, w=_w, h=_h)


class FoundGifCached(TLObject):
    CONSTRUCTOR_ID = 0x9c750409
    SUBCLASS_OF_ID = 0x5bbc92c3

    def __init__(self, url, photo, document):
        """
        :param str url:
        :param Photo photo:
        :param Document document:

        Constructor for FoundGif: Instance of either FoundGif, FoundGifCached.
        """
        super().__init__()

        self.url = url  # type: str
        self.photo = photo  # type: TypePhoto
        self.document = document  # type: TypeDocument

    def to_dict(self):
        return {
            '_': 'FoundGifCached',
            'url': self.url,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\t\x04u\x9c',
            TLObject.serialize_bytes(self.url),
            bytes(self.photo),
            bytes(self.document),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _photo = reader.tgread_object()
        _document = reader.tgread_object()
        return FoundGifCached(url=_url, photo=_photo, document=_document)


class FutureSalt(TLObject):
    CONSTRUCTOR_ID = 0x949d9dc
    SUBCLASS_OF_ID = 0x45e53dcf

    def __init__(self, valid_since, valid_until, salt):
        """
        :param int valid_since:
        :param int valid_until:
        :param int salt:

        Constructor for FutureSalt: Instance of FutureSalt.
        """
        super().__init__()

        self.valid_since = valid_since  # type: int
        self.valid_until = valid_until  # type: int
        self.salt = salt  # type: int

    def to_dict(self):
        return {
            '_': 'FutureSalt',
            'valid_since': self.valid_since,
            'valid_until': self.valid_until,
            'salt': self.salt
        }

    def __bytes__(self):
        return b''.join((
            b'\xdc\xd9I\t',
            struct.pack('<i', self.valid_since),
            struct.pack('<i', self.valid_until),
            struct.pack('<q', self.salt),
        ))

    @staticmethod
    def from_reader(reader):
        _valid_since = reader.read_int()
        _valid_until = reader.read_int()
        _salt = reader.read_long()
        return FutureSalt(valid_since=_valid_since, valid_until=_valid_until, salt=_salt)


class FutureSalts(TLObject):
    CONSTRUCTOR_ID = 0xae500895
    SUBCLASS_OF_ID = 0x1090f517

    def __init__(self, req_msg_id, now, salts):
        """
        :param int req_msg_id:
        :param int now:
        :param list[future_salt] salts:

        Constructor for FutureSalts: Instance of FutureSalts.
        """
        super().__init__()

        self.req_msg_id = req_msg_id  # type: int
        self.now = now  # type: int
        self.salts = salts  # type: List[Typefuture_salt]

    def to_dict(self):
        return {
            '_': 'FutureSalts',
            'req_msg_id': self.req_msg_id,
            'now': self.now,
            'salts': [] if self.salts is None else [None if x is None else x.to_dict() for x in self.salts]
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\x08P\xae',
            struct.pack('<q', self.req_msg_id),
            struct.pack('<i', self.now),
            struct.pack('<i', len(self.salts)),b''.join(bytes(x) for x in self.salts),
        ))

    @staticmethod
    def from_reader(reader):
        _req_msg_id = reader.read_long()
        _now = reader.read_int()
        _salts = []
        for _ in range(reader.read_int()):
            from . import FutureSalt
            _x = FutureSalt.from_reader(reader)
            _salts.append(_x)

        return FutureSalts(req_msg_id=_req_msg_id, now=_now, salts=_salts)


class Game(TLObject):
    CONSTRUCTOR_ID = 0xbdf9653b
    SUBCLASS_OF_ID = 0x83199eb2

    def __init__(self, id, access_hash, short_name, title, description, photo, document=None):
        """
        :param int id:
        :param int access_hash:
        :param str short_name:
        :param str title:
        :param str description:
        :param Photo photo:
        :param Document | None document:

        Constructor for Game: Instance of Game.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.short_name = short_name  # type: str
        self.title = title  # type: str
        self.description = description  # type: str
        self.photo = photo  # type: TypePhoto
        self.document = document  # type: Optional[TypeDocument]

    def to_dict(self):
        return {
            '_': 'Game',
            'id': self.id,
            'access_hash': self.access_hash,
            'short_name': self.short_name,
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b';e\xf9\xbd',
            struct.pack('<I', (0 if self.document is None or self.document is False else 1)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_bytes(self.short_name),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.description),
            bytes(self.photo),
            b'' if self.document is None or self.document is False else (bytes(self.document)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _access_hash = reader.read_long()
        _short_name = reader.tgread_string()
        _title = reader.tgread_string()
        _description = reader.tgread_string()
        _photo = reader.tgread_object()
        if flags & 1:
            _document = reader.tgread_object()
        else:
            _document = None
        return Game(id=_id, access_hash=_access_hash, short_name=_short_name, title=_title, description=_description, photo=_photo, document=_document)


class GeoPoint(TLObject):
    CONSTRUCTOR_ID = 0x2049d70c
    SUBCLASS_OF_ID = 0xd610e16d

    def __init__(self, long, lat):
        """
        :param double long:
        :param double lat:

        Constructor for GeoPoint: Instance of either GeoPointEmpty, GeoPoint.
        """
        super().__init__()

        self.long = long  # type: Typedouble
        self.lat = lat  # type: Typedouble

    def to_dict(self):
        return {
            '_': 'GeoPoint',
            'long': self.long,
            'lat': self.lat
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c\xd7I ',
            struct.pack('<d', self.long),
            struct.pack('<d', self.lat),
        ))

    @staticmethod
    def from_reader(reader):
        _long = reader.read_double()
        _lat = reader.read_double()
        return GeoPoint(long=_long, lat=_lat)


class GeoPointEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1117dd5f
    SUBCLASS_OF_ID = 0xd610e16d

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'GeoPointEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'_\xdd\x17\x11',
        ))

    @staticmethod
    def from_reader(reader):
        return GeoPointEmpty()


class HighScore(TLObject):
    CONSTRUCTOR_ID = 0x58fffcd0
    SUBCLASS_OF_ID = 0xd32b1e35

    def __init__(self, pos, user_id, score):
        """
        :param int pos:
        :param int user_id:
        :param int score:

        Constructor for HighScore: Instance of HighScore.
        """
        super().__init__()

        self.pos = pos  # type: int
        self.user_id = user_id  # type: int
        self.score = score  # type: int

    def to_dict(self):
        return {
            '_': 'HighScore',
            'pos': self.pos,
            'user_id': self.user_id,
            'score': self.score
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\xfc\xffX',
            struct.pack('<i', self.pos),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.score),
        ))

    @staticmethod
    def from_reader(reader):
        _pos = reader.read_int()
        _user_id = reader.read_int()
        _score = reader.read_int()
        return HighScore(pos=_pos, user_id=_user_id, score=_score)


class HttpWait(TLObject):
    CONSTRUCTOR_ID = 0x9299359f
    SUBCLASS_OF_ID = 0x1284aed6

    def __init__(self, max_delay, wait_after, max_wait):
        """
        :param int max_delay:
        :param int wait_after:
        :param int max_wait:

        Constructor for HttpWait: Instance of HttpWait.
        """
        super().__init__()

        self.max_delay = max_delay  # type: int
        self.wait_after = wait_after  # type: int
        self.max_wait = max_wait  # type: int

    def to_dict(self):
        return {
            '_': 'HttpWait',
            'max_delay': self.max_delay,
            'wait_after': self.wait_after,
            'max_wait': self.max_wait
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f5\x99\x92',
            struct.pack('<i', self.max_delay),
            struct.pack('<i', self.wait_after),
            struct.pack('<i', self.max_wait),
        ))

    @staticmethod
    def from_reader(reader):
        _max_delay = reader.read_int()
        _wait_after = reader.read_int()
        _max_wait = reader.read_int()
        return HttpWait(max_delay=_max_delay, wait_after=_wait_after, max_wait=_max_wait)


class ImportedContact(TLObject):
    CONSTRUCTOR_ID = 0xd0028438
    SUBCLASS_OF_ID = 0xb545bbda

    def __init__(self, user_id, client_id):
        """
        :param int user_id:
        :param int client_id:

        Constructor for ImportedContact: Instance of ImportedContact.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.client_id = client_id  # type: int

    def to_dict(self):
        return {
            '_': 'ImportedContact',
            'user_id': self.user_id,
            'client_id': self.client_id
        }

    def __bytes__(self):
        return b''.join((
            b'8\x84\x02\xd0',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.client_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _client_id = reader.read_long()
        return ImportedContact(user_id=_user_id, client_id=_client_id)


class InlineBotSwitchPM(TLObject):
    CONSTRUCTOR_ID = 0x3c20629f
    SUBCLASS_OF_ID = 0x82b1f73b

    def __init__(self, text, start_param):
        """
        :param str text:
        :param str start_param:

        Constructor for InlineBotSwitchPM: Instance of InlineBotSwitchPM.
        """
        super().__init__()

        self.text = text  # type: str
        self.start_param = start_param  # type: str

    def to_dict(self):
        return {
            '_': 'InlineBotSwitchPM',
            'text': self.text,
            'start_param': self.start_param
        }

    def __bytes__(self):
        return b''.join((
            b'\x9fb <',
            TLObject.serialize_bytes(self.text),
            TLObject.serialize_bytes(self.start_param),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        _start_param = reader.tgread_string()
        return InlineBotSwitchPM(text=_text, start_param=_start_param)


class InputAppEvent(TLObject):
    CONSTRUCTOR_ID = 0x770656a8
    SUBCLASS_OF_ID = 0x89322106

    def __init__(self, time, type, peer, data):
        """
        :param double time:
        :param str type:
        :param int peer:
        :param str data:

        Constructor for InputAppEvent: Instance of InputAppEvent.
        """
        super().__init__()

        self.time = time  # type: Typedouble
        self.type = type  # type: str
        self.peer = peer  # type: int
        self.data = data  # type: str

    def to_dict(self):
        return {
            '_': 'InputAppEvent',
            'time': self.time,
            'type': self.type,
            'peer': self.peer,
            'data': self.data
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8V\x06w',
            struct.pack('<d', self.time),
            TLObject.serialize_bytes(self.type),
            struct.pack('<q', self.peer),
            TLObject.serialize_bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _time = reader.read_double()
        _type = reader.tgread_string()
        _peer = reader.read_long()
        _data = reader.tgread_string()
        return InputAppEvent(time=_time, type=_type, peer=_peer, data=_data)


class InputBotInlineMessageGame(TLObject):
    CONSTRUCTOR_ID = 0x4b425864
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, reply_markup=None):
        """
        :param ReplyMarkup | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageGame',
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'dXBK',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageGame(reply_markup=_reply_markup)


class InputBotInlineMessageID(TLObject):
    CONSTRUCTOR_ID = 0x890c3d89
    SUBCLASS_OF_ID = 0x2dcd6300

    def __init__(self, dc_id, id, access_hash):
        """
        :param int dc_id:
        :param int id:
        :param int access_hash:

        Constructor for InputBotInlineMessageID: Instance of InputBotInlineMessageID.
        """
        super().__init__()

        self.dc_id = dc_id  # type: int
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageID',
            'dc_id': self.dc_id,
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x89=\x0c\x89',
            struct.pack('<i', self.dc_id),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _dc_id = reader.read_int()
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputBotInlineMessageID(dc_id=_dc_id, id=_id, access_hash=_access_hash)


class InputBotInlineMessageMediaAuto(TLObject):
    CONSTRUCTOR_ID = 0x3380c786
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, message, entities=None, reply_markup=None):
        """
        :param str message:
        :param list[MessageEntity] | None entities:
        :param ReplyMarkup | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageMediaAuto',
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\xc7\x803',
            struct.pack('<I', (0 if self.entities is None or self.entities is False else 2) | (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            TLObject.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageMediaAuto(message=_message, entities=_entities, reply_markup=_reply_markup)


class InputBotInlineMessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0x2daf01a7
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, phone_number, first_name, last_name, reply_markup=None):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param ReplyMarkup | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.phone_number = phone_number  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageMediaContact',
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xa7\x01\xaf-',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            TLObject.serialize_bytes(self.phone_number),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageMediaContact(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, reply_markup=_reply_markup)


class InputBotInlineMessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0xc1b15d65
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, geo_point, period, reply_markup=None):
        """
        :param InputGeoPoint geo_point:
        :param int period:
        :param ReplyMarkup | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.period = period  # type: int
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageMediaGeo',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'period': self.period,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'e]\xb1\xc1',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            bytes(self.geo_point),
            struct.pack('<i', self.period),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _geo_point = reader.tgread_object()
        _period = reader.read_int()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageMediaGeo(geo_point=_geo_point, period=_period, reply_markup=_reply_markup)


class InputBotInlineMessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0xaaafadc8
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, geo_point, title, address, provider, venue_id, reply_markup=None):
        """
        :param InputGeoPoint geo_point:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param ReplyMarkup | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.title = title  # type: str
        self.address = address  # type: str
        self.provider = provider  # type: str
        self.venue_id = venue_id  # type: str
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageMediaVenue',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xad\xaf\xaa',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            bytes(self.geo_point),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.address),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.venue_id),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _geo_point = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageMediaVenue(geo_point=_geo_point, title=_title, address=_address, provider=_provider, venue_id=_venue_id, reply_markup=_reply_markup)


class InputBotInlineMessageText(TLObject):
    CONSTRUCTOR_ID = 0x3dcd7a87
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, message, no_webpage=None, entities=None, reply_markup=None):
        """
        :param bool | None no_webpage:
        :param str message:
        :param list[MessageEntity] | None entities:
        :param ReplyMarkup | None reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        super().__init__()

        self.no_webpage = no_webpage  # type: Optional[bool]
        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageText',
            'no_webpage': self.no_webpage,
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x87z\xcd=',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 1) | (0 if self.entities is None or self.entities is False else 2) | (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            TLObject.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 1)
        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return InputBotInlineMessageText(message=_message, no_webpage=_no_webpage, entities=_entities, reply_markup=_reply_markup)


class InputBotInlineResult(TLObject):
    CONSTRUCTOR_ID = 0x2cbbe15a
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, send_message, title=None, description=None, url=None, thumb_url=None, content_url=None, content_type=None, w=None, h=None, duration=None):
        """
        :param str id:
        :param str type:
        :param str | None title:
        :param str | None description:
        :param str | None url:
        :param str | None thumb_url:
        :param str | None content_url:
        :param str | None content_type:
        :param int | None w:
        :param int | None h:
        :param int | None duration:
        :param InputBotInlineMessage send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id  # type: str
        self.type = type  # type: str
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.url = url  # type: Optional[str]
        self.thumb_url = thumb_url  # type: Optional[str]
        self.content_url = content_url  # type: Optional[str]
        self.content_type = content_type  # type: Optional[str]
        self.w = w  # type: Optional[int]
        self.h = h  # type: Optional[int]
        self.duration = duration  # type: Optional[int]
        self.send_message = send_message  # type: TypeInputBotInlineMessage

    def to_dict(self):
        return {
            '_': 'InputBotInlineResult',
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h,
            'duration': self.duration,
            'send_message': None if self.send_message is None else self.send_message.to_dict()
        }

    def __bytes__(self):
        assert ((self.content_url or self.content_url is not None) and (self.content_type or self.content_type is not None)) or ((self.content_url is None or self.content_url is False) and (self.content_type is None or self.content_type is False)), 'content_url, content_type parameters must all be False-y (like None) or all me True-y'
        assert ((self.w or self.w is not None) and (self.h or self.h is not None)) or ((self.w is None or self.w is False) and (self.h is None or self.h is False)), 'w, h parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'Z\xe1\xbb,',
            struct.pack('<I', (0 if self.title is None or self.title is False else 2) | (0 if self.description is None or self.description is False else 4) | (0 if self.url is None or self.url is False else 8) | (0 if self.thumb_url is None or self.thumb_url is False else 16) | (0 if self.content_url is None or self.content_url is False else 32) | (0 if self.content_type is None or self.content_type is False else 32) | (0 if self.w is None or self.w is False else 64) | (0 if self.h is None or self.h is False else 64) | (0 if self.duration is None or self.duration is False else 128)),
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            b'' if self.title is None or self.title is False else (TLObject.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (TLObject.serialize_bytes(self.description)),
            b'' if self.url is None or self.url is False else (TLObject.serialize_bytes(self.url)),
            b'' if self.thumb_url is None or self.thumb_url is False else (TLObject.serialize_bytes(self.thumb_url)),
            b'' if self.content_url is None or self.content_url is False else (TLObject.serialize_bytes(self.content_url)),
            b'' if self.content_type is None or self.content_type is False else (TLObject.serialize_bytes(self.content_type)),
            b'' if self.w is None or self.w is False else (struct.pack('<i', self.w)),
            b'' if self.h is None or self.h is False else (struct.pack('<i', self.h)),
            b'' if self.duration is None or self.duration is False else (struct.pack('<i', self.duration)),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 8:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 16:
            _thumb_url = reader.tgread_string()
        else:
            _thumb_url = None
        if flags & 32:
            _content_url = reader.tgread_string()
        else:
            _content_url = None
        if flags & 32:
            _content_type = reader.tgread_string()
        else:
            _content_type = None
        if flags & 64:
            _w = reader.read_int()
        else:
            _w = None
        if flags & 64:
            _h = reader.read_int()
        else:
            _h = None
        if flags & 128:
            _duration = reader.read_int()
        else:
            _duration = None
        _send_message = reader.tgread_object()
        return InputBotInlineResult(id=_id, type=_type, send_message=_send_message, title=_title, description=_description, url=_url, thumb_url=_thumb_url, content_url=_content_url, content_type=_content_type, w=_w, h=_h, duration=_duration)


class InputBotInlineResultDocument(TLObject):
    CONSTRUCTOR_ID = 0xfff8fdc4
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, document, send_message, title=None, description=None):
        """
        :param str id:
        :param str type:
        :param str | None title:
        :param str | None description:
        :param InputDocument document:
        :param InputBotInlineMessage send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id  # type: str
        self.type = type  # type: str
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.document = document  # type: TypeInputDocument
        self.send_message = send_message  # type: TypeInputBotInlineMessage

    def to_dict(self):
        return {
            '_': 'InputBotInlineResultDocument',
            'id': self.id,
            'type': self.type,
            'title': self.title,
            'description': self.description,
            'document': None if self.document is None else self.document.to_dict(),
            'send_message': None if self.send_message is None else self.send_message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xfd\xf8\xff',
            struct.pack('<I', (0 if self.title is None or self.title is False else 2) | (0 if self.description is None or self.description is False else 4)),
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            b'' if self.title is None or self.title is False else (TLObject.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (TLObject.serialize_bytes(self.description)),
            bytes(self.document),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        _document = reader.tgread_object()
        _send_message = reader.tgread_object()
        return InputBotInlineResultDocument(id=_id, type=_type, document=_document, send_message=_send_message, title=_title, description=_description)


class InputBotInlineResultGame(TLObject):
    CONSTRUCTOR_ID = 0x4fa417f2
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, short_name, send_message):
        """
        :param str id:
        :param str short_name:
        :param InputBotInlineMessage send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id  # type: str
        self.short_name = short_name  # type: str
        self.send_message = send_message  # type: TypeInputBotInlineMessage

    def to_dict(self):
        return {
            '_': 'InputBotInlineResultGame',
            'id': self.id,
            'short_name': self.short_name,
            'send_message': None if self.send_message is None else self.send_message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xf2\x17\xa4O',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.short_name),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _short_name = reader.tgread_string()
        _send_message = reader.tgread_object()
        return InputBotInlineResultGame(id=_id, short_name=_short_name, send_message=_send_message)


class InputBotInlineResultPhoto(TLObject):
    CONSTRUCTOR_ID = 0xa8d864a7
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, photo, send_message):
        """
        :param str id:
        :param str type:
        :param InputPhoto photo:
        :param InputBotInlineMessage send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        super().__init__()

        self.id = id  # type: str
        self.type = type  # type: str
        self.photo = photo  # type: TypeInputPhoto
        self.send_message = send_message  # type: TypeInputBotInlineMessage

    def resolve(self, client, utils):
        self.photo = utils.get_input_photo(self.photo)

    def to_dict(self):
        return {
            '_': 'InputBotInlineResultPhoto',
            'id': self.id,
            'type': self.type,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'send_message': None if self.send_message is None else self.send_message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xa7d\xd8\xa8',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.type),
            bytes(self.photo),
            bytes(self.send_message),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _type = reader.tgread_string()
        _photo = reader.tgread_object()
        _send_message = reader.tgread_object()
        return InputBotInlineResultPhoto(id=_id, type=_type, photo=_photo, send_message=_send_message)


class InputChannel(TLObject):
    CONSTRUCTOR_ID = 0xafeb712e
    SUBCLASS_OF_ID = 0x40f202fd

    def __init__(self, channel_id, access_hash):
        """
        :param int channel_id:
        :param int access_hash:

        Constructor for InputChannel: Instance of either InputChannelEmpty, InputChannel.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputChannel',
            'channel_id': self.channel_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'.q\xeb\xaf',
            struct.pack('<i', self.channel_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputChannel(channel_id=_channel_id, access_hash=_access_hash)


class InputChannelEmpty(TLObject):
    CONSTRUCTOR_ID = 0xee8c1e86
    SUBCLASS_OF_ID = 0x40f202fd

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputChannelEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\x1e\x8c\xee',
        ))

    @staticmethod
    def from_reader(reader):
        return InputChannelEmpty()


class InputChatPhoto(TLObject):
    CONSTRUCTOR_ID = 0x8953ad37
    SUBCLASS_OF_ID = 0xd4eb2d74

    def __init__(self, id):
        """
        :param InputPhoto id:

        Constructor for InputChatPhoto: Instance of either InputChatPhotoEmpty, InputChatUploadedPhoto, InputChatPhoto.
        """
        super().__init__()

        self.id = id  # type: TypeInputPhoto

    def resolve(self, client, utils):
        self.id = utils.get_input_photo(self.id)

    def to_dict(self):
        return {
            '_': 'InputChatPhoto',
            'id': None if self.id is None else self.id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'7\xadS\x89',
            bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        return InputChatPhoto(id=_id)


class InputChatPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1ca48f57
    SUBCLASS_OF_ID = 0xd4eb2d74

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputChatPhotoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'W\x8f\xa4\x1c',
        ))

    @staticmethod
    def from_reader(reader):
        return InputChatPhotoEmpty()


class InputChatUploadedPhoto(TLObject):
    CONSTRUCTOR_ID = 0x927c55b4
    SUBCLASS_OF_ID = 0xd4eb2d74

    def __init__(self, file):
        """
        :param InputFile file:

        Constructor for InputChatPhoto: Instance of either InputChatPhotoEmpty, InputChatUploadedPhoto, InputChatPhoto.
        """
        super().__init__()

        self.file = file  # type: TypeInputFile

    def to_dict(self):
        return {
            '_': 'InputChatUploadedPhoto',
            'file': None if self.file is None else self.file.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xb4U|\x92',
            bytes(self.file),
        ))

    @staticmethod
    def from_reader(reader):
        _file = reader.tgread_object()
        return InputChatUploadedPhoto(file=_file)


class InputDocument(TLObject):
    CONSTRUCTOR_ID = 0x18798952
    SUBCLASS_OF_ID = 0xf33fdb68

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputDocument: Instance of either InputDocumentEmpty, InputDocument.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputDocument',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'R\x89y\x18',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputDocument(id=_id, access_hash=_access_hash)


class InputDocumentEmpty(TLObject):
    CONSTRUCTOR_ID = 0x72f0eaae
    SUBCLASS_OF_ID = 0xf33fdb68

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputDocumentEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xae\xea\xf0r',
        ))

    @staticmethod
    def from_reader(reader):
        return InputDocumentEmpty()


class InputDocumentFileLocation(TLObject):
    CONSTRUCTOR_ID = 0x430f0724
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, id, access_hash, version):
        """
        :param int id:
        :param int access_hash:
        :param int version:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'InputDocumentFileLocation',
            'id': self.id,
            'access_hash': self.access_hash,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'$\x07\x0fC',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _version = reader.read_int()
        return InputDocumentFileLocation(id=_id, access_hash=_access_hash, version=_version)


class InputEncryptedChat(TLObject):
    CONSTRUCTOR_ID = 0xf141b5e1
    SUBCLASS_OF_ID = 0x6c7606c0

    def __init__(self, chat_id, access_hash):
        """
        :param int chat_id:
        :param int access_hash:

        Constructor for InputEncryptedChat: Instance of InputEncryptedChat.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedChat',
            'chat_id': self.chat_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xb5A\xf1',
            struct.pack('<i', self.chat_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputEncryptedChat(chat_id=_chat_id, access_hash=_access_hash)


class InputEncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x5a17b5e5
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedFile',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\xb5\x17Z',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputEncryptedFile(id=_id, access_hash=_access_hash)


class InputEncryptedFileBigUploaded(TLObject):
    CONSTRUCTOR_ID = 0x2dc173c8
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, parts, key_fingerprint):
        """
        :param int id:
        :param int parts:
        :param int key_fingerprint:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id  # type: int
        self.parts = parts  # type: int
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedFileBigUploaded',
            'id': self.id,
            'parts': self.parts,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8s\xc1-',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            struct.pack('<i', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _key_fingerprint = reader.read_int()
        return InputEncryptedFileBigUploaded(id=_id, parts=_parts, key_fingerprint=_key_fingerprint)


class InputEncryptedFileEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1837c364
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputEncryptedFileEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'd\xc37\x18',
        ))

    @staticmethod
    def from_reader(reader):
        return InputEncryptedFileEmpty()


class InputEncryptedFileLocation(TLObject):
    CONSTRUCTOR_ID = 0xf5235d55
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedFileLocation',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'U]#\xf5',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputEncryptedFileLocation(id=_id, access_hash=_access_hash)


class InputEncryptedFileUploaded(TLObject):
    CONSTRUCTOR_ID = 0x64bd0306
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, parts, md5_checksum, key_fingerprint):
        """
        :param int id:
        :param int parts:
        :param str md5_checksum:
        :param int key_fingerprint:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        super().__init__()

        self.id = id  # type: int
        self.parts = parts  # type: int
        self.md5_checksum = md5_checksum  # type: str
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedFileUploaded',
            'id': self.id,
            'parts': self.parts,
            'md5_checksum': self.md5_checksum,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'\x06\x03\xbdd',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            TLObject.serialize_bytes(self.md5_checksum),
            struct.pack('<i', self.key_fingerprint),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _md5_checksum = reader.tgread_string()
        _key_fingerprint = reader.read_int()
        return InputEncryptedFileUploaded(id=_id, parts=_parts, md5_checksum=_md5_checksum, key_fingerprint=_key_fingerprint)


class InputFile(TLObject):
    CONSTRUCTOR_ID = 0xf52ff27f
    SUBCLASS_OF_ID = 0xe7655f1f

    def __init__(self, id, parts, name, md5_checksum):
        """
        :param int id:
        :param int parts:
        :param str name:
        :param str md5_checksum:

        Constructor for InputFile: Instance of either InputFile, InputFileBig.
        """
        super().__init__()

        self.id = id  # type: int
        self.parts = parts  # type: int
        self.name = name  # type: str
        self.md5_checksum = md5_checksum  # type: str

    def to_dict(self):
        return {
            '_': 'InputFile',
            'id': self.id,
            'parts': self.parts,
            'name': self.name,
            'md5_checksum': self.md5_checksum
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf2/\xf5',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            TLObject.serialize_bytes(self.name),
            TLObject.serialize_bytes(self.md5_checksum),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _name = reader.tgread_string()
        _md5_checksum = reader.tgread_string()
        return InputFile(id=_id, parts=_parts, name=_name, md5_checksum=_md5_checksum)


class InputFileBig(TLObject):
    CONSTRUCTOR_ID = 0xfa4f0bb5
    SUBCLASS_OF_ID = 0xe7655f1f

    def __init__(self, id, parts, name):
        """
        :param int id:
        :param int parts:
        :param str name:

        Constructor for InputFile: Instance of either InputFile, InputFileBig.
        """
        super().__init__()

        self.id = id  # type: int
        self.parts = parts  # type: int
        self.name = name  # type: str

    def to_dict(self):
        return {
            '_': 'InputFileBig',
            'id': self.id,
            'parts': self.parts,
            'name': self.name
        }

    def __bytes__(self):
        return b''.join((
            b'\xb5\x0bO\xfa',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            TLObject.serialize_bytes(self.name),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _name = reader.tgread_string()
        return InputFileBig(id=_id, parts=_parts, name=_name)


class InputFileLocation(TLObject):
    CONSTRUCTOR_ID = 0x14637196
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, volume_id, local_id, secret):
        """
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation.
        """
        super().__init__()

        self.volume_id = volume_id  # type: int
        self.local_id = local_id  # type: int
        self.secret = secret  # type: int

    def to_dict(self):
        return {
            '_': 'InputFileLocation',
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'\x96qc\x14',
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @staticmethod
    def from_reader(reader):
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return InputFileLocation(volume_id=_volume_id, local_id=_local_id, secret=_secret)


class InputGameID(TLObject):
    CONSTRUCTOR_ID = 0x32c3e77
    SUBCLASS_OF_ID = 0x48d15883

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputGame: Instance of either InputGameID, InputGameShortName.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputGameID',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'w>,\x03',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputGameID(id=_id, access_hash=_access_hash)


class InputGameShortName(TLObject):
    CONSTRUCTOR_ID = 0xc331e80a
    SUBCLASS_OF_ID = 0x48d15883

    def __init__(self, bot_id, short_name):
        """
        :param InputUser bot_id:
        :param str short_name:

        Constructor for InputGame: Instance of either InputGameID, InputGameShortName.
        """
        super().__init__()

        self.bot_id = bot_id  # type: TypeInputUser
        self.short_name = short_name  # type: str

    def resolve(self, client, utils):
        self.bot_id = utils.get_input_user(client.get_input_entity(self.bot_id))

    def to_dict(self):
        return {
            '_': 'InputGameShortName',
            'bot_id': None if self.bot_id is None else self.bot_id.to_dict(),
            'short_name': self.short_name
        }

    def __bytes__(self):
        return b''.join((
            b'\n\xe81\xc3',
            bytes(self.bot_id),
            TLObject.serialize_bytes(self.short_name),
        ))

    @staticmethod
    def from_reader(reader):
        _bot_id = reader.tgread_object()
        _short_name = reader.tgread_string()
        return InputGameShortName(bot_id=_bot_id, short_name=_short_name)


class InputGeoPoint(TLObject):
    CONSTRUCTOR_ID = 0xf3b7acc9
    SUBCLASS_OF_ID = 0x430d225

    def __init__(self, lat, long):
        """
        :param double lat:
        :param double long:

        Constructor for InputGeoPoint: Instance of either InputGeoPointEmpty, InputGeoPoint.
        """
        super().__init__()

        self.lat = lat  # type: Typedouble
        self.long = long  # type: Typedouble

    def to_dict(self):
        return {
            '_': 'InputGeoPoint',
            'lat': self.lat,
            'long': self.long
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\xac\xb7\xf3',
            struct.pack('<d', self.lat),
            struct.pack('<d', self.long),
        ))

    @staticmethod
    def from_reader(reader):
        _lat = reader.read_double()
        _long = reader.read_double()
        return InputGeoPoint(lat=_lat, long=_long)


class InputGeoPointEmpty(TLObject):
    CONSTRUCTOR_ID = 0xe4c123d6
    SUBCLASS_OF_ID = 0x430d225

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputGeoPointEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6#\xc1\xe4',
        ))

    @staticmethod
    def from_reader(reader):
        return InputGeoPointEmpty()


class InputMediaContact(TLObject):
    CONSTRUCTOR_ID = 0xa6e45987
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, phone_number, first_name, last_name):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.phone_number = phone_number  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str

    def to_dict(self):
        return {
            '_': 'InputMediaContact',
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name
        }

    def __bytes__(self):
        return b''.join((
            b'\x87Y\xe4\xa6',
            TLObject.serialize_bytes(self.phone_number),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
        ))

    @staticmethod
    def from_reader(reader):
        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        return InputMediaContact(phone_number=_phone_number, first_name=_first_name, last_name=_last_name)


class InputMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x23ab23d2
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id, ttl_seconds=None):
        """
        :param InputDocument id:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.id = id  # type: TypeInputDocument
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaDocument',
            'id': None if self.id is None else self.id.to_dict(),
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\xd2#\xab#',
            struct.pack('<I', (0 if self.ttl_seconds is None or self.ttl_seconds is False else 1)),
            bytes(self.id),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_object()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaDocument(id=_id, ttl_seconds=_ttl_seconds)


class InputMediaDocumentExternal(TLObject):
    CONSTRUCTOR_ID = 0xfb52dc99
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, ttl_seconds=None):
        """
        :param str url:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.url = url  # type: str
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaDocumentExternal',
            'url': self.url,
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\xdcR\xfb',
            struct.pack('<I', (0 if self.ttl_seconds is None or self.ttl_seconds is False else 1)),
            TLObject.serialize_bytes(self.url),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _url = reader.tgread_string()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaDocumentExternal(url=_url, ttl_seconds=_ttl_seconds)


class InputMediaEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9664f57f
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMediaEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf5d\x96',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMediaEmpty()


class InputMediaGame(TLObject):
    CONSTRUCTOR_ID = 0xd33f43f3
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id):
        """
        :param InputGame id:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.id = id  # type: TypeInputGame

    def to_dict(self):
        return {
            '_': 'InputMediaGame',
            'id': None if self.id is None else self.id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xf3C?\xd3',
            bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        return InputMediaGame(id=_id)


class InputMediaGeoLive(TLObject):
    CONSTRUCTOR_ID = 0x7b1a118f
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, geo_point, period):
        """
        :param InputGeoPoint geo_point:
        :param int period:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.period = period  # type: int

    def to_dict(self):
        return {
            '_': 'InputMediaGeoLive',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'period': self.period
        }

    def __bytes__(self):
        return b''.join((
            b'\x8f\x11\x1a{',
            bytes(self.geo_point),
            struct.pack('<i', self.period),
        ))

    @staticmethod
    def from_reader(reader):
        _geo_point = reader.tgread_object()
        _period = reader.read_int()
        return InputMediaGeoLive(geo_point=_geo_point, period=_period)


class InputMediaGeoPoint(TLObject):
    CONSTRUCTOR_ID = 0xf9c44144
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, geo_point):
        """
        :param InputGeoPoint geo_point:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.geo_point = geo_point  # type: TypeInputGeoPoint

    def to_dict(self):
        return {
            '_': 'InputMediaGeoPoint',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'DA\xc4\xf9',
            bytes(self.geo_point),
        ))

    @staticmethod
    def from_reader(reader):
        _geo_point = reader.tgread_object()
        return InputMediaGeoPoint(geo_point=_geo_point)


class InputMediaGifExternal(TLObject):
    CONSTRUCTOR_ID = 0x4843b0fd
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, q):
        """
        :param str url:
        :param str q:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.url = url  # type: str
        self.q = q  # type: str

    def to_dict(self):
        return {
            '_': 'InputMediaGifExternal',
            'url': self.url,
            'q': self.q
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\xb0CH',
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.q),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _q = reader.tgread_string()
        return InputMediaGifExternal(url=_url, q=_q)


class InputMediaInvoice(TLObject):
    CONSTRUCTOR_ID = 0xf4e096c3
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, title, description, invoice, payload, provider, provider_data, start_param, photo=None):
        """
        :param str title:
        :param str description:
        :param InputWebDocument | None photo:
        :param Invoice invoice:
        :param bytes payload:
        :param str provider:
        :param DataJSON provider_data:
        :param str start_param:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.title = title  # type: str
        self.description = description  # type: str
        self.photo = photo  # type: Optional[TypeInputWebDocument]
        self.invoice = invoice  # type: TypeInvoice
        self.payload = payload  # type: bytes
        self.provider = provider  # type: str
        self.provider_data = provider_data  # type: TypeDataJSON
        self.start_param = start_param  # type: str

    def to_dict(self):
        return {
            '_': 'InputMediaInvoice',
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'invoice': None if self.invoice is None else self.invoice.to_dict(),
            'payload': self.payload,
            'provider': self.provider,
            'provider_data': None if self.provider_data is None else self.provider_data.to_dict(),
            'start_param': self.start_param
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\x96\xe0\xf4',
            struct.pack('<I', (0 if self.photo is None or self.photo is False else 1)),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.description),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            bytes(self.invoice),
            TLObject.serialize_bytes(self.payload),
            TLObject.serialize_bytes(self.provider),
            bytes(self.provider_data),
            TLObject.serialize_bytes(self.start_param),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _title = reader.tgread_string()
        _description = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        _invoice = reader.tgread_object()
        _payload = reader.tgread_bytes()
        _provider = reader.tgread_string()
        _provider_data = reader.tgread_object()
        _start_param = reader.tgread_string()
        return InputMediaInvoice(title=_title, description=_description, invoice=_invoice, payload=_payload, provider=_provider, provider_data=_provider_data, start_param=_start_param, photo=_photo)


class InputMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0xb3ba0635
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id, ttl_seconds=None):
        """
        :param InputPhoto id:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.id = id  # type: TypeInputPhoto
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def resolve(self, client, utils):
        self.id = utils.get_input_photo(self.id)

    def to_dict(self):
        return {
            '_': 'InputMediaPhoto',
            'id': None if self.id is None else self.id.to_dict(),
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'5\x06\xba\xb3',
            struct.pack('<I', (0 if self.ttl_seconds is None or self.ttl_seconds is False else 1)),
            bytes(self.id),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.tgread_object()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaPhoto(id=_id, ttl_seconds=_ttl_seconds)


class InputMediaPhotoExternal(TLObject):
    CONSTRUCTOR_ID = 0xe5bbfe1a
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, ttl_seconds=None):
        """
        :param str url:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.url = url  # type: str
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaPhotoExternal',
            'url': self.url,
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\x1a\xfe\xbb\xe5',
            struct.pack('<I', (0 if self.ttl_seconds is None or self.ttl_seconds is False else 1)),
            TLObject.serialize_bytes(self.url),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _url = reader.tgread_string()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaPhotoExternal(url=_url, ttl_seconds=_ttl_seconds)


class InputMediaUploadedDocument(TLObject):
    CONSTRUCTOR_ID = 0x5b38c6c1
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, file, mime_type, attributes, nosound_video=None, thumb=None, stickers=None, ttl_seconds=None):
        """
        :param bool | None nosound_video:
        :param InputFile file:
        :param InputFile | None thumb:
        :param str mime_type:
        :param list[DocumentAttribute] attributes:
        :param list[InputDocument] | None stickers:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.nosound_video = nosound_video  # type: Optional[bool]
        self.file = file  # type: TypeInputFile
        self.thumb = thumb  # type: Optional[TypeInputFile]
        self.mime_type = mime_type  # type: str
        self.attributes = attributes  # type: List[TypeDocumentAttribute]
        self.stickers = stickers  # type: Optional[List[TypeInputDocument]]
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaUploadedDocument',
            'nosound_video': self.nosound_video,
            'file': None if self.file is None else self.file.to_dict(),
            'thumb': None if self.thumb is None else self.thumb.to_dict(),
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes],
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\xc68[',
            struct.pack('<I', (0 if self.nosound_video is None or self.nosound_video is False else 8) | (0 if self.thumb is None or self.thumb is False else 4) | (0 if self.stickers is None or self.stickers is False else 1) | (0 if self.ttl_seconds is None or self.ttl_seconds is False else 2)),
            bytes(self.file),
            b'' if self.thumb is None or self.thumb is False else (bytes(self.thumb)),
            TLObject.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
            b'' if self.stickers is None or self.stickers is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers))),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _nosound_video = bool(flags & 8)
        _file = reader.tgread_object()
        if flags & 4:
            _thumb = reader.tgread_object()
        else:
            _thumb = None
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        if flags & 1:
            reader.read_int()
            _stickers = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _stickers.append(_x)

        else:
            _stickers = None
        if flags & 2:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaUploadedDocument(file=_file, mime_type=_mime_type, attributes=_attributes, nosound_video=_nosound_video, thumb=_thumb, stickers=_stickers, ttl_seconds=_ttl_seconds)


class InputMediaUploadedPhoto(TLObject):
    CONSTRUCTOR_ID = 0x1e287d04
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, file, stickers=None, ttl_seconds=None):
        """
        :param InputFile file:
        :param list[InputDocument] | None stickers:
        :param int | None ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.file = file  # type: TypeInputFile
        self.stickers = stickers  # type: Optional[List[TypeInputDocument]]
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaUploadedPhoto',
            'file': None if self.file is None else self.file.to_dict(),
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\x04}(\x1e',
            struct.pack('<I', (0 if self.stickers is None or self.stickers is False else 1) | (0 if self.ttl_seconds is None or self.ttl_seconds is False else 2)),
            bytes(self.file),
            b'' if self.stickers is None or self.stickers is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers))),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _file = reader.tgread_object()
        if flags & 1:
            reader.read_int()
            _stickers = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _stickers.append(_x)

        else:
            _stickers = None
        if flags & 2:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return InputMediaUploadedPhoto(file=_file, stickers=_stickers, ttl_seconds=_ttl_seconds)


class InputMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0xc13d1c11
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, geo_point, title, address, provider, venue_id, venue_type):
        """
        :param InputGeoPoint geo_point:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param str venue_type:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        super().__init__()

        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.title = title  # type: str
        self.address = address  # type: str
        self.provider = provider  # type: str
        self.venue_id = venue_id  # type: str
        self.venue_type = venue_type  # type: str

    def to_dict(self):
        return {
            '_': 'InputMediaVenue',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'venue_type': self.venue_type
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\x1c=\xc1',
            bytes(self.geo_point),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.address),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.venue_id),
            TLObject.serialize_bytes(self.venue_type),
        ))

    @staticmethod
    def from_reader(reader):
        _geo_point = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        _venue_type = reader.tgread_string()
        return InputMediaVenue(geo_point=_geo_point, title=_title, address=_address, provider=_provider, venue_id=_venue_id, venue_type=_venue_type)


class InputMessageEntityMentionName(TLObject):
    CONSTRUCTOR_ID = 0x208e68c9
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, user_id):
        """
        :param int offset:
        :param int length:
        :param InputUser user_id:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int
        self.user_id = user_id  # type: TypeInputUser

    def resolve(self, client, utils):
        self.user_id = utils.get_input_user(client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'InputMessageEntityMentionName',
            'offset': self.offset,
            'length': self.length,
            'user_id': None if self.user_id is None else self.user_id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9h\x8e ',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            bytes(self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _user_id = reader.tgread_object()
        return InputMessageEntityMentionName(offset=_offset, length=_length, user_id=_user_id)


class InputMessagesFilterChatPhotos(TLObject):
    CONSTRUCTOR_ID = 0x3a20ecb8
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterChatPhotos'
        }

    def __bytes__(self):
        return b''.join((
            b'\xb8\xec :',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterChatPhotos()


class InputMessagesFilterContacts(TLObject):
    CONSTRUCTOR_ID = 0xe062db83
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'\x83\xdbb\xe0',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterContacts()


class InputMessagesFilterDocument(TLObject):
    CONSTRUCTOR_ID = 0x9eddf188
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterDocument'
        }

    def __bytes__(self):
        return b''.join((
            b'\x88\xf1\xdd\x9e',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterDocument()


class InputMessagesFilterEmpty(TLObject):
    CONSTRUCTOR_ID = 0x57e2f66c
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'l\xf6\xe2W',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterEmpty()


class InputMessagesFilterGeo(TLObject):
    CONSTRUCTOR_ID = 0xe7026d0d
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterGeo'
        }

    def __bytes__(self):
        return b''.join((
            b'\rm\x02\xe7',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterGeo()


class InputMessagesFilterGif(TLObject):
    CONSTRUCTOR_ID = 0xffc86587
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterGif'
        }

    def __bytes__(self):
        return b''.join((
            b'\x87e\xc8\xff',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterGif()


class InputMessagesFilterMusic(TLObject):
    CONSTRUCTOR_ID = 0x3751b49e
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterMusic'
        }

    def __bytes__(self):
        return b''.join((
            b'\x9e\xb4Q7',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterMusic()


class InputMessagesFilterMyMentions(TLObject):
    CONSTRUCTOR_ID = 0xc1f8e69a
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterMyMentions'
        }

    def __bytes__(self):
        return b''.join((
            b'\x9a\xe6\xf8\xc1',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterMyMentions()


class InputMessagesFilterPhoneCalls(TLObject):
    CONSTRUCTOR_ID = 0x80c99768
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self, missed=None):
        """
        :param bool | None missed:

        Constructor for MessagesFilter: Instance of either InputMessagesFilterEmpty, InputMessagesFilterPhotos, InputMessagesFilterVideo, InputMessagesFilterPhotoVideo, InputMessagesFilterDocument, InputMessagesFilterUrl, InputMessagesFilterGif, InputMessagesFilterVoice, InputMessagesFilterMusic, InputMessagesFilterChatPhotos, InputMessagesFilterPhoneCalls, InputMessagesFilterRoundVoice, InputMessagesFilterRoundVideo, InputMessagesFilterMyMentions, InputMessagesFilterGeo, InputMessagesFilterContacts.
        """
        super().__init__()

        self.missed = missed  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterPhoneCalls',
            'missed': self.missed
        }

    def __bytes__(self):
        return b''.join((
            b'h\x97\xc9\x80',
            struct.pack('<I', (0 if self.missed is None or self.missed is False else 1)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _missed = bool(flags & 1)
        return InputMessagesFilterPhoneCalls(missed=_missed)


class InputMessagesFilterPhotoVideo(TLObject):
    CONSTRUCTOR_ID = 0x56e9f0e4
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterPhotoVideo'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4\xf0\xe9V',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterPhotoVideo()


class InputMessagesFilterPhotos(TLObject):
    CONSTRUCTOR_ID = 0x9609a51c
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterPhotos'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\xa5\t\x96',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterPhotos()


class InputMessagesFilterRoundVideo(TLObject):
    CONSTRUCTOR_ID = 0xb549da53
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterRoundVideo'
        }

    def __bytes__(self):
        return b''.join((
            b'S\xdaI\xb5',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterRoundVideo()


class InputMessagesFilterRoundVoice(TLObject):
    CONSTRUCTOR_ID = 0x7a7c17a4
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterRoundVoice'
        }

    def __bytes__(self):
        return b''.join((
            b'\xa4\x17|z',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterRoundVoice()


class InputMessagesFilterUrl(TLObject):
    CONSTRUCTOR_ID = 0x7ef0dd87
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterUrl'
        }

    def __bytes__(self):
        return b''.join((
            b'\x87\xdd\xf0~',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterUrl()


class InputMessagesFilterVideo(TLObject):
    CONSTRUCTOR_ID = 0x9fc00e65
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterVideo'
        }

    def __bytes__(self):
        return b''.join((
            b'e\x0e\xc0\x9f',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterVideo()


class InputMessagesFilterVoice(TLObject):
    CONSTRUCTOR_ID = 0x50f5c392
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterVoice'
        }

    def __bytes__(self):
        return b''.join((
            b'\x92\xc3\xf5P',
        ))

    @staticmethod
    def from_reader(reader):
        return InputMessagesFilterVoice()


class InputNotifyAll(TLObject):
    CONSTRUCTOR_ID = 0xa429b886
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputNotifyAll'
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\xb8)\xa4',
        ))

    @staticmethod
    def from_reader(reader):
        return InputNotifyAll()


class InputNotifyChats(TLObject):
    CONSTRUCTOR_ID = 0x4a95e84e
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputNotifyChats'
        }

    def __bytes__(self):
        return b''.join((
            b'N\xe8\x95J',
        ))

    @staticmethod
    def from_reader(reader):
        return InputNotifyChats()


class InputNotifyPeer(TLObject):
    CONSTRUCTOR_ID = 0xb8bc5b0c
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self, peer):
        """
        :param InputPeer peer:

        Constructor for InputNotifyPeer: Instance of either InputNotifyPeer, InputNotifyUsers, InputNotifyChats, InputNotifyAll.
        """
        super().__init__()

        self.peer = peer  # type: TypeInputPeer

    def resolve(self, client, utils):
        self.peer = utils.get_input_peer(client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'InputNotifyPeer',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c[\xbc\xb8',
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        return InputNotifyPeer(peer=_peer)


class InputNotifyUsers(TLObject):
    CONSTRUCTOR_ID = 0x193b4417
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputNotifyUsers'
        }

    def __bytes__(self):
        return b''.join((
            b'\x17D;\x19',
        ))

    @staticmethod
    def from_reader(reader):
        return InputNotifyUsers()


class InputPaymentCredentials(TLObject):
    CONSTRUCTOR_ID = 0x3417d728
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, data, save=None):
        """
        :param bool | None save:
        :param DataJSON data:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials, InputPaymentCredentialsApplePay, InputPaymentCredentialsAndroidPay.
        """
        super().__init__()

        self.save = save  # type: Optional[bool]
        self.data = data  # type: TypeDataJSON

    def to_dict(self):
        return {
            '_': 'InputPaymentCredentials',
            'save': self.save,
            'data': None if self.data is None else self.data.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'(\xd7\x174',
            struct.pack('<I', (0 if self.save is None or self.save is False else 1)),
            bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _save = bool(flags & 1)
        _data = reader.tgread_object()
        return InputPaymentCredentials(data=_data, save=_save)


class InputPaymentCredentialsAndroidPay(TLObject):
    CONSTRUCTOR_ID = 0xca05d50e
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, payment_token, google_transaction_id):
        """
        :param DataJSON payment_token:
        :param str google_transaction_id:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials, InputPaymentCredentialsApplePay, InputPaymentCredentialsAndroidPay.
        """
        super().__init__()

        self.payment_token = payment_token  # type: TypeDataJSON
        self.google_transaction_id = google_transaction_id  # type: str

    def to_dict(self):
        return {
            '_': 'InputPaymentCredentialsAndroidPay',
            'payment_token': None if self.payment_token is None else self.payment_token.to_dict(),
            'google_transaction_id': self.google_transaction_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x0e\xd5\x05\xca',
            bytes(self.payment_token),
            TLObject.serialize_bytes(self.google_transaction_id),
        ))

    @staticmethod
    def from_reader(reader):
        _payment_token = reader.tgread_object()
        _google_transaction_id = reader.tgread_string()
        return InputPaymentCredentialsAndroidPay(payment_token=_payment_token, google_transaction_id=_google_transaction_id)


class InputPaymentCredentialsApplePay(TLObject):
    CONSTRUCTOR_ID = 0xaa1c39f
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, payment_data):
        """
        :param DataJSON payment_data:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials, InputPaymentCredentialsApplePay, InputPaymentCredentialsAndroidPay.
        """
        super().__init__()

        self.payment_data = payment_data  # type: TypeDataJSON

    def to_dict(self):
        return {
            '_': 'InputPaymentCredentialsApplePay',
            'payment_data': None if self.payment_data is None else self.payment_data.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f\xc3\xa1\n',
            bytes(self.payment_data),
        ))

    @staticmethod
    def from_reader(reader):
        _payment_data = reader.tgread_object()
        return InputPaymentCredentialsApplePay(payment_data=_payment_data)


class InputPaymentCredentialsSaved(TLObject):
    CONSTRUCTOR_ID = 0xc10eb2cf
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, id, tmp_password):
        """
        :param str id:
        :param bytes tmp_password:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials, InputPaymentCredentialsApplePay, InputPaymentCredentialsAndroidPay.
        """
        super().__init__()

        self.id = id  # type: str
        self.tmp_password = tmp_password  # type: bytes

    def to_dict(self):
        return {
            '_': 'InputPaymentCredentialsSaved',
            'id': self.id,
            'tmp_password': self.tmp_password
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\xb2\x0e\xc1',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.tmp_password),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _tmp_password = reader.tgread_bytes()
        return InputPaymentCredentialsSaved(id=_id, tmp_password=_tmp_password)


class InputPeerChannel(TLObject):
    CONSTRUCTOR_ID = 0x20adaef8
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, channel_id, access_hash):
        """
        :param int channel_id:
        :param int access_hash:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputPeerChannel',
            'channel_id': self.channel_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xf8\xae\xad ',
            struct.pack('<i', self.channel_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputPeerChannel(channel_id=_channel_id, access_hash=_access_hash)


class InputPeerChat(TLObject):
    CONSTRUCTOR_ID = 0x179be863
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'InputPeerChat',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'c\xe8\x9b\x17',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return InputPeerChat(chat_id=_chat_id)


class InputPeerEmpty(TLObject):
    CONSTRUCTOR_ID = 0x7f3b18ea
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPeerEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xea\x18;\x7f',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPeerEmpty()


class InputPeerNotifyEventsAll(TLObject):
    CONSTRUCTOR_ID = 0xe86a2c74
    SUBCLASS_OF_ID = 0x8f66c45c

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPeerNotifyEventsAll'
        }

    def __bytes__(self):
        return b''.join((
            b't,j\xe8',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPeerNotifyEventsAll()


class InputPeerNotifyEventsEmpty(TLObject):
    CONSTRUCTOR_ID = 0xf03064d8
    SUBCLASS_OF_ID = 0x8f66c45c

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPeerNotifyEventsEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8d0\xf0',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPeerNotifyEventsEmpty()


class InputPeerNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0x38935eb2
    SUBCLASS_OF_ID = 0x90db0b0d

    def __init__(self, mute_until, sound, show_previews=None, silent=None):
        """
        :param bool | None show_previews:
        :param bool | None silent:
        :param int mute_until:
        :param str sound:

        Constructor for InputPeerNotifySettings: Instance of InputPeerNotifySettings.
        """
        super().__init__()

        self.show_previews = show_previews  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.mute_until = mute_until  # type: int
        self.sound = sound  # type: str

    def to_dict(self):
        return {
            '_': 'InputPeerNotifySettings',
            'show_previews': self.show_previews,
            'silent': self.silent,
            'mute_until': self.mute_until,
            'sound': self.sound
        }

    def __bytes__(self):
        return b''.join((
            b'\xb2^\x938',
            struct.pack('<I', (0 if self.show_previews is None or self.show_previews is False else 1) | (0 if self.silent is None or self.silent is False else 2)),
            struct.pack('<i', self.mute_until),
            TLObject.serialize_bytes(self.sound),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _show_previews = bool(flags & 1)
        _silent = bool(flags & 2)
        _mute_until = reader.read_int()
        _sound = reader.tgread_string()
        return InputPeerNotifySettings(mute_until=_mute_until, sound=_sound, show_previews=_show_previews, silent=_silent)


class InputPeerSelf(TLObject):
    CONSTRUCTOR_ID = 0x7da07ec9
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPeerSelf'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9~\xa0}',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPeerSelf()


class InputPeerUser(TLObject):
    CONSTRUCTOR_ID = 0x7b8e7de6
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, user_id, access_hash):
        """
        :param int user_id:
        :param int access_hash:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputPeerUser',
            'user_id': self.user_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6}\x8e{',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputPeerUser(user_id=_user_id, access_hash=_access_hash)


class InputPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x1e36fded
    SUBCLASS_OF_ID = 0xbcaaf240

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputPhoneCall: Instance of InputPhoneCall.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputPhoneCall',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xed\xfd6\x1e',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputPhoneCall(id=_id, access_hash=_access_hash)


class InputPhoneContact(TLObject):
    CONSTRUCTOR_ID = 0xf392b7f4
    SUBCLASS_OF_ID = 0xae696a82

    def __init__(self, client_id, phone, first_name, last_name):
        """
        :param int client_id:
        :param str phone:
        :param str first_name:
        :param str last_name:

        Constructor for InputContact: Instance of InputPhoneContact.
        """
        super().__init__()

        self.client_id = client_id  # type: int
        self.phone = phone  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str

    def to_dict(self):
        return {
            '_': 'InputPhoneContact',
            'client_id': self.client_id,
            'phone': self.phone,
            'first_name': self.first_name,
            'last_name': self.last_name
        }

    def __bytes__(self):
        return b''.join((
            b'\xf4\xb7\x92\xf3',
            struct.pack('<q', self.client_id),
            TLObject.serialize_bytes(self.phone),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
        ))

    @staticmethod
    def from_reader(reader):
        _client_id = reader.read_long()
        _phone = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        return InputPhoneContact(client_id=_client_id, phone=_phone, first_name=_first_name, last_name=_last_name)


class InputPhoto(TLObject):
    CONSTRUCTOR_ID = 0xfb95c6c4
    SUBCLASS_OF_ID = 0x846363e0

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputPhoto: Instance of either InputPhotoEmpty, InputPhoto.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputPhoto',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xc6\x95\xfb',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputPhoto(id=_id, access_hash=_access_hash)


class InputPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1cd7bf0d
    SUBCLASS_OF_ID = 0x846363e0

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPhotoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\r\xbf\xd7\x1c',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPhotoEmpty()


class InputPrivacyKeyChatInvite(TLObject):
    CONSTRUCTOR_ID = 0xbdfb0426
    SUBCLASS_OF_ID = 0x53627f8

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPrivacyKeyChatInvite'
        }

    def __bytes__(self):
        return b''.join((
            b'&\x04\xfb\xbd',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyKeyChatInvite()


class InputPrivacyKeyPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xfabadc5f
    SUBCLASS_OF_ID = 0x53627f8

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPrivacyKeyPhoneCall'
        }

    def __bytes__(self):
        return b''.join((
            b'_\xdc\xba\xfa',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyKeyPhoneCall()


class InputPrivacyKeyStatusTimestamp(TLObject):
    CONSTRUCTOR_ID = 0x4f96cb18
    SUBCLASS_OF_ID = 0x53627f8

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPrivacyKeyStatusTimestamp'
        }

    def __bytes__(self):
        return b''.join((
            b'\x18\xcb\x96O',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyKeyStatusTimestamp()


class InputPrivacyValueAllowAll(TLObject):
    CONSTRUCTOR_ID = 0x184b35ce
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueAllowAll'
        }

    def __bytes__(self):
        return b''.join((
            b'\xce5K\x18',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyValueAllowAll()


class InputPrivacyValueAllowContacts(TLObject):
    CONSTRUCTOR_ID = 0xd09e07b
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueAllowContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'{\xe0\t\r',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyValueAllowContacts()


class InputPrivacyValueAllowUsers(TLObject):
    CONSTRUCTOR_ID = 0x131cc67f
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self, users):
        """
        :param list[InputUser] users:

        Constructor for InputPrivacyRule: Instance of either InputPrivacyValueAllowContacts, InputPrivacyValueAllowAll, InputPrivacyValueAllowUsers, InputPrivacyValueDisallowContacts, InputPrivacyValueDisallowAll, InputPrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users  # type: List[TypeInputUser]

    def resolve(self, client, utils):
        self.users = [utils.get_input_user(client.get_input_entity(_x)) for _x in self.users]

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueAllowUsers',
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xc6\x1c\x13',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return InputPrivacyValueAllowUsers(users=_users)


class InputPrivacyValueDisallowAll(TLObject):
    CONSTRUCTOR_ID = 0xd66b66c9
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueDisallowAll'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9fk\xd6',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyValueDisallowAll()


class InputPrivacyValueDisallowContacts(TLObject):
    CONSTRUCTOR_ID = 0xba52007
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueDisallowContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'\x07 \xa5\x0b',
        ))

    @staticmethod
    def from_reader(reader):
        return InputPrivacyValueDisallowContacts()


class InputPrivacyValueDisallowUsers(TLObject):
    CONSTRUCTOR_ID = 0x90110467
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self, users):
        """
        :param list[InputUser] users:

        Constructor for InputPrivacyRule: Instance of either InputPrivacyValueAllowContacts, InputPrivacyValueAllowAll, InputPrivacyValueAllowUsers, InputPrivacyValueDisallowContacts, InputPrivacyValueDisallowAll, InputPrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users  # type: List[TypeInputUser]

    def resolve(self, client, utils):
        self.users = [utils.get_input_user(client.get_input_entity(_x)) for _x in self.users]

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueDisallowUsers',
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'g\x04\x11\x90',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return InputPrivacyValueDisallowUsers(users=_users)


class InputReportReasonOther(TLObject):
    CONSTRUCTOR_ID = 0xe1746d0a
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self, text):
        """
        :param str text:

        Constructor for ReportReason: Instance of either InputReportReasonSpam, InputReportReasonViolence, InputReportReasonPornography, InputReportReasonOther.
        """
        super().__init__()

        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'InputReportReasonOther',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\nmt\xe1',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return InputReportReasonOther(text=_text)


class InputReportReasonPornography(TLObject):
    CONSTRUCTOR_ID = 0x2e59d922
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputReportReasonPornography'
        }

    def __bytes__(self):
        return b''.join((
            b'"\xd9Y.',
        ))

    @staticmethod
    def from_reader(reader):
        return InputReportReasonPornography()


class InputReportReasonSpam(TLObject):
    CONSTRUCTOR_ID = 0x58dbcab8
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputReportReasonSpam'
        }

    def __bytes__(self):
        return b''.join((
            b'\xb8\xca\xdbX',
        ))

    @staticmethod
    def from_reader(reader):
        return InputReportReasonSpam()


class InputReportReasonViolence(TLObject):
    CONSTRUCTOR_ID = 0x1e22c78d
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputReportReasonViolence'
        }

    def __bytes__(self):
        return b''.join((
            b'\x8d\xc7"\x1e',
        ))

    @staticmethod
    def from_reader(reader):
        return InputReportReasonViolence()


class InputSingleMedia(TLObject):
    CONSTRUCTOR_ID = 0x31bc3d25
    SUBCLASS_OF_ID = 0x21ca8ed8

    def __init__(self, media, message, random_id=None, entities=None):
        """
        :param InputMedia media:
        :param int random_id:
        :param str message:
        :param list[MessageEntity] | None entities:

        Constructor for InputSingleMedia: Instance of InputSingleMedia.
        """
        super().__init__()

        self.media = media  # type: TypeInputMedia
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def resolve(self, client, utils):
        self.media = utils.get_input_media(self.media)

    def to_dict(self):
        return {
            '_': 'InputSingleMedia',
            'media': None if self.media is None else self.media.to_dict(),
            'random_id': self.random_id,
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'%=\xbc1',
            bytes(self.media),
            struct.pack('<I', (0 if self.entities is None or self.entities is False else 1)),
            struct.pack('<q', self.random_id),
            TLObject.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        _media = reader.tgread_object()
        flags = reader.read_int()

        _random_id = reader.read_long()
        _message = reader.tgread_string()
        if flags & 1:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return InputSingleMedia(media=_media, message=_message, random_id=_random_id, entities=_entities)


class InputStickerSetEmpty(TLObject):
    CONSTRUCTOR_ID = 0xffb62b95
    SUBCLASS_OF_ID = 0x3da389aa

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputStickerSetEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x95+\xb6\xff',
        ))

    @staticmethod
    def from_reader(reader):
        return InputStickerSetEmpty()


class InputStickerSetID(TLObject):
    CONSTRUCTOR_ID = 0x9de7a269
    SUBCLASS_OF_ID = 0x3da389aa

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputStickerSet: Instance of either InputStickerSetEmpty, InputStickerSetID, InputStickerSetShortName.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputStickerSetID',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'i\xa2\xe7\x9d',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return InputStickerSetID(id=_id, access_hash=_access_hash)


class InputStickerSetItem(TLObject):
    CONSTRUCTOR_ID = 0xffa0a496
    SUBCLASS_OF_ID = 0xae59f075

    def __init__(self, document, emoji, mask_coords=None):
        """
        :param InputDocument document:
        :param str emoji:
        :param MaskCoords | None mask_coords:

        Constructor for InputStickerSetItem: Instance of InputStickerSetItem.
        """
        super().__init__()

        self.document = document  # type: TypeInputDocument
        self.emoji = emoji  # type: str
        self.mask_coords = mask_coords  # type: Optional[TypeMaskCoords]

    def to_dict(self):
        return {
            '_': 'InputStickerSetItem',
            'document': None if self.document is None else self.document.to_dict(),
            'emoji': self.emoji,
            'mask_coords': None if self.mask_coords is None else self.mask_coords.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x96\xa4\xa0\xff',
            struct.pack('<I', (0 if self.mask_coords is None or self.mask_coords is False else 1)),
            bytes(self.document),
            TLObject.serialize_bytes(self.emoji),
            b'' if self.mask_coords is None or self.mask_coords is False else (bytes(self.mask_coords)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _document = reader.tgread_object()
        _emoji = reader.tgread_string()
        if flags & 1:
            _mask_coords = reader.tgread_object()
        else:
            _mask_coords = None
        return InputStickerSetItem(document=_document, emoji=_emoji, mask_coords=_mask_coords)


class InputStickerSetShortName(TLObject):
    CONSTRUCTOR_ID = 0x861cc8a0
    SUBCLASS_OF_ID = 0x3da389aa

    def __init__(self, short_name):
        """
        :param str short_name:

        Constructor for InputStickerSet: Instance of either InputStickerSetEmpty, InputStickerSetID, InputStickerSetShortName.
        """
        super().__init__()

        self.short_name = short_name  # type: str

    def to_dict(self):
        return {
            '_': 'InputStickerSetShortName',
            'short_name': self.short_name
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc8\x1c\x86',
            TLObject.serialize_bytes(self.short_name),
        ))

    @staticmethod
    def from_reader(reader):
        _short_name = reader.tgread_string()
        return InputStickerSetShortName(short_name=_short_name)


class InputStickeredMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x438865b
    SUBCLASS_OF_ID = 0x5146d99e

    def __init__(self, id):
        """
        :param InputDocument id:

        Constructor for InputStickeredMedia: Instance of either InputStickeredMediaPhoto, InputStickeredMediaDocument.
        """
        super().__init__()

        self.id = id  # type: TypeInputDocument

    def to_dict(self):
        return {
            '_': 'InputStickeredMediaDocument',
            'id': None if self.id is None else self.id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'[\x868\x04',
            bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        return InputStickeredMediaDocument(id=_id)


class InputStickeredMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0x4a992157
    SUBCLASS_OF_ID = 0x5146d99e

    def __init__(self, id):
        """
        :param InputPhoto id:

        Constructor for InputStickeredMedia: Instance of either InputStickeredMediaPhoto, InputStickeredMediaDocument.
        """
        super().__init__()

        self.id = id  # type: TypeInputPhoto

    def resolve(self, client, utils):
        self.id = utils.get_input_photo(self.id)

    def to_dict(self):
        return {
            '_': 'InputStickeredMediaPhoto',
            'id': None if self.id is None else self.id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'W!\x99J',
            bytes(self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_object()
        return InputStickeredMediaPhoto(id=_id)


class InputUser(TLObject):
    CONSTRUCTOR_ID = 0xd8292816
    SUBCLASS_OF_ID = 0xe669bf46

    def __init__(self, user_id, access_hash):
        """
        :param int user_id:
        :param int access_hash:

        Constructor for InputUser: Instance of either InputUserEmpty, InputUserSelf, InputUser.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputUser',
            'user_id': self.user_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x16()\xd8',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _access_hash = reader.read_long()
        return InputUser(user_id=_user_id, access_hash=_access_hash)


class InputUserEmpty(TLObject):
    CONSTRUCTOR_ID = 0xb98886cf
    SUBCLASS_OF_ID = 0xe669bf46

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputUserEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\x86\x88\xb9',
        ))

    @staticmethod
    def from_reader(reader):
        return InputUserEmpty()


class InputUserSelf(TLObject):
    CONSTRUCTOR_ID = 0xf7c1b13f
    SUBCLASS_OF_ID = 0xe669bf46

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'InputUserSelf'
        }

    def __bytes__(self):
        return b''.join((
            b'?\xb1\xc1\xf7',
        ))

    @staticmethod
    def from_reader(reader):
        return InputUserSelf()


class InputWebDocument(TLObject):
    CONSTRUCTOR_ID = 0x9bed434d
    SUBCLASS_OF_ID = 0x8ae8b146

    def __init__(self, url, size, mime_type, attributes):
        """
        :param str url:
        :param int size:
        :param str mime_type:
        :param list[DocumentAttribute] attributes:

        Constructor for InputWebDocument: Instance of InputWebDocument.
        """
        super().__init__()

        self.url = url  # type: str
        self.size = size  # type: int
        self.mime_type = mime_type  # type: str
        self.attributes = attributes  # type: List[TypeDocumentAttribute]

    def to_dict(self):
        return {
            '_': 'InputWebDocument',
            'url': self.url,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]
        }

    def __bytes__(self):
        return b''.join((
            b'MC\xed\x9b',
            TLObject.serialize_bytes(self.url),
            struct.pack('<i', self.size),
            TLObject.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        return InputWebDocument(url=_url, size=_size, mime_type=_mime_type, attributes=_attributes)


class InputWebFileLocation(TLObject):
    CONSTRUCTOR_ID = 0xc239d686
    SUBCLASS_OF_ID = 0xf72ed8d9

    def __init__(self, url, access_hash):
        """
        :param str url:
        :param int access_hash:

        Constructor for InputWebFileLocation: Instance of InputWebFileLocation.
        """
        super().__init__()

        self.url = url  # type: str
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputWebFileLocation',
            'url': self.url,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\xd69\xc2',
            TLObject.serialize_bytes(self.url),
            struct.pack('<q', self.access_hash),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _access_hash = reader.read_long()
        return InputWebFileLocation(url=_url, access_hash=_access_hash)


class Invoice(TLObject):
    CONSTRUCTOR_ID = 0xc30aa358
    SUBCLASS_OF_ID = 0x5fd82ed8

    def __init__(self, currency, prices, test=None, name_requested=None, phone_requested=None, email_requested=None, shipping_address_requested=None, flexible=None, phone_to_provider=None, email_to_provider=None):
        """
        :param bool | None test:
        :param bool | None name_requested:
        :param bool | None phone_requested:
        :param bool | None email_requested:
        :param bool | None shipping_address_requested:
        :param bool | None flexible:
        :param bool | None phone_to_provider:
        :param bool | None email_to_provider:
        :param str currency:
        :param list[LabeledPrice] prices:

        Constructor for Invoice: Instance of Invoice.
        """
        super().__init__()

        self.test = test  # type: Optional[bool]
        self.name_requested = name_requested  # type: Optional[bool]
        self.phone_requested = phone_requested  # type: Optional[bool]
        self.email_requested = email_requested  # type: Optional[bool]
        self.shipping_address_requested = shipping_address_requested  # type: Optional[bool]
        self.flexible = flexible  # type: Optional[bool]
        self.phone_to_provider = phone_to_provider  # type: Optional[bool]
        self.email_to_provider = email_to_provider  # type: Optional[bool]
        self.currency = currency  # type: str
        self.prices = prices  # type: List[TypeLabeledPrice]

    def to_dict(self):
        return {
            '_': 'Invoice',
            'test': self.test,
            'name_requested': self.name_requested,
            'phone_requested': self.phone_requested,
            'email_requested': self.email_requested,
            'shipping_address_requested': self.shipping_address_requested,
            'flexible': self.flexible,
            'phone_to_provider': self.phone_to_provider,
            'email_to_provider': self.email_to_provider,
            'currency': self.currency,
            'prices': [] if self.prices is None else [None if x is None else x.to_dict() for x in self.prices]
        }

    def __bytes__(self):
        return b''.join((
            b'X\xa3\n\xc3',
            struct.pack('<I', (0 if self.test is None or self.test is False else 1) | (0 if self.name_requested is None or self.name_requested is False else 2) | (0 if self.phone_requested is None or self.phone_requested is False else 4) | (0 if self.email_requested is None or self.email_requested is False else 8) | (0 if self.shipping_address_requested is None or self.shipping_address_requested is False else 16) | (0 if self.flexible is None or self.flexible is False else 32) | (0 if self.phone_to_provider is None or self.phone_to_provider is False else 64) | (0 if self.email_to_provider is None or self.email_to_provider is False else 128)),
            TLObject.serialize_bytes(self.currency),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.prices)),b''.join(bytes(x) for x in self.prices),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _test = bool(flags & 1)
        _name_requested = bool(flags & 2)
        _phone_requested = bool(flags & 4)
        _email_requested = bool(flags & 8)
        _shipping_address_requested = bool(flags & 16)
        _flexible = bool(flags & 32)
        _phone_to_provider = bool(flags & 64)
        _email_to_provider = bool(flags & 128)
        _currency = reader.tgread_string()
        reader.read_int()
        _prices = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _prices.append(_x)

        return Invoice(currency=_currency, prices=_prices, test=_test, name_requested=_name_requested, phone_requested=_phone_requested, email_requested=_email_requested, shipping_address_requested=_shipping_address_requested, flexible=_flexible, phone_to_provider=_phone_to_provider, email_to_provider=_email_to_provider)


class IpPort(TLObject):
    CONSTRUCTOR_ID = 0xd433ad73
    SUBCLASS_OF_ID = 0xa2a03726

    def __init__(self, ipv4, port):
        """
        :param int ipv4:
        :param int port:

        Constructor for IpPort: Instance of IpPort.
        """
        super().__init__()

        self.ipv4 = ipv4  # type: int
        self.port = port  # type: int

    def to_dict(self):
        return {
            '_': 'IpPort',
            'ipv4': self.ipv4,
            'port': self.port
        }

    def __bytes__(self):
        return b''.join((
            b's\xad3\xd4',
            struct.pack('<i', self.ipv4),
            struct.pack('<i', self.port),
        ))

    @staticmethod
    def from_reader(reader):
        _ipv4 = reader.read_int()
        _port = reader.read_int()
        return IpPort(ipv4=_ipv4, port=_port)


class KeyboardButton(TLObject):
    CONSTRUCTOR_ID = 0xa2fa4880
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButton',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\x80H\xfa\xa2',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButton(text=_text)


class KeyboardButtonBuy(TLObject):
    CONSTRUCTOR_ID = 0xafd93fbb
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonBuy',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb?\xd9\xaf',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButtonBuy(text=_text)


class KeyboardButtonCallback(TLObject):
    CONSTRUCTOR_ID = 0x683a5e46
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, data):
        """
        :param str text:
        :param bytes data:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text  # type: str
        self.data = data  # type: bytes

    def to_dict(self):
        return {
            '_': 'KeyboardButtonCallback',
            'text': self.text,
            'data': self.data
        }

    def __bytes__(self):
        return b''.join((
            b'F^:h',
            TLObject.serialize_bytes(self.text),
            TLObject.serialize_bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        _data = reader.tgread_bytes()
        return KeyboardButtonCallback(text=_text, data=_data)


class KeyboardButtonGame(TLObject):
    CONSTRUCTOR_ID = 0x50f41ccf
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonGame',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\x1c\xf4P',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButtonGame(text=_text)


class KeyboardButtonRequestGeoLocation(TLObject):
    CONSTRUCTOR_ID = 0xfc796b3f
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonRequestGeoLocation',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'?ky\xfc',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButtonRequestGeoLocation(text=_text)


class KeyboardButtonRequestPhone(TLObject):
    CONSTRUCTOR_ID = 0xb16a6c29
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonRequestPhone',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b')lj\xb1',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return KeyboardButtonRequestPhone(text=_text)


class KeyboardButtonRow(TLObject):
    CONSTRUCTOR_ID = 0x77608b83
    SUBCLASS_OF_ID = 0x847730ae

    def __init__(self, buttons):
        """
        :param list[KeyboardButton] buttons:

        Constructor for KeyboardButtonRow: Instance of KeyboardButtonRow.
        """
        super().__init__()

        self.buttons = buttons  # type: List[TypeKeyboardButton]

    def to_dict(self):
        return {
            '_': 'KeyboardButtonRow',
            'buttons': [] if self.buttons is None else [None if x is None else x.to_dict() for x in self.buttons]
        }

    def __bytes__(self):
        return b''.join((
            b'\x83\x8b`w',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.buttons)),b''.join(bytes(x) for x in self.buttons),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _buttons = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _buttons.append(_x)

        return KeyboardButtonRow(buttons=_buttons)


class KeyboardButtonSwitchInline(TLObject):
    CONSTRUCTOR_ID = 0x568a748
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, query, same_peer=None):
        """
        :param bool | None same_peer:
        :param str text:
        :param str query:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.same_peer = same_peer  # type: Optional[bool]
        self.text = text  # type: str
        self.query = query  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonSwitchInline',
            'same_peer': self.same_peer,
            'text': self.text,
            'query': self.query
        }

    def __bytes__(self):
        return b''.join((
            b'H\xa7h\x05',
            struct.pack('<I', (0 if self.same_peer is None or self.same_peer is False else 1)),
            TLObject.serialize_bytes(self.text),
            TLObject.serialize_bytes(self.query),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _same_peer = bool(flags & 1)
        _text = reader.tgread_string()
        _query = reader.tgread_string()
        return KeyboardButtonSwitchInline(text=_text, query=_query, same_peer=_same_peer)


class KeyboardButtonUrl(TLObject):
    CONSTRUCTOR_ID = 0x258aff05
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, url):
        """
        :param str text:
        :param str url:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        super().__init__()

        self.text = text  # type: str
        self.url = url  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonUrl',
            'text': self.text,
            'url': self.url
        }

    def __bytes__(self):
        return b''.join((
            b'\x05\xff\x8a%',
            TLObject.serialize_bytes(self.text),
            TLObject.serialize_bytes(self.url),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        _url = reader.tgread_string()
        return KeyboardButtonUrl(text=_text, url=_url)


class LabeledPrice(TLObject):
    CONSTRUCTOR_ID = 0xcb296bf8
    SUBCLASS_OF_ID = 0x1c84047a

    def __init__(self, label, amount):
        """
        :param str label:
        :param int amount:

        Constructor for LabeledPrice: Instance of LabeledPrice.
        """
        super().__init__()

        self.label = label  # type: str
        self.amount = amount  # type: int

    def to_dict(self):
        return {
            '_': 'LabeledPrice',
            'label': self.label,
            'amount': self.amount
        }

    def __bytes__(self):
        return b''.join((
            b'\xf8k)\xcb',
            TLObject.serialize_bytes(self.label),
            struct.pack('<q', self.amount),
        ))

    @staticmethod
    def from_reader(reader):
        _label = reader.tgread_string()
        _amount = reader.read_long()
        return LabeledPrice(label=_label, amount=_amount)


class LangPackDifference(TLObject):
    CONSTRUCTOR_ID = 0xf385c1f6
    SUBCLASS_OF_ID = 0x52662d55

    def __init__(self, lang_code, from_version, version, strings):
        """
        :param str lang_code:
        :param int from_version:
        :param int version:
        :param list[LangPackString] strings:

        Constructor for LangPackDifference: Instance of LangPackDifference.
        """
        super().__init__()

        self.lang_code = lang_code  # type: str
        self.from_version = from_version  # type: int
        self.version = version  # type: int
        self.strings = strings  # type: List[TypeLangPackString]

    def to_dict(self):
        return {
            '_': 'LangPackDifference',
            'lang_code': self.lang_code,
            'from_version': self.from_version,
            'version': self.version,
            'strings': [] if self.strings is None else [None if x is None else x.to_dict() for x in self.strings]
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xc1\x85\xf3',
            TLObject.serialize_bytes(self.lang_code),
            struct.pack('<i', self.from_version),
            struct.pack('<i', self.version),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.strings)),b''.join(bytes(x) for x in self.strings),
        ))

    @staticmethod
    def from_reader(reader):
        _lang_code = reader.tgread_string()
        _from_version = reader.read_int()
        _version = reader.read_int()
        reader.read_int()
        _strings = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _strings.append(_x)

        return LangPackDifference(lang_code=_lang_code, from_version=_from_version, version=_version, strings=_strings)


class LangPackLanguage(TLObject):
    CONSTRUCTOR_ID = 0x117698f1
    SUBCLASS_OF_ID = 0xabac89b7

    def __init__(self, name, native_name, lang_code):
        """
        :param str name:
        :param str native_name:
        :param str lang_code:

        Constructor for LangPackLanguage: Instance of LangPackLanguage.
        """
        super().__init__()

        self.name = name  # type: str
        self.native_name = native_name  # type: str
        self.lang_code = lang_code  # type: str

    def to_dict(self):
        return {
            '_': 'LangPackLanguage',
            'name': self.name,
            'native_name': self.native_name,
            'lang_code': self.lang_code
        }

    def __bytes__(self):
        return b''.join((
            b'\xf1\x98v\x11',
            TLObject.serialize_bytes(self.name),
            TLObject.serialize_bytes(self.native_name),
            TLObject.serialize_bytes(self.lang_code),
        ))

    @staticmethod
    def from_reader(reader):
        _name = reader.tgread_string()
        _native_name = reader.tgread_string()
        _lang_code = reader.tgread_string()
        return LangPackLanguage(name=_name, native_name=_native_name, lang_code=_lang_code)


class LangPackString(TLObject):
    CONSTRUCTOR_ID = 0xcad181f6
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key, value):
        """
        :param str key:
        :param str value:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key  # type: str
        self.value = value  # type: str

    def to_dict(self):
        return {
            '_': 'LangPackString',
            'key': self.key,
            'value': self.value
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\x81\xd1\xca',
            TLObject.serialize_bytes(self.key),
            TLObject.serialize_bytes(self.value),
        ))

    @staticmethod
    def from_reader(reader):
        _key = reader.tgread_string()
        _value = reader.tgread_string()
        return LangPackString(key=_key, value=_value)


class LangPackStringDeleted(TLObject):
    CONSTRUCTOR_ID = 0x2979eeb2
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key):
        """
        :param str key:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key  # type: str

    def to_dict(self):
        return {
            '_': 'LangPackStringDeleted',
            'key': self.key
        }

    def __bytes__(self):
        return b''.join((
            b'\xb2\xeey)',
            TLObject.serialize_bytes(self.key),
        ))

    @staticmethod
    def from_reader(reader):
        _key = reader.tgread_string()
        return LangPackStringDeleted(key=_key)


class LangPackStringPluralized(TLObject):
    CONSTRUCTOR_ID = 0x6c47ac9f
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key, other_value, zero_value=None, one_value=None, two_value=None, few_value=None, many_value=None):
        """
        :param str key:
        :param str | None zero_value:
        :param str | None one_value:
        :param str | None two_value:
        :param str | None few_value:
        :param str | None many_value:
        :param str other_value:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        super().__init__()

        self.key = key  # type: str
        self.zero_value = zero_value  # type: Optional[str]
        self.one_value = one_value  # type: Optional[str]
        self.two_value = two_value  # type: Optional[str]
        self.few_value = few_value  # type: Optional[str]
        self.many_value = many_value  # type: Optional[str]
        self.other_value = other_value  # type: str

    def to_dict(self):
        return {
            '_': 'LangPackStringPluralized',
            'key': self.key,
            'zero_value': self.zero_value,
            'one_value': self.one_value,
            'two_value': self.two_value,
            'few_value': self.few_value,
            'many_value': self.many_value,
            'other_value': self.other_value
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f\xacGl',
            struct.pack('<I', (0 if self.zero_value is None or self.zero_value is False else 1) | (0 if self.one_value is None or self.one_value is False else 2) | (0 if self.two_value is None or self.two_value is False else 4) | (0 if self.few_value is None or self.few_value is False else 8) | (0 if self.many_value is None or self.many_value is False else 16)),
            TLObject.serialize_bytes(self.key),
            b'' if self.zero_value is None or self.zero_value is False else (TLObject.serialize_bytes(self.zero_value)),
            b'' if self.one_value is None or self.one_value is False else (TLObject.serialize_bytes(self.one_value)),
            b'' if self.two_value is None or self.two_value is False else (TLObject.serialize_bytes(self.two_value)),
            b'' if self.few_value is None or self.few_value is False else (TLObject.serialize_bytes(self.few_value)),
            b'' if self.many_value is None or self.many_value is False else (TLObject.serialize_bytes(self.many_value)),
            TLObject.serialize_bytes(self.other_value),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _key = reader.tgread_string()
        if flags & 1:
            _zero_value = reader.tgread_string()
        else:
            _zero_value = None
        if flags & 2:
            _one_value = reader.tgread_string()
        else:
            _one_value = None
        if flags & 4:
            _two_value = reader.tgread_string()
        else:
            _two_value = None
        if flags & 8:
            _few_value = reader.tgread_string()
        else:
            _few_value = None
        if flags & 16:
            _many_value = reader.tgread_string()
        else:
            _many_value = None
        _other_value = reader.tgread_string()
        return LangPackStringPluralized(key=_key, other_value=_other_value, zero_value=_zero_value, one_value=_one_value, two_value=_two_value, few_value=_few_value, many_value=_many_value)


class MaskCoords(TLObject):
    CONSTRUCTOR_ID = 0xaed6dbb2
    SUBCLASS_OF_ID = 0x6bbb2fd

    def __init__(self, n, x, y, zoom):
        """
        :param int n:
        :param double x:
        :param double y:
        :param double zoom:

        Constructor for MaskCoords: Instance of MaskCoords.
        """
        super().__init__()

        self.n = n  # type: int
        self.x = x  # type: Typedouble
        self.y = y  # type: Typedouble
        self.zoom = zoom  # type: Typedouble

    def to_dict(self):
        return {
            '_': 'MaskCoords',
            'n': self.n,
            'x': self.x,
            'y': self.y,
            'zoom': self.zoom
        }

    def __bytes__(self):
        return b''.join((
            b'\xb2\xdb\xd6\xae',
            struct.pack('<i', self.n),
            struct.pack('<d', self.x),
            struct.pack('<d', self.y),
            struct.pack('<d', self.zoom),
        ))

    @staticmethod
    def from_reader(reader):
        _n = reader.read_int()
        _x = reader.read_double()
        _y = reader.read_double()
        _zoom = reader.read_double()
        return MaskCoords(n=_n, x=_x, y=_y, zoom=_zoom)


class Message(TLObject):
    CONSTRUCTOR_ID = 0x44f9b43d
    SUBCLASS_OF_ID = 0x790009e3

    def __init__(self, id, to_id, date, message, out=None, mentioned=None, media_unread=None, silent=None, post=None, from_id=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, media=None, reply_markup=None, entities=None, views=None, edit_date=None, post_author=None, grouped_id=None):
        """
        :param bool | None out:
        :param bool | None mentioned:
        :param bool | None media_unread:
        :param bool | None silent:
        :param bool | None post:
        :param int id:
        :param int | None from_id:
        :param Peer to_id:
        :param MessageFwdHeader | None fwd_from:
        :param int | None via_bot_id:
        :param int | None reply_to_msg_id:
        :param datetime.datetime | None date:
        :param str message:
        :param MessageMedia | None media:
        :param ReplyMarkup | None reply_markup:
        :param list[MessageEntity] | None entities:
        :param int | None views:
        :param datetime.datetime | None edit_date:
        :param str | None post_author:
        :param int | None grouped_id:

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.out = out  # type: Optional[bool]
        self.mentioned = mentioned  # type: Optional[bool]
        self.media_unread = media_unread  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.post = post  # type: Optional[bool]
        self.id = id  # type: int
        self.from_id = from_id  # type: Optional[int]
        self.to_id = to_id  # type: TypePeer
        self.fwd_from = fwd_from  # type: Optional[TypeMessageFwdHeader]
        self.via_bot_id = via_bot_id  # type: Optional[int]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.date = date  # type: Optional[datetime]
        self.message = message  # type: str
        self.media = media  # type: Optional[TypeMessageMedia]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.views = views  # type: Optional[int]
        self.edit_date = edit_date  # type: Optional[datetime]
        self.post_author = post_author  # type: Optional[str]
        self.grouped_id = grouped_id  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'Message',
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'post': self.post,
            'id': self.id,
            'from_id': self.from_id,
            'to_id': None if self.to_id is None else self.to_id.to_dict(),
            'fwd_from': None if self.fwd_from is None else self.fwd_from.to_dict(),
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'date': self.date,
            'message': self.message,
            'media': None if self.media is None else self.media.to_dict(),
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'views': self.views,
            'edit_date': self.edit_date,
            'post_author': self.post_author,
            'grouped_id': self.grouped_id
        }

    def __bytes__(self):
        return b''.join((
            b'=\xb4\xf9D',
            struct.pack('<I', (0 if self.out is None or self.out is False else 2) | (0 if self.mentioned is None or self.mentioned is False else 16) | (0 if self.media_unread is None or self.media_unread is False else 32) | (0 if self.silent is None or self.silent is False else 8192) | (0 if self.post is None or self.post is False else 16384) | (0 if self.from_id is None or self.from_id is False else 256) | (0 if self.fwd_from is None or self.fwd_from is False else 4) | (0 if self.via_bot_id is None or self.via_bot_id is False else 2048) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 8) | (0 if self.media is None or self.media is False else 512) | (0 if self.reply_markup is None or self.reply_markup is False else 64) | (0 if self.entities is None or self.entities is False else 128) | (0 if self.views is None or self.views is False else 1024) | (0 if self.edit_date is None or self.edit_date is False else 32768) | (0 if self.post_author is None or self.post_author is False else 65536) | (0 if self.grouped_id is None or self.grouped_id is False else 131072)),
            struct.pack('<i', self.id),
            b'' if self.from_id is None or self.from_id is False else (struct.pack('<i', self.from_id)),
            bytes(self.to_id),
            b'' if self.fwd_from is None or self.fwd_from is False else (bytes(self.fwd_from)),
            b'' if self.via_bot_id is None or self.via_bot_id is False else (struct.pack('<i', self.via_bot_id)),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            TLObject.serialize_datetime(self.date),
            TLObject.serialize_bytes(self.message),
            b'' if self.media is None or self.media is False else (bytes(self.media)),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.views is None or self.views is False else (struct.pack('<i', self.views)),
            b'' if self.edit_date is None or self.edit_date is False else (TLObject.serialize_datetime(self.edit_date)),
            b'' if self.post_author is None or self.post_author is False else (TLObject.serialize_bytes(self.post_author)),
            b'' if self.grouped_id is None or self.grouped_id is False else (struct.pack('<q', self.grouped_id)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _post = bool(flags & 16384)
        _id = reader.read_int()
        if flags & 256:
            _from_id = reader.read_int()
        else:
            _from_id = None
        _to_id = reader.tgread_object()
        if flags & 4:
            _fwd_from = reader.tgread_object()
        else:
            _fwd_from = None
        if flags & 2048:
            _via_bot_id = reader.read_int()
        else:
            _via_bot_id = None
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _date = reader.tgread_date()
        _message = reader.tgread_string()
        if flags & 512:
            _media = reader.tgread_object()
        else:
            _media = None
        if flags & 64:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 1024:
            _views = reader.read_int()
        else:
            _views = None
        if flags & 32768:
            _edit_date = reader.tgread_date()
        else:
            _edit_date = None
        if flags & 65536:
            _post_author = reader.tgread_string()
        else:
            _post_author = None
        if flags & 131072:
            _grouped_id = reader.read_long()
        else:
            _grouped_id = None
        return Message(id=_id, to_id=_to_id, date=_date, message=_message, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, post=_post, from_id=_from_id, fwd_from=_fwd_from, via_bot_id=_via_bot_id, reply_to_msg_id=_reply_to_msg_id, media=_media, reply_markup=_reply_markup, entities=_entities, views=_views, edit_date=_edit_date, post_author=_post_author, grouped_id=_grouped_id)


class MessageActionChannelCreate(TLObject):
    CONSTRUCTOR_ID = 0x95d2ac92
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title):
        """
        :param str title:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.title = title  # type: str

    def to_dict(self):
        return {
            '_': 'MessageActionChannelCreate',
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'\x92\xac\xd2\x95',
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _title = reader.tgread_string()
        return MessageActionChannelCreate(title=_title)


class MessageActionChannelMigrateFrom(TLObject):
    CONSTRUCTOR_ID = 0xb055eaee
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title, chat_id):
        """
        :param str title:
        :param int chat_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.title = title  # type: str
        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionChannelMigrateFrom',
            'title': self.title,
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xee\xeaU\xb0',
            TLObject.serialize_bytes(self.title),
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _title = reader.tgread_string()
        _chat_id = reader.read_int()
        return MessageActionChannelMigrateFrom(title=_title, chat_id=_chat_id)


class MessageActionChatAddUser(TLObject):
    CONSTRUCTOR_ID = 0x488a7337
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, users):
        """
        :param list[int] users:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.users = users  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MessageActionChatAddUser',
            'users': [] if self.users is None else self.users[:]
        }

    def __bytes__(self):
        return b''.join((
            b'7s\x8aH',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return MessageActionChatAddUser(users=_users)


class MessageActionChatCreate(TLObject):
    CONSTRUCTOR_ID = 0xa6638b9a
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title, users):
        """
        :param str title:
        :param list[int] users:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.title = title  # type: str
        self.users = users  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MessageActionChatCreate',
            'title': self.title,
            'users': [] if self.users is None else self.users[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x9a\x8bc\xa6',
            TLObject.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _title = reader.tgread_string()
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return MessageActionChatCreate(title=_title, users=_users)


class MessageActionChatDeletePhoto(TLObject):
    CONSTRUCTOR_ID = 0x95e3fbef
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'MessageActionChatDeletePhoto'
        }

    def __bytes__(self):
        return b''.join((
            b'\xef\xfb\xe3\x95',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionChatDeletePhoto()


class MessageActionChatDeleteUser(TLObject):
    CONSTRUCTOR_ID = 0xb2ae9b0c
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionChatDeleteUser',
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c\x9b\xae\xb2',
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        return MessageActionChatDeleteUser(user_id=_user_id)


class MessageActionChatEditPhoto(TLObject):
    CONSTRUCTOR_ID = 0x7fcb13a8
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, photo):
        """
        :param Photo photo:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.photo = photo  # type: TypePhoto

    def to_dict(self):
        return {
            '_': 'MessageActionChatEditPhoto',
            'photo': None if self.photo is None else self.photo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8\x13\xcb\x7f',
            bytes(self.photo),
        ))

    @staticmethod
    def from_reader(reader):
        _photo = reader.tgread_object()
        return MessageActionChatEditPhoto(photo=_photo)


class MessageActionChatEditTitle(TLObject):
    CONSTRUCTOR_ID = 0xb5a1ce5a
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title):
        """
        :param str title:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.title = title  # type: str

    def to_dict(self):
        return {
            '_': 'MessageActionChatEditTitle',
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'Z\xce\xa1\xb5',
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _title = reader.tgread_string()
        return MessageActionChatEditTitle(title=_title)


class MessageActionChatJoinedByLink(TLObject):
    CONSTRUCTOR_ID = 0xf89cf5e8
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, inviter_id):
        """
        :param int inviter_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.inviter_id = inviter_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionChatJoinedByLink',
            'inviter_id': self.inviter_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xe8\xf5\x9c\xf8',
            struct.pack('<i', self.inviter_id),
        ))

    @staticmethod
    def from_reader(reader):
        _inviter_id = reader.read_int()
        return MessageActionChatJoinedByLink(inviter_id=_inviter_id)


class MessageActionChatMigrateTo(TLObject):
    CONSTRUCTOR_ID = 0x51bdb021
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionChatMigrateTo',
            'channel_id': self.channel_id
        }

    def __bytes__(self):
        return b''.join((
            b'!\xb0\xbdQ',
            struct.pack('<i', self.channel_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        return MessageActionChatMigrateTo(channel_id=_channel_id)


class MessageActionCustomAction(TLObject):
    CONSTRUCTOR_ID = 0xfae69f56
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, message):
        """
        :param str message:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.message = message  # type: str

    def to_dict(self):
        return {
            '_': 'MessageActionCustomAction',
            'message': self.message
        }

    def __bytes__(self):
        return b''.join((
            b'V\x9f\xe6\xfa',
            TLObject.serialize_bytes(self.message),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_string()
        return MessageActionCustomAction(message=_message)


class MessageActionEmpty(TLObject):
    CONSTRUCTOR_ID = 0xb6aef7b0
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'MessageActionEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xb0\xf7\xae\xb6',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionEmpty()


class MessageActionGameScore(TLObject):
    CONSTRUCTOR_ID = 0x92a72876
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, game_id, score):
        """
        :param int game_id:
        :param int score:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.game_id = game_id  # type: int
        self.score = score  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionGameScore',
            'game_id': self.game_id,
            'score': self.score
        }

    def __bytes__(self):
        return b''.join((
            b'v(\xa7\x92',
            struct.pack('<q', self.game_id),
            struct.pack('<i', self.score),
        ))

    @staticmethod
    def from_reader(reader):
        _game_id = reader.read_long()
        _score = reader.read_int()
        return MessageActionGameScore(game_id=_game_id, score=_score)


class MessageActionHistoryClear(TLObject):
    CONSTRUCTOR_ID = 0x9fbab604
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'MessageActionHistoryClear'
        }

    def __bytes__(self):
        return b''.join((
            b'\x04\xb6\xba\x9f',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionHistoryClear()


class MessageActionPaymentSent(TLObject):
    CONSTRUCTOR_ID = 0x40699cd0
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, currency, total_amount):
        """
        :param str currency:
        :param int total_amount:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.currency = currency  # type: str
        self.total_amount = total_amount  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionPaymentSent',
            'currency': self.currency,
            'total_amount': self.total_amount
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\x9ci@',
            TLObject.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
        ))

    @staticmethod
    def from_reader(reader):
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        return MessageActionPaymentSent(currency=_currency, total_amount=_total_amount)


class MessageActionPaymentSentMe(TLObject):
    CONSTRUCTOR_ID = 0x8f31b327
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, currency, total_amount, payload, charge, info=None, shipping_option_id=None):
        """
        :param str currency:
        :param int total_amount:
        :param bytes payload:
        :param PaymentRequestedInfo | None info:
        :param str | None shipping_option_id:
        :param PaymentCharge charge:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.currency = currency  # type: str
        self.total_amount = total_amount  # type: int
        self.payload = payload  # type: bytes
        self.info = info  # type: Optional[TypePaymentRequestedInfo]
        self.shipping_option_id = shipping_option_id  # type: Optional[str]
        self.charge = charge  # type: TypePaymentCharge

    def to_dict(self):
        return {
            '_': 'MessageActionPaymentSentMe',
            'currency': self.currency,
            'total_amount': self.total_amount,
            'payload': self.payload,
            'info': None if self.info is None else self.info.to_dict(),
            'shipping_option_id': self.shipping_option_id,
            'charge': None if self.charge is None else self.charge.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b"'\xb31\x8f",
            struct.pack('<I', (0 if self.info is None or self.info is False else 1) | (0 if self.shipping_option_id is None or self.shipping_option_id is False else 2)),
            TLObject.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
            TLObject.serialize_bytes(self.payload),
            b'' if self.info is None or self.info is False else (bytes(self.info)),
            b'' if self.shipping_option_id is None or self.shipping_option_id is False else (TLObject.serialize_bytes(self.shipping_option_id)),
            bytes(self.charge),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        _payload = reader.tgread_bytes()
        if flags & 1:
            _info = reader.tgread_object()
        else:
            _info = None
        if flags & 2:
            _shipping_option_id = reader.tgread_string()
        else:
            _shipping_option_id = None
        _charge = reader.tgread_object()
        return MessageActionPaymentSentMe(currency=_currency, total_amount=_total_amount, payload=_payload, charge=_charge, info=_info, shipping_option_id=_shipping_option_id)


class MessageActionPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x80e11a7f
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, call_id, reason=None, duration=None):
        """
        :param int call_id:
        :param PhoneCallDiscardReason | None reason:
        :param int | None duration:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction.
        """
        super().__init__()

        self.call_id = call_id  # type: int
        self.reason = reason  # type: Optional[TypePhoneCallDiscardReason]
        self.duration = duration  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageActionPhoneCall',
            'call_id': self.call_id,
            'reason': None if self.reason is None else self.reason.to_dict(),
            'duration': self.duration
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\x1a\xe1\x80',
            struct.pack('<I', (0 if self.reason is None or self.reason is False else 1) | (0 if self.duration is None or self.duration is False else 2)),
            struct.pack('<q', self.call_id),
            b'' if self.reason is None or self.reason is False else (bytes(self.reason)),
            b'' if self.duration is None or self.duration is False else (struct.pack('<i', self.duration)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _call_id = reader.read_long()
        if flags & 1:
            _reason = reader.tgread_object()
        else:
            _reason = None
        if flags & 2:
            _duration = reader.read_int()
        else:
            _duration = None
        return MessageActionPhoneCall(call_id=_call_id, reason=_reason, duration=_duration)


class MessageActionPinMessage(TLObject):
    CONSTRUCTOR_ID = 0x94bd38ed
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'MessageActionPinMessage'
        }

    def __bytes__(self):
        return b''.join((
            b'\xed8\xbd\x94',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionPinMessage()


class MessageActionScreenshotTaken(TLObject):
    CONSTRUCTOR_ID = 0x4792929b
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'MessageActionScreenshotTaken'
        }

    def __bytes__(self):
        return b''.join((
            b'\x9b\x92\x92G',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageActionScreenshotTaken()


class MessageEmpty(TLObject):
    CONSTRUCTOR_ID = 0x83e5de54
    SUBCLASS_OF_ID = 0x790009e3

    def __init__(self, id):
        """
        :param int id:

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'T\xde\xe5\x83',
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return MessageEmpty(id=_id)


class MessageEntityBold(TLObject):
    CONSTRUCTOR_ID = 0xbd610bc9
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityBold',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\x0ba\xbd',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityBold(offset=_offset, length=_length)


class MessageEntityBotCommand(TLObject):
    CONSTRUCTOR_ID = 0x6cef8ac7
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityBotCommand',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\x8a\xefl',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityBotCommand(offset=_offset, length=_length)


class MessageEntityCode(TLObject):
    CONSTRUCTOR_ID = 0x28a20571
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityCode',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'q\x05\xa2(',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityCode(offset=_offset, length=_length)


class MessageEntityEmail(TLObject):
    CONSTRUCTOR_ID = 0x64e475c2
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityEmail',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\xc2u\xe4d',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityEmail(offset=_offset, length=_length)


class MessageEntityHashtag(TLObject):
    CONSTRUCTOR_ID = 0x6f635b0d
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityHashtag',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\r[co',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityHashtag(offset=_offset, length=_length)


class MessageEntityItalic(TLObject):
    CONSTRUCTOR_ID = 0x826f8b60
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityItalic',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'`\x8bo\x82',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityItalic(offset=_offset, length=_length)


class MessageEntityMention(TLObject):
    CONSTRUCTOR_ID = 0xfa04579d
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityMention',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\x9dW\x04\xfa',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityMention(offset=_offset, length=_length)


class MessageEntityMentionName(TLObject):
    CONSTRUCTOR_ID = 0x352dca58
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, user_id):
        """
        :param int offset:
        :param int length:
        :param int user_id:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityMentionName',
            'offset': self.offset,
            'length': self.length,
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'X\xca-5',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _user_id = reader.read_int()
        return MessageEntityMentionName(offset=_offset, length=_length, user_id=_user_id)


class MessageEntityPre(TLObject):
    CONSTRUCTOR_ID = 0x73924be0
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, language):
        """
        :param int offset:
        :param int length:
        :param str language:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int
        self.language = language  # type: str

    def to_dict(self):
        return {
            '_': 'MessageEntityPre',
            'offset': self.offset,
            'length': self.length,
            'language': self.language
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0K\x92s',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            TLObject.serialize_bytes(self.language),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _language = reader.tgread_string()
        return MessageEntityPre(offset=_offset, length=_length, language=_language)


class MessageEntityTextUrl(TLObject):
    CONSTRUCTOR_ID = 0x76a6d327
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, url):
        """
        :param int offset:
        :param int length:
        :param str url:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int
        self.url = url  # type: str

    def to_dict(self):
        return {
            '_': 'MessageEntityTextUrl',
            'offset': self.offset,
            'length': self.length,
            'url': self.url
        }

    def __bytes__(self):
        return b''.join((
            b"'\xd3\xa6v",
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            TLObject.serialize_bytes(self.url),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _url = reader.tgread_string()
        return MessageEntityTextUrl(offset=_offset, length=_length, url=_url)


class MessageEntityUnknown(TLObject):
    CONSTRUCTOR_ID = 0xbb92ba95
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityUnknown',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xba\x92\xbb',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityUnknown(offset=_offset, length=_length)


class MessageEntityUrl(TLObject):
    CONSTRUCTOR_ID = 0x6ed02538
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName.
        """
        super().__init__()

        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityUrl',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'8%\xd0n',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @staticmethod
    def from_reader(reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return MessageEntityUrl(offset=_offset, length=_length)


class MessageFwdHeader(TLObject):
    CONSTRUCTOR_ID = 0x559ebe6d
    SUBCLASS_OF_ID = 0x7a286804

    def __init__(self, date, from_id=None, channel_id=None, channel_post=None, post_author=None, saved_from_peer=None, saved_from_msg_id=None):
        """
        :param int | None from_id:
        :param datetime.datetime | None date:
        :param int | None channel_id:
        :param int | None channel_post:
        :param str | None post_author:
        :param Peer | None saved_from_peer:
        :param int | None saved_from_msg_id:

        Constructor for MessageFwdHeader: Instance of MessageFwdHeader.
        """
        super().__init__()

        self.from_id = from_id  # type: Optional[int]
        self.date = date  # type: Optional[datetime]
        self.channel_id = channel_id  # type: Optional[int]
        self.channel_post = channel_post  # type: Optional[int]
        self.post_author = post_author  # type: Optional[str]
        self.saved_from_peer = saved_from_peer  # type: Optional[TypePeer]
        self.saved_from_msg_id = saved_from_msg_id  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageFwdHeader',
            'from_id': self.from_id,
            'date': self.date,
            'channel_id': self.channel_id,
            'channel_post': self.channel_post,
            'post_author': self.post_author,
            'saved_from_peer': None if self.saved_from_peer is None else self.saved_from_peer.to_dict(),
            'saved_from_msg_id': self.saved_from_msg_id
        }

    def __bytes__(self):
        assert ((self.saved_from_peer or self.saved_from_peer is not None) and (self.saved_from_msg_id or self.saved_from_msg_id is not None)) or ((self.saved_from_peer is None or self.saved_from_peer is False) and (self.saved_from_msg_id is None or self.saved_from_msg_id is False)), 'saved_from_peer, saved_from_msg_id parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'm\xbe\x9eU',
            struct.pack('<I', (0 if self.from_id is None or self.from_id is False else 1) | (0 if self.channel_id is None or self.channel_id is False else 2) | (0 if self.channel_post is None or self.channel_post is False else 4) | (0 if self.post_author is None or self.post_author is False else 8) | (0 if self.saved_from_peer is None or self.saved_from_peer is False else 16) | (0 if self.saved_from_msg_id is None or self.saved_from_msg_id is False else 16)),
            b'' if self.from_id is None or self.from_id is False else (struct.pack('<i', self.from_id)),
            TLObject.serialize_datetime(self.date),
            b'' if self.channel_id is None or self.channel_id is False else (struct.pack('<i', self.channel_id)),
            b'' if self.channel_post is None or self.channel_post is False else (struct.pack('<i', self.channel_post)),
            b'' if self.post_author is None or self.post_author is False else (TLObject.serialize_bytes(self.post_author)),
            b'' if self.saved_from_peer is None or self.saved_from_peer is False else (bytes(self.saved_from_peer)),
            b'' if self.saved_from_msg_id is None or self.saved_from_msg_id is False else (struct.pack('<i', self.saved_from_msg_id)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            _from_id = reader.read_int()
        else:
            _from_id = None
        _date = reader.tgread_date()
        if flags & 2:
            _channel_id = reader.read_int()
        else:
            _channel_id = None
        if flags & 4:
            _channel_post = reader.read_int()
        else:
            _channel_post = None
        if flags & 8:
            _post_author = reader.tgread_string()
        else:
            _post_author = None
        if flags & 16:
            _saved_from_peer = reader.tgread_object()
        else:
            _saved_from_peer = None
        if flags & 16:
            _saved_from_msg_id = reader.read_int()
        else:
            _saved_from_msg_id = None
        return MessageFwdHeader(date=_date, from_id=_from_id, channel_id=_channel_id, channel_post=_channel_post, post_author=_post_author, saved_from_peer=_saved_from_peer, saved_from_msg_id=_saved_from_msg_id)


class MessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0x5e7d2f39
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, phone_number, first_name, last_name, user_id):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param int user_id:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.phone_number = phone_number  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageMediaContact',
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'9/}^',
            TLObject.serialize_bytes(self.phone_number),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _user_id = reader.read_int()
        return MessageMediaContact(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, user_id=_user_id)


class MessageMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x9cb070d7
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, document=None, ttl_seconds=None):
        """
        :param Document | None document:
        :param int | None ttl_seconds:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.document = document  # type: Optional[TypeDocument]
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageMediaDocument',
            'document': None if self.document is None else self.document.to_dict(),
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7p\xb0\x9c',
            struct.pack('<I', (0 if self.document is None or self.document is False else 1) | (0 if self.ttl_seconds is None or self.ttl_seconds is False else 4)),
            b'' if self.document is None or self.document is False else (bytes(self.document)),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 4:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return MessageMediaDocument(document=_document, ttl_seconds=_ttl_seconds)


class MessageMediaEmpty(TLObject):
    CONSTRUCTOR_ID = 0x3ded6320
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'MessageMediaEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b' c\xed=',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageMediaEmpty()


class MessageMediaGame(TLObject):
    CONSTRUCTOR_ID = 0xfdb19008
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, game):
        """
        :param Game game:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.game = game  # type: TypeGame

    def to_dict(self):
        return {
            '_': 'MessageMediaGame',
            'game': None if self.game is None else self.game.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\x90\xb1\xfd',
            bytes(self.game),
        ))

    @staticmethod
    def from_reader(reader):
        _game = reader.tgread_object()
        return MessageMediaGame(game=_game)


class MessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0x56e0d474
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, geo):
        """
        :param GeoPoint geo:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.geo = geo  # type: TypeGeoPoint

    def to_dict(self):
        return {
            '_': 'MessageMediaGeo',
            'geo': None if self.geo is None else self.geo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b't\xd4\xe0V',
            bytes(self.geo),
        ))

    @staticmethod
    def from_reader(reader):
        _geo = reader.tgread_object()
        return MessageMediaGeo(geo=_geo)


class MessageMediaGeoLive(TLObject):
    CONSTRUCTOR_ID = 0x7c3c2609
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, geo, period):
        """
        :param GeoPoint geo:
        :param int period:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.geo = geo  # type: TypeGeoPoint
        self.period = period  # type: int

    def to_dict(self):
        return {
            '_': 'MessageMediaGeoLive',
            'geo': None if self.geo is None else self.geo.to_dict(),
            'period': self.period
        }

    def __bytes__(self):
        return b''.join((
            b'\t&<|',
            bytes(self.geo),
            struct.pack('<i', self.period),
        ))

    @staticmethod
    def from_reader(reader):
        _geo = reader.tgread_object()
        _period = reader.read_int()
        return MessageMediaGeoLive(geo=_geo, period=_period)


class MessageMediaInvoice(TLObject):
    CONSTRUCTOR_ID = 0x84551347
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, title, description, currency, total_amount, start_param, shipping_address_requested=None, test=None, photo=None, receipt_msg_id=None):
        """
        :param bool | None shipping_address_requested:
        :param bool | None test:
        :param str title:
        :param str description:
        :param WebDocument | None photo:
        :param int | None receipt_msg_id:
        :param str currency:
        :param int total_amount:
        :param str start_param:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.shipping_address_requested = shipping_address_requested  # type: Optional[bool]
        self.test = test  # type: Optional[bool]
        self.title = title  # type: str
        self.description = description  # type: str
        self.photo = photo  # type: Optional[TypeWebDocument]
        self.receipt_msg_id = receipt_msg_id  # type: Optional[int]
        self.currency = currency  # type: str
        self.total_amount = total_amount  # type: int
        self.start_param = start_param  # type: str

    def to_dict(self):
        return {
            '_': 'MessageMediaInvoice',
            'shipping_address_requested': self.shipping_address_requested,
            'test': self.test,
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'receipt_msg_id': self.receipt_msg_id,
            'currency': self.currency,
            'total_amount': self.total_amount,
            'start_param': self.start_param
        }

    def __bytes__(self):
        return b''.join((
            b'G\x13U\x84',
            struct.pack('<I', (0 if self.shipping_address_requested is None or self.shipping_address_requested is False else 2) | (0 if self.test is None or self.test is False else 8) | (0 if self.photo is None or self.photo is False else 1) | (0 if self.receipt_msg_id is None or self.receipt_msg_id is False else 4)),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.description),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.receipt_msg_id is None or self.receipt_msg_id is False else (struct.pack('<i', self.receipt_msg_id)),
            TLObject.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
            TLObject.serialize_bytes(self.start_param),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _shipping_address_requested = bool(flags & 2)
        _test = bool(flags & 8)
        _title = reader.tgread_string()
        _description = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 4:
            _receipt_msg_id = reader.read_int()
        else:
            _receipt_msg_id = None
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        _start_param = reader.tgread_string()
        return MessageMediaInvoice(title=_title, description=_description, currency=_currency, total_amount=_total_amount, start_param=_start_param, shipping_address_requested=_shipping_address_requested, test=_test, photo=_photo, receipt_msg_id=_receipt_msg_id)


class MessageMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0x695150d7
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, photo=None, ttl_seconds=None):
        """
        :param Photo | None photo:
        :param int | None ttl_seconds:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.photo = photo  # type: Optional[TypePhoto]
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageMediaPhoto',
            'photo': None if self.photo is None else self.photo.to_dict(),
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7PQi',
            struct.pack('<I', (0 if self.photo is None or self.photo is False else 1) | (0 if self.ttl_seconds is None or self.ttl_seconds is False else 4)),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 4:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return MessageMediaPhoto(photo=_photo, ttl_seconds=_ttl_seconds)


class MessageMediaUnsupported(TLObject):
    CONSTRUCTOR_ID = 0x9f84f49e
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'MessageMediaUnsupported'
        }

    def __bytes__(self):
        return b''.join((
            b'\x9e\xf4\x84\x9f',
        ))

    @staticmethod
    def from_reader(reader):
        return MessageMediaUnsupported()


class MessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0x2ec0533f
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, geo, title, address, provider, venue_id, venue_type):
        """
        :param GeoPoint geo:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param str venue_type:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.geo = geo  # type: TypeGeoPoint
        self.title = title  # type: str
        self.address = address  # type: str
        self.provider = provider  # type: str
        self.venue_id = venue_id  # type: str
        self.venue_type = venue_type  # type: str

    def to_dict(self):
        return {
            '_': 'MessageMediaVenue',
            'geo': None if self.geo is None else self.geo.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'venue_type': self.venue_type
        }

    def __bytes__(self):
        return b''.join((
            b'?S\xc0.',
            bytes(self.geo),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.address),
            TLObject.serialize_bytes(self.provider),
            TLObject.serialize_bytes(self.venue_id),
            TLObject.serialize_bytes(self.venue_type),
        ))

    @staticmethod
    def from_reader(reader):
        _geo = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        _venue_type = reader.tgread_string()
        return MessageMediaVenue(geo=_geo, title=_title, address=_address, provider=_provider, venue_id=_venue_id, venue_type=_venue_type)


class MessageMediaWebPage(TLObject):
    CONSTRUCTOR_ID = 0xa32dd600
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, webpage):
        """
        :param WebPage webpage:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        super().__init__()

        self.webpage = webpage  # type: TypeWebPage

    def to_dict(self):
        return {
            '_': 'MessageMediaWebPage',
            'webpage': None if self.webpage is None else self.webpage.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\xd6-\xa3',
            bytes(self.webpage),
        ))

    @staticmethod
    def from_reader(reader):
        _webpage = reader.tgread_object()
        return MessageMediaWebPage(webpage=_webpage)


class MessageRange(TLObject):
    CONSTRUCTOR_ID = 0xae30253
    SUBCLASS_OF_ID = 0xbec74577

    def __init__(self, min_id, max_id):
        """
        :param int min_id:
        :param int max_id:

        Constructor for MessageRange: Instance of MessageRange.
        """
        super().__init__()

        self.min_id = min_id  # type: int
        self.max_id = max_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageRange',
            'min_id': self.min_id,
            'max_id': self.max_id
        }

    def __bytes__(self):
        return b''.join((
            b'S\x02\xe3\n',
            struct.pack('<i', self.min_id),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _min_id = reader.read_int()
        _max_id = reader.read_int()
        return MessageRange(min_id=_min_id, max_id=_max_id)


class MessageService(TLObject):
    CONSTRUCTOR_ID = 0x9e19a1f6
    SUBCLASS_OF_ID = 0x790009e3

    def __init__(self, id, to_id, date, action, out=None, mentioned=None, media_unread=None, silent=None, post=None, from_id=None, reply_to_msg_id=None):
        """
        :param bool | None out:
        :param bool | None mentioned:
        :param bool | None media_unread:
        :param bool | None silent:
        :param bool | None post:
        :param int id:
        :param int | None from_id:
        :param Peer to_id:
        :param int | None reply_to_msg_id:
        :param datetime.datetime | None date:
        :param MessageAction action:

        Constructor for Message: Instance of either MessageEmpty, Message, MessageService.
        """
        super().__init__()

        self.out = out  # type: Optional[bool]
        self.mentioned = mentioned  # type: Optional[bool]
        self.media_unread = media_unread  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.post = post  # type: Optional[bool]
        self.id = id  # type: int
        self.from_id = from_id  # type: Optional[int]
        self.to_id = to_id  # type: TypePeer
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.date = date  # type: Optional[datetime]
        self.action = action  # type: TypeMessageAction

    def to_dict(self):
        return {
            '_': 'MessageService',
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'post': self.post,
            'id': self.id,
            'from_id': self.from_id,
            'to_id': None if self.to_id is None else self.to_id.to_dict(),
            'reply_to_msg_id': self.reply_to_msg_id,
            'date': self.date,
            'action': None if self.action is None else self.action.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xa1\x19\x9e',
            struct.pack('<I', (0 if self.out is None or self.out is False else 2) | (0 if self.mentioned is None or self.mentioned is False else 16) | (0 if self.media_unread is None or self.media_unread is False else 32) | (0 if self.silent is None or self.silent is False else 8192) | (0 if self.post is None or self.post is False else 16384) | (0 if self.from_id is None or self.from_id is False else 256) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 8)),
            struct.pack('<i', self.id),
            b'' if self.from_id is None or self.from_id is False else (struct.pack('<i', self.from_id)),
            bytes(self.to_id),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            TLObject.serialize_datetime(self.date),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _post = bool(flags & 16384)
        _id = reader.read_int()
        if flags & 256:
            _from_id = reader.read_int()
        else:
            _from_id = None
        _to_id = reader.tgread_object()
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _date = reader.tgread_date()
        _action = reader.tgread_object()
        return MessageService(id=_id, to_id=_to_id, date=_date, action=_action, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, post=_post, from_id=_from_id, reply_to_msg_id=_reply_to_msg_id)


class MsgDetailedInfo(TLObject):
    CONSTRUCTOR_ID = 0x276d3ec6
    SUBCLASS_OF_ID = 0x5f32d5ee

    def __init__(self, msg_id, answer_msg_id, bytes, status):
        """
        :param int msg_id:
        :param int answer_msg_id:
        :param int bytes:
        :param int status:

        Constructor for MsgDetailedInfo: Instance of either MsgDetailedInfo, MsgNewDetailedInfo.
        """
        super().__init__()

        self.msg_id = msg_id  # type: int
        self.answer_msg_id = answer_msg_id  # type: int
        self.bytes = bytes  # type: int
        self.status = status  # type: int

    def to_dict(self):
        return {
            '_': 'MsgDetailedInfo',
            'msg_id': self.msg_id,
            'answer_msg_id': self.answer_msg_id,
            'bytes': self.bytes,
            'status': self.status
        }

    def __bytes__(self):
        return b''.join((
            b"\xc6>m'",
            struct.pack('<q', self.msg_id),
            struct.pack('<q', self.answer_msg_id),
            struct.pack('<i', self.bytes),
            struct.pack('<i', self.status),
        ))

    @staticmethod
    def from_reader(reader):
        _msg_id = reader.read_long()
        _answer_msg_id = reader.read_long()
        _bytes = reader.read_int()
        _status = reader.read_int()
        return MsgDetailedInfo(msg_id=_msg_id, answer_msg_id=_answer_msg_id, bytes=_bytes, status=_status)


class MsgNewDetailedInfo(TLObject):
    CONSTRUCTOR_ID = 0x809db6df
    SUBCLASS_OF_ID = 0x5f32d5ee

    def __init__(self, answer_msg_id, bytes, status):
        """
        :param int answer_msg_id:
        :param int bytes:
        :param int status:

        Constructor for MsgDetailedInfo: Instance of either MsgDetailedInfo, MsgNewDetailedInfo.
        """
        super().__init__()

        self.answer_msg_id = answer_msg_id  # type: int
        self.bytes = bytes  # type: int
        self.status = status  # type: int

    def to_dict(self):
        return {
            '_': 'MsgNewDetailedInfo',
            'answer_msg_id': self.answer_msg_id,
            'bytes': self.bytes,
            'status': self.status
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf\xb6\x9d\x80',
            struct.pack('<q', self.answer_msg_id),
            struct.pack('<i', self.bytes),
            struct.pack('<i', self.status),
        ))

    @staticmethod
    def from_reader(reader):
        _answer_msg_id = reader.read_long()
        _bytes = reader.read_int()
        _status = reader.read_int()
        return MsgNewDetailedInfo(answer_msg_id=_answer_msg_id, bytes=_bytes, status=_status)


class MsgResendReq(TLObject):
    CONSTRUCTOR_ID = 0x7d861a08
    SUBCLASS_OF_ID = 0x2024514

    def __init__(self, msg_ids):
        """
        :param list[int] msg_ids:

        Constructor for MsgResendReq: Instance of MsgResendReq.
        """
        super().__init__()

        self.msg_ids = msg_ids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MsgResendReq',
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\x1a\x86}',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return MsgResendReq(msg_ids=_msg_ids)


class MsgsAck(TLObject):
    CONSTRUCTOR_ID = 0x62d6b459
    SUBCLASS_OF_ID = 0x827677c4

    def __init__(self, msg_ids):
        """
        :param list[int] msg_ids:

        Constructor for MsgsAck: Instance of MsgsAck.
        """
        super().__init__()

        self.msg_ids = msg_ids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MsgsAck',
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'Y\xb4\xd6b',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return MsgsAck(msg_ids=_msg_ids)


class MsgsAllInfo(TLObject):
    CONSTRUCTOR_ID = 0x8cc0d131
    SUBCLASS_OF_ID = 0xfa8fcb54

    def __init__(self, msg_ids, info):
        """
        :param list[int] msg_ids:
        :param str info:

        Constructor for MsgsAllInfo: Instance of MsgsAllInfo.
        """
        super().__init__()

        self.msg_ids = msg_ids  # type: List[int]
        self.info = info  # type: str

    def to_dict(self):
        return {
            '_': 'MsgsAllInfo',
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
            'info': self.info
        }

    def __bytes__(self):
        return b''.join((
            b'1\xd1\xc0\x8c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
            TLObject.serialize_bytes(self.info),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        _info = reader.tgread_string()
        return MsgsAllInfo(msg_ids=_msg_ids, info=_info)


class MsgsStateInfo(TLObject):
    CONSTRUCTOR_ID = 0x4deb57d
    SUBCLASS_OF_ID = 0x70a0a64

    def __init__(self, req_msg_id, info):
        """
        :param int req_msg_id:
        :param str info:

        Constructor for MsgsStateInfo: Instance of MsgsStateInfo.
        """
        super().__init__()

        self.req_msg_id = req_msg_id  # type: int
        self.info = info  # type: str

    def to_dict(self):
        return {
            '_': 'MsgsStateInfo',
            'req_msg_id': self.req_msg_id,
            'info': self.info
        }

    def __bytes__(self):
        return b''.join((
            b'}\xb5\xde\x04',
            struct.pack('<q', self.req_msg_id),
            TLObject.serialize_bytes(self.info),
        ))

    @staticmethod
    def from_reader(reader):
        _req_msg_id = reader.read_long()
        _info = reader.tgread_string()
        return MsgsStateInfo(req_msg_id=_req_msg_id, info=_info)


class MsgsStateReq(TLObject):
    CONSTRUCTOR_ID = 0xda69fb52
    SUBCLASS_OF_ID = 0x18f01dd0

    def __init__(self, msg_ids):
        """
        :param list[int] msg_ids:

        Constructor for MsgsStateReq: Instance of MsgsStateReq.
        """
        super().__init__()

        self.msg_ids = msg_ids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MsgsStateReq',
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'R\xfbi\xda',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return MsgsStateReq(msg_ids=_msg_ids)


class NearestDc(TLObject):
    CONSTRUCTOR_ID = 0x8e1a1775
    SUBCLASS_OF_ID = 0x3877045f

    def __init__(self, country, this_dc, nearest_dc):
        """
        :param str country:
        :param int this_dc:
        :param int nearest_dc:

        Constructor for NearestDc: Instance of NearestDc.
        """
        super().__init__()

        self.country = country  # type: str
        self.this_dc = this_dc  # type: int
        self.nearest_dc = nearest_dc  # type: int

    def to_dict(self):
        return {
            '_': 'NearestDc',
            'country': self.country,
            'this_dc': self.this_dc,
            'nearest_dc': self.nearest_dc
        }

    def __bytes__(self):
        return b''.join((
            b'u\x17\x1a\x8e',
            TLObject.serialize_bytes(self.country),
            struct.pack('<i', self.this_dc),
            struct.pack('<i', self.nearest_dc),
        ))

    @staticmethod
    def from_reader(reader):
        _country = reader.tgread_string()
        _this_dc = reader.read_int()
        _nearest_dc = reader.read_int()
        return NearestDc(country=_country, this_dc=_this_dc, nearest_dc=_nearest_dc)


class NewSessionCreated(TLObject):
    CONSTRUCTOR_ID = 0x9ec20908
    SUBCLASS_OF_ID = 0x510d3031

    def __init__(self, first_msg_id, unique_id, server_salt):
        """
        :param int first_msg_id:
        :param int unique_id:
        :param int server_salt:

        Constructor for NewSession: Instance of NewSessionCreated.
        """
        super().__init__()

        self.first_msg_id = first_msg_id  # type: int
        self.unique_id = unique_id  # type: int
        self.server_salt = server_salt  # type: int

    def to_dict(self):
        return {
            '_': 'NewSessionCreated',
            'first_msg_id': self.first_msg_id,
            'unique_id': self.unique_id,
            'server_salt': self.server_salt
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\t\xc2\x9e',
            struct.pack('<q', self.first_msg_id),
            struct.pack('<q', self.unique_id),
            struct.pack('<q', self.server_salt),
        ))

    @staticmethod
    def from_reader(reader):
        _first_msg_id = reader.read_long()
        _unique_id = reader.read_long()
        _server_salt = reader.read_long()
        return NewSessionCreated(first_msg_id=_first_msg_id, unique_id=_unique_id, server_salt=_server_salt)


class NotifyAll(TLObject):
    CONSTRUCTOR_ID = 0x74d07c60
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'NotifyAll'
        }

    def __bytes__(self):
        return b''.join((
            b'`|\xd0t',
        ))

    @staticmethod
    def from_reader(reader):
        return NotifyAll()


class NotifyChats(TLObject):
    CONSTRUCTOR_ID = 0xc007cec3
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'NotifyChats'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\xce\x07\xc0',
        ))

    @staticmethod
    def from_reader(reader):
        return NotifyChats()


class NotifyPeer(TLObject):
    CONSTRUCTOR_ID = 0x9fd40bd8
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self, peer):
        """
        :param Peer peer:

        Constructor for NotifyPeer: Instance of either NotifyPeer, NotifyUsers, NotifyChats, NotifyAll.
        """
        super().__init__()

        self.peer = peer  # type: TypePeer

    def to_dict(self):
        return {
            '_': 'NotifyPeer',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8\x0b\xd4\x9f',
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        return NotifyPeer(peer=_peer)


class NotifyUsers(TLObject):
    CONSTRUCTOR_ID = 0xb4c83b4c
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'NotifyUsers'
        }

    def __bytes__(self):
        return b''.join((
            b'L;\xc8\xb4',
        ))

    @staticmethod
    def from_reader(reader):
        return NotifyUsers()


class Null(TLObject):
    CONSTRUCTOR_ID = 0x56730bcc
    SUBCLASS_OF_ID = 0x85f95371

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'Null'
        }

    def __bytes__(self):
        return b''.join((
            b'\xcc\x0bsV',
        ))

    @staticmethod
    def from_reader(reader):
        return Null()


class PQInnerData(TLObject):
    CONSTRUCTOR_ID = 0x83c95aec
    SUBCLASS_OF_ID = 0x41701377

    def __init__(self, pq, p, q, nonce, server_nonce, new_nonce):
        """
        :param bytes pq:
        :param bytes p:
        :param bytes q:
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce:

        Constructor for P_Q_inner_data: Instance of PQInnerData.
        """
        super().__init__()

        self.pq = pq  # type: bytes
        self.p = p  # type: bytes
        self.q = q  # type: bytes
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce = new_nonce  # type: int

    def to_dict(self):
        return {
            '_': 'PQInnerData',
            'pq': self.pq,
            'p': self.p,
            'q': self.q,
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce': self.new_nonce
        }

    def __bytes__(self):
        return b''.join((
            b'\xecZ\xc9\x83',
            TLObject.serialize_bytes(self.pq),
            TLObject.serialize_bytes(self.p),
            TLObject.serialize_bytes(self.q),
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce.to_bytes(32, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _pq = reader.tgread_bytes()
        _p = reader.tgread_bytes()
        _q = reader.tgread_bytes()
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce = reader.read_large_int(bits=256)
        return PQInnerData(pq=_pq, p=_p, q=_q, nonce=_nonce, server_nonce=_server_nonce, new_nonce=_new_nonce)


class PageBlockAnchor(TLObject):
    CONSTRUCTOR_ID = 0xce0d37b0
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, name):
        """
        :param str name:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.name = name  # type: str

    def to_dict(self):
        return {
            '_': 'PageBlockAnchor',
            'name': self.name
        }

    def __bytes__(self):
        return b''.join((
            b'\xb07\r\xce',
            TLObject.serialize_bytes(self.name),
        ))

    @staticmethod
    def from_reader(reader):
        _name = reader.tgread_string()
        return PageBlockAnchor(name=_name)


class PageBlockAudio(TLObject):
    CONSTRUCTOR_ID = 0x31b81a7f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, audio_id, caption):
        """
        :param int audio_id:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.audio_id = audio_id  # type: int
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockAudio',
            'audio_id': self.audio_id,
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\x1a\xb81',
            struct.pack('<q', self.audio_id),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _audio_id = reader.read_long()
        _caption = reader.tgread_object()
        return PageBlockAudio(audio_id=_audio_id, caption=_caption)


class PageBlockAuthorDate(TLObject):
    CONSTRUCTOR_ID = 0xbaafe5e0
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, author, published_date):
        """
        :param RichText author:
        :param datetime.datetime | None published_date:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.author = author  # type: TypeRichText
        self.published_date = published_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'PageBlockAuthorDate',
            'author': None if self.author is None else self.author.to_dict(),
            'published_date': self.published_date
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0\xe5\xaf\xba',
            bytes(self.author),
            TLObject.serialize_datetime(self.published_date),
        ))

    @staticmethod
    def from_reader(reader):
        _author = reader.tgread_object()
        _published_date = reader.tgread_date()
        return PageBlockAuthorDate(author=_author, published_date=_published_date)


class PageBlockBlockquote(TLObject):
    CONSTRUCTOR_ID = 0x263d7c26
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, caption):
        """
        :param RichText text:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockBlockquote',
            'text': None if self.text is None else self.text.to_dict(),
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'&|=&',
            bytes(self.text),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _caption = reader.tgread_object()
        return PageBlockBlockquote(text=_text, caption=_caption)


class PageBlockChannel(TLObject):
    CONSTRUCTOR_ID = 0xef1751b5
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, channel):
        """
        :param Chat channel:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.channel = channel  # type: TypeChat

    def to_dict(self):
        return {
            '_': 'PageBlockChannel',
            'channel': None if self.channel is None else self.channel.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xb5Q\x17\xef',
            bytes(self.channel),
        ))

    @staticmethod
    def from_reader(reader):
        _channel = reader.tgread_object()
        return PageBlockChannel(channel=_channel)


class PageBlockCollage(TLObject):
    CONSTRUCTOR_ID = 0x8b31c4f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, items, caption):
        """
        :param list[PageBlock] items:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.items = items  # type: List[TypePageBlock]
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockCollage',
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items],
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'O\x1c\xb3\x08',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        _caption = reader.tgread_object()
        return PageBlockCollage(items=_items, caption=_caption)


class PageBlockCover(TLObject):
    CONSTRUCTOR_ID = 0x39f23300
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, cover):
        """
        :param PageBlock cover:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.cover = cover  # type: TypePageBlock

    def to_dict(self):
        return {
            '_': 'PageBlockCover',
            'cover': None if self.cover is None else self.cover.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x003\xf29',
            bytes(self.cover),
        ))

    @staticmethod
    def from_reader(reader):
        _cover = reader.tgread_object()
        return PageBlockCover(cover=_cover)


class PageBlockDivider(TLObject):
    CONSTRUCTOR_ID = 0xdb20b188
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PageBlockDivider'
        }

    def __bytes__(self):
        return b''.join((
            b'\x88\xb1 \xdb',
        ))

    @staticmethod
    def from_reader(reader):
        return PageBlockDivider()


class PageBlockEmbed(TLObject):
    CONSTRUCTOR_ID = 0xcde200d1
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, w, h, caption, full_width=None, allow_scrolling=None, url=None, html=None, poster_photo_id=None):
        """
        :param bool | None full_width:
        :param bool | None allow_scrolling:
        :param str | None url:
        :param str | None html:
        :param int | None poster_photo_id:
        :param int w:
        :param int h:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.full_width = full_width  # type: Optional[bool]
        self.allow_scrolling = allow_scrolling  # type: Optional[bool]
        self.url = url  # type: Optional[str]
        self.html = html  # type: Optional[str]
        self.poster_photo_id = poster_photo_id  # type: Optional[int]
        self.w = w  # type: int
        self.h = h  # type: int
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockEmbed',
            'full_width': self.full_width,
            'allow_scrolling': self.allow_scrolling,
            'url': self.url,
            'html': self.html,
            'poster_photo_id': self.poster_photo_id,
            'w': self.w,
            'h': self.h,
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1\x00\xe2\xcd',
            struct.pack('<I', (0 if self.full_width is None or self.full_width is False else 1) | (0 if self.allow_scrolling is None or self.allow_scrolling is False else 8) | (0 if self.url is None or self.url is False else 2) | (0 if self.html is None or self.html is False else 4) | (0 if self.poster_photo_id is None or self.poster_photo_id is False else 16)),
            b'' if self.url is None or self.url is False else (TLObject.serialize_bytes(self.url)),
            b'' if self.html is None or self.html is False else (TLObject.serialize_bytes(self.html)),
            b'' if self.poster_photo_id is None or self.poster_photo_id is False else (struct.pack('<q', self.poster_photo_id)),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _full_width = bool(flags & 1)
        _allow_scrolling = bool(flags & 8)
        if flags & 2:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 4:
            _html = reader.tgread_string()
        else:
            _html = None
        if flags & 16:
            _poster_photo_id = reader.read_long()
        else:
            _poster_photo_id = None
        _w = reader.read_int()
        _h = reader.read_int()
        _caption = reader.tgread_object()
        return PageBlockEmbed(w=_w, h=_h, caption=_caption, full_width=_full_width, allow_scrolling=_allow_scrolling, url=_url, html=_html, poster_photo_id=_poster_photo_id)


class PageBlockEmbedPost(TLObject):
    CONSTRUCTOR_ID = 0x292c7be9
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, url, webpage_id, author_photo_id, author, date, blocks, caption):
        """
        :param str url:
        :param int webpage_id:
        :param int author_photo_id:
        :param str author:
        :param datetime.datetime | None date:
        :param list[PageBlock] blocks:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.url = url  # type: str
        self.webpage_id = webpage_id  # type: int
        self.author_photo_id = author_photo_id  # type: int
        self.author = author  # type: str
        self.date = date  # type: Optional[datetime]
        self.blocks = blocks  # type: List[TypePageBlock]
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockEmbedPost',
            'url': self.url,
            'webpage_id': self.webpage_id,
            'author_photo_id': self.author_photo_id,
            'author': self.author,
            'date': self.date,
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe9{,)',
            TLObject.serialize_bytes(self.url),
            struct.pack('<q', self.webpage_id),
            struct.pack('<q', self.author_photo_id),
            TLObject.serialize_bytes(self.author),
            TLObject.serialize_datetime(self.date),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _webpage_id = reader.read_long()
        _author_photo_id = reader.read_long()
        _author = reader.tgread_string()
        _date = reader.tgread_date()
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        _caption = reader.tgread_object()
        return PageBlockEmbedPost(url=_url, webpage_id=_webpage_id, author_photo_id=_author_photo_id, author=_author, date=_date, blocks=_blocks, caption=_caption)


class PageBlockFooter(TLObject):
    CONSTRUCTOR_ID = 0x48870999
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockFooter',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\t\x87H',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockFooter(text=_text)


class PageBlockHeader(TLObject):
    CONSTRUCTOR_ID = 0xbfd064ec
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockHeader',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xecd\xd0\xbf',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockHeader(text=_text)


class PageBlockList(TLObject):
    CONSTRUCTOR_ID = 0x3a58c7f4
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, ordered, items):
        """
        :param Bool ordered:
        :param list[RichText] items:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.ordered = ordered  # type: TypeBool
        self.items = items  # type: List[TypeRichText]

    def to_dict(self):
        return {
            '_': 'PageBlockList',
            'ordered': self.ordered,
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items]
        }

    def __bytes__(self):
        return b''.join((
            b'\xf4\xc7X:',
            b'\xb5ur\x99' if self.ordered else b'7\x97y\xbc',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
        ))

    @staticmethod
    def from_reader(reader):
        _ordered = reader.tgread_bool()
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        return PageBlockList(ordered=_ordered, items=_items)


class PageBlockParagraph(TLObject):
    CONSTRUCTOR_ID = 0x467a0766
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockParagraph',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'f\x07zF',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockParagraph(text=_text)


class PageBlockPhoto(TLObject):
    CONSTRUCTOR_ID = 0xe9c69982
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, photo_id, caption):
        """
        :param int photo_id:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.photo_id = photo_id  # type: int
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockPhoto',
            'photo_id': self.photo_id,
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x82\x99\xc6\xe9',
            struct.pack('<q', self.photo_id),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _photo_id = reader.read_long()
        _caption = reader.tgread_object()
        return PageBlockPhoto(photo_id=_photo_id, caption=_caption)


class PageBlockPreformatted(TLObject):
    CONSTRUCTOR_ID = 0xc070d93e
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, language):
        """
        :param RichText text:
        :param str language:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText
        self.language = language  # type: str

    def to_dict(self):
        return {
            '_': 'PageBlockPreformatted',
            'text': None if self.text is None else self.text.to_dict(),
            'language': self.language
        }

    def __bytes__(self):
        return b''.join((
            b'>\xd9p\xc0',
            bytes(self.text),
            TLObject.serialize_bytes(self.language),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _language = reader.tgread_string()
        return PageBlockPreformatted(text=_text, language=_language)


class PageBlockPullquote(TLObject):
    CONSTRUCTOR_ID = 0x4f4456d3
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, caption):
        """
        :param RichText text:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockPullquote',
            'text': None if self.text is None else self.text.to_dict(),
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3VDO',
            bytes(self.text),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _caption = reader.tgread_object()
        return PageBlockPullquote(text=_text, caption=_caption)


class PageBlockSlideshow(TLObject):
    CONSTRUCTOR_ID = 0x130c8963
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, items, caption):
        """
        :param list[PageBlock] items:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.items = items  # type: List[TypePageBlock]
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockSlideshow',
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items],
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'c\x89\x0c\x13',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        _caption = reader.tgread_object()
        return PageBlockSlideshow(items=_items, caption=_caption)


class PageBlockSubheader(TLObject):
    CONSTRUCTOR_ID = 0xf12bb6e1
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockSubheader',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xb6+\xf1',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockSubheader(text=_text)


class PageBlockSubtitle(TLObject):
    CONSTRUCTOR_ID = 0x8ffa9a1f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockSubtitle',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\x9a\xfa\x8f',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockSubtitle(text=_text)


class PageBlockTitle(TLObject):
    CONSTRUCTOR_ID = 0x70abc3fd
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockTitle',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\xc3\xabp',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return PageBlockTitle(text=_text)


class PageBlockUnsupported(TLObject):
    CONSTRUCTOR_ID = 0x13567e8a
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PageBlockUnsupported'
        }

    def __bytes__(self):
        return b''.join((
            b'\x8a~V\x13',
        ))

    @staticmethod
    def from_reader(reader):
        return PageBlockUnsupported()


class PageBlockVideo(TLObject):
    CONSTRUCTOR_ID = 0xd9d71866
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, video_id, caption, autoplay=None, loop=None):
        """
        :param bool | None autoplay:
        :param bool | None loop:
        :param int video_id:
        :param RichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        super().__init__()

        self.autoplay = autoplay  # type: Optional[bool]
        self.loop = loop  # type: Optional[bool]
        self.video_id = video_id  # type: int
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockVideo',
            'autoplay': self.autoplay,
            'loop': self.loop,
            'video_id': self.video_id,
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'f\x18\xd7\xd9',
            struct.pack('<I', (0 if self.autoplay is None or self.autoplay is False else 1) | (0 if self.loop is None or self.loop is False else 2)),
            struct.pack('<q', self.video_id),
            bytes(self.caption),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _autoplay = bool(flags & 1)
        _loop = bool(flags & 2)
        _video_id = reader.read_long()
        _caption = reader.tgread_object()
        return PageBlockVideo(video_id=_video_id, caption=_caption, autoplay=_autoplay, loop=_loop)


class PageFull(TLObject):
    CONSTRUCTOR_ID = 0x556ec7aa
    SUBCLASS_OF_ID = 0xb438191e

    def __init__(self, blocks, photos, documents):
        """
        :param list[PageBlock] blocks:
        :param list[Photo] photos:
        :param list[Document] documents:

        Constructor for Page: Instance of either PagePart, PageFull.
        """
        super().__init__()

        self.blocks = blocks  # type: List[TypePageBlock]
        self.photos = photos  # type: List[TypePhoto]
        self.documents = documents  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'PageFull',
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'photos': [] if self.photos is None else [None if x is None else x.to_dict() for x in self.photos],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]
        }

    def __bytes__(self):
        return b''.join((
            b'\xaa\xc7nU',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.photos)),b''.join(bytes(x) for x in self.photos),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        reader.read_int()
        _photos = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _photos.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return PageFull(blocks=_blocks, photos=_photos, documents=_documents)


class PagePart(TLObject):
    CONSTRUCTOR_ID = 0x8e3f9ebe
    SUBCLASS_OF_ID = 0xb438191e

    def __init__(self, blocks, photos, documents):
        """
        :param list[PageBlock] blocks:
        :param list[Photo] photos:
        :param list[Document] documents:

        Constructor for Page: Instance of either PagePart, PageFull.
        """
        super().__init__()

        self.blocks = blocks  # type: List[TypePageBlock]
        self.photos = photos  # type: List[TypePhoto]
        self.documents = documents  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'PagePart',
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'photos': [] if self.photos is None else [None if x is None else x.to_dict() for x in self.photos],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]
        }

    def __bytes__(self):
        return b''.join((
            b'\xbe\x9e?\x8e',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.photos)),b''.join(bytes(x) for x in self.photos),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        reader.read_int()
        _photos = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _photos.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return PagePart(blocks=_blocks, photos=_photos, documents=_documents)


class PaymentCharge(TLObject):
    CONSTRUCTOR_ID = 0xea02c27e
    SUBCLASS_OF_ID = 0x3cc830d9

    def __init__(self, id, provider_charge_id):
        """
        :param str id:
        :param str provider_charge_id:

        Constructor for PaymentCharge: Instance of PaymentCharge.
        """
        super().__init__()

        self.id = id  # type: str
        self.provider_charge_id = provider_charge_id  # type: str

    def to_dict(self):
        return {
            '_': 'PaymentCharge',
            'id': self.id,
            'provider_charge_id': self.provider_charge_id
        }

    def __bytes__(self):
        return b''.join((
            b'~\xc2\x02\xea',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.provider_charge_id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _provider_charge_id = reader.tgread_string()
        return PaymentCharge(id=_id, provider_charge_id=_provider_charge_id)


class PaymentRequestedInfo(TLObject):
    CONSTRUCTOR_ID = 0x909c3f94
    SUBCLASS_OF_ID = 0x8db03146

    def __init__(self, name=None, phone=None, email=None, shipping_address=None):
        """
        :param str | None name:
        :param str | None phone:
        :param str | None email:
        :param PostAddress | None shipping_address:

        Constructor for PaymentRequestedInfo: Instance of PaymentRequestedInfo.
        """
        super().__init__()

        self.name = name  # type: Optional[str]
        self.phone = phone  # type: Optional[str]
        self.email = email  # type: Optional[str]
        self.shipping_address = shipping_address  # type: Optional[TypePostAddress]

    def to_dict(self):
        return {
            '_': 'PaymentRequestedInfo',
            'name': self.name,
            'phone': self.phone,
            'email': self.email,
            'shipping_address': None if self.shipping_address is None else self.shipping_address.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x94?\x9c\x90',
            struct.pack('<I', (0 if self.name is None or self.name is False else 1) | (0 if self.phone is None or self.phone is False else 2) | (0 if self.email is None or self.email is False else 4) | (0 if self.shipping_address is None or self.shipping_address is False else 8)),
            b'' if self.name is None or self.name is False else (TLObject.serialize_bytes(self.name)),
            b'' if self.phone is None or self.phone is False else (TLObject.serialize_bytes(self.phone)),
            b'' if self.email is None or self.email is False else (TLObject.serialize_bytes(self.email)),
            b'' if self.shipping_address is None or self.shipping_address is False else (bytes(self.shipping_address)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            _name = reader.tgread_string()
        else:
            _name = None
        if flags & 2:
            _phone = reader.tgread_string()
        else:
            _phone = None
        if flags & 4:
            _email = reader.tgread_string()
        else:
            _email = None
        if flags & 8:
            _shipping_address = reader.tgread_object()
        else:
            _shipping_address = None
        return PaymentRequestedInfo(name=_name, phone=_phone, email=_email, shipping_address=_shipping_address)


class PaymentSavedCredentialsCard(TLObject):
    CONSTRUCTOR_ID = 0xcdc27a1f
    SUBCLASS_OF_ID = 0xb3627ee3

    def __init__(self, id, title):
        """
        :param str id:
        :param str title:

        Constructor for PaymentSavedCredentials: Instance of PaymentSavedCredentialsCard.
        """
        super().__init__()

        self.id = id  # type: str
        self.title = title  # type: str

    def to_dict(self):
        return {
            '_': 'PaymentSavedCredentialsCard',
            'id': self.id,
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'\x1fz\xc2\xcd',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.title),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _title = reader.tgread_string()
        return PaymentSavedCredentialsCard(id=_id, title=_title)


class PeerChannel(TLObject):
    CONSTRUCTOR_ID = 0xbddde532
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int

    def to_dict(self):
        return {
            '_': 'PeerChannel',
            'channel_id': self.channel_id
        }

    def __bytes__(self):
        return b''.join((
            b'2\xe5\xdd\xbd',
            struct.pack('<i', self.channel_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        return PeerChannel(channel_id=_channel_id)


class PeerChat(TLObject):
    CONSTRUCTOR_ID = 0xbad0e5bb
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'PeerChat',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\xe5\xd0\xba',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return PeerChat(chat_id=_chat_id)


class PeerNotifyEventsAll(TLObject):
    CONSTRUCTOR_ID = 0x6d1ded88
    SUBCLASS_OF_ID = 0x180c8bc4

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PeerNotifyEventsAll'
        }

    def __bytes__(self):
        return b''.join((
            b'\x88\xed\x1dm',
        ))

    @staticmethod
    def from_reader(reader):
        return PeerNotifyEventsAll()


class PeerNotifyEventsEmpty(TLObject):
    CONSTRUCTOR_ID = 0xadd53cb3
    SUBCLASS_OF_ID = 0x180c8bc4

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PeerNotifyEventsEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xb3<\xd5\xad',
        ))

    @staticmethod
    def from_reader(reader):
        return PeerNotifyEventsEmpty()


class PeerNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0x9acda4c0
    SUBCLASS_OF_ID = 0xcf20c074

    def __init__(self, mute_until, sound, show_previews=None, silent=None):
        """
        :param bool | None show_previews:
        :param bool | None silent:
        :param int mute_until:
        :param str sound:

        Constructor for PeerNotifySettings: Instance of either PeerNotifySettingsEmpty, PeerNotifySettings.
        """
        super().__init__()

        self.show_previews = show_previews  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.mute_until = mute_until  # type: int
        self.sound = sound  # type: str

    def to_dict(self):
        return {
            '_': 'PeerNotifySettings',
            'show_previews': self.show_previews,
            'silent': self.silent,
            'mute_until': self.mute_until,
            'sound': self.sound
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0\xa4\xcd\x9a',
            struct.pack('<I', (0 if self.show_previews is None or self.show_previews is False else 1) | (0 if self.silent is None or self.silent is False else 2)),
            struct.pack('<i', self.mute_until),
            TLObject.serialize_bytes(self.sound),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _show_previews = bool(flags & 1)
        _silent = bool(flags & 2)
        _mute_until = reader.read_int()
        _sound = reader.tgread_string()
        return PeerNotifySettings(mute_until=_mute_until, sound=_sound, show_previews=_show_previews, silent=_silent)


class PeerNotifySettingsEmpty(TLObject):
    CONSTRUCTOR_ID = 0x70a68512
    SUBCLASS_OF_ID = 0xcf20c074

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PeerNotifySettingsEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x12\x85\xa6p',
        ))

    @staticmethod
    def from_reader(reader):
        return PeerNotifySettingsEmpty()


class PeerSettings(TLObject):
    CONSTRUCTOR_ID = 0x818426cd
    SUBCLASS_OF_ID = 0xf6a79f84

    def __init__(self, report_spam=None):
        """
        :param bool | None report_spam:

        Constructor for PeerSettings: Instance of PeerSettings.
        """
        super().__init__()

        self.report_spam = report_spam  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'PeerSettings',
            'report_spam': self.report_spam
        }

    def __bytes__(self):
        return b''.join((
            b'\xcd&\x84\x81',
            struct.pack('<I', (0 if self.report_spam is None or self.report_spam is False else 1)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _report_spam = bool(flags & 1)
        return PeerSettings(report_spam=_report_spam)


class PeerUser(TLObject):
    CONSTRUCTOR_ID = 0x9db1bc6d
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        super().__init__()

        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'PeerUser',
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'm\xbc\xb1\x9d',
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        return PeerUser(user_id=_user_id)


class PhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xffe6ab67
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_or_b, key_fingerprint, protocol, connection, alternative_connections, start_date):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_or_b:
        :param int key_fingerprint:
        :param PhoneCallProtocol protocol:
        :param PhoneConnection connection:
        :param list[PhoneConnection] alternative_connections:
        :param datetime.datetime | None start_date:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_a_or_b = g_a_or_b  # type: bytes
        self.key_fingerprint = key_fingerprint  # type: int
        self.protocol = protocol  # type: TypePhoneCallProtocol
        self.connection = connection  # type: TypePhoneConnection
        self.alternative_connections = alternative_connections  # type: List[TypePhoneConnection]
        self.start_date = start_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'PhoneCall',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_or_b': self.g_a_or_b,
            'key_fingerprint': self.key_fingerprint,
            'protocol': None if self.protocol is None else self.protocol.to_dict(),
            'connection': None if self.connection is None else self.connection.to_dict(),
            'alternative_connections': [] if self.alternative_connections is None else [None if x is None else x.to_dict() for x in self.alternative_connections],
            'start_date': self.start_date
        }

    def __bytes__(self):
        return b''.join((
            b'g\xab\xe6\xff',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_a_or_b),
            struct.pack('<q', self.key_fingerprint),
            bytes(self.protocol),
            bytes(self.connection),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.alternative_connections)),b''.join(bytes(x) for x in self.alternative_connections),
            TLObject.serialize_datetime(self.start_date),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_or_b = reader.tgread_bytes()
        _key_fingerprint = reader.read_long()
        _protocol = reader.tgread_object()
        _connection = reader.tgread_object()
        reader.read_int()
        _alternative_connections = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _alternative_connections.append(_x)

        _start_date = reader.tgread_date()
        return PhoneCall(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_or_b=_g_a_or_b, key_fingerprint=_key_fingerprint, protocol=_protocol, connection=_connection, alternative_connections=_alternative_connections, start_date=_start_date)


class PhoneCallAccepted(TLObject):
    CONSTRUCTOR_ID = 0x6d003d3f
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_b, protocol):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_b:
        :param PhoneCallProtocol protocol:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_b = g_b  # type: bytes
        self.protocol = protocol  # type: TypePhoneCallProtocol

    def to_dict(self):
        return {
            '_': 'PhoneCallAccepted',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_b': self.g_b,
            'protocol': None if self.protocol is None else self.protocol.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'?=\x00m',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_b),
            bytes(self.protocol),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_b = reader.tgread_bytes()
        _protocol = reader.tgread_object()
        return PhoneCallAccepted(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_b=_g_b, protocol=_protocol)


class PhoneCallDiscardReasonBusy(TLObject):
    CONSTRUCTOR_ID = 0xfaf7e8c9
    SUBCLASS_OF_ID = 0xd89bad3d

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscardReasonBusy'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\xe8\xf7\xfa',
        ))

    @staticmethod
    def from_reader(reader):
        return PhoneCallDiscardReasonBusy()


class PhoneCallDiscardReasonDisconnect(TLObject):
    CONSTRUCTOR_ID = 0xe095c1a0
    SUBCLASS_OF_ID = 0xd89bad3d

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscardReasonDisconnect'
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc1\x95\xe0',
        ))

    @staticmethod
    def from_reader(reader):
        return PhoneCallDiscardReasonDisconnect()


class PhoneCallDiscardReasonHangup(TLObject):
    CONSTRUCTOR_ID = 0x57adc690
    SUBCLASS_OF_ID = 0xd89bad3d

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscardReasonHangup'
        }

    def __bytes__(self):
        return b''.join((
            b'\x90\xc6\xadW',
        ))

    @staticmethod
    def from_reader(reader):
        return PhoneCallDiscardReasonHangup()


class PhoneCallDiscardReasonMissed(TLObject):
    CONSTRUCTOR_ID = 0x85e42301
    SUBCLASS_OF_ID = 0xd89bad3d

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscardReasonMissed'
        }

    def __bytes__(self):
        return b''.join((
            b'\x01#\xe4\x85',
        ))

    @staticmethod
    def from_reader(reader):
        return PhoneCallDiscardReasonMissed()


class PhoneCallDiscarded(TLObject):
    CONSTRUCTOR_ID = 0x50ca4de1
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, need_rating=None, need_debug=None, reason=None, duration=None):
        """
        :param bool | None need_rating:
        :param bool | None need_debug:
        :param int id:
        :param PhoneCallDiscardReason | None reason:
        :param int | None duration:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.need_rating = need_rating  # type: Optional[bool]
        self.need_debug = need_debug  # type: Optional[bool]
        self.id = id  # type: int
        self.reason = reason  # type: Optional[TypePhoneCallDiscardReason]
        self.duration = duration  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscarded',
            'need_rating': self.need_rating,
            'need_debug': self.need_debug,
            'id': self.id,
            'reason': None if self.reason is None else self.reason.to_dict(),
            'duration': self.duration
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1M\xcaP',
            struct.pack('<I', (0 if self.need_rating is None or self.need_rating is False else 4) | (0 if self.need_debug is None or self.need_debug is False else 8) | (0 if self.reason is None or self.reason is False else 1) | (0 if self.duration is None or self.duration is False else 2)),
            struct.pack('<q', self.id),
            b'' if self.reason is None or self.reason is False else (bytes(self.reason)),
            b'' if self.duration is None or self.duration is False else (struct.pack('<i', self.duration)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _need_rating = bool(flags & 4)
        _need_debug = bool(flags & 8)
        _id = reader.read_long()
        if flags & 1:
            _reason = reader.tgread_object()
        else:
            _reason = None
        if flags & 2:
            _duration = reader.read_int()
        else:
            _duration = None
        return PhoneCallDiscarded(id=_id, need_rating=_need_rating, need_debug=_need_debug, reason=_reason, duration=_duration)


class PhoneCallEmpty(TLObject):
    CONSTRUCTOR_ID = 0x5366c915
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id):
        """
        :param int id:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'PhoneCallEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\x15\xc9fS',
            struct.pack('<q', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        return PhoneCallEmpty(id=_id)


class PhoneCallProtocol(TLObject):
    CONSTRUCTOR_ID = 0xa2bb35cb
    SUBCLASS_OF_ID = 0x783991a3

    def __init__(self, min_layer, max_layer, udp_p2p=None, udp_reflector=None):
        """
        :param bool | None udp_p2p:
        :param bool | None udp_reflector:
        :param int min_layer:
        :param int max_layer:

        Constructor for PhoneCallProtocol: Instance of PhoneCallProtocol.
        """
        super().__init__()

        self.udp_p2p = udp_p2p  # type: Optional[bool]
        self.udp_reflector = udp_reflector  # type: Optional[bool]
        self.min_layer = min_layer  # type: int
        self.max_layer = max_layer  # type: int

    def to_dict(self):
        return {
            '_': 'PhoneCallProtocol',
            'udp_p2p': self.udp_p2p,
            'udp_reflector': self.udp_reflector,
            'min_layer': self.min_layer,
            'max_layer': self.max_layer
        }

    def __bytes__(self):
        return b''.join((
            b'\xcb5\xbb\xa2',
            struct.pack('<I', (0 if self.udp_p2p is None or self.udp_p2p is False else 1) | (0 if self.udp_reflector is None or self.udp_reflector is False else 2)),
            struct.pack('<i', self.min_layer),
            struct.pack('<i', self.max_layer),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _udp_p2p = bool(flags & 1)
        _udp_reflector = bool(flags & 2)
        _min_layer = reader.read_int()
        _max_layer = reader.read_int()
        return PhoneCallProtocol(min_layer=_min_layer, max_layer=_max_layer, udp_p2p=_udp_p2p, udp_reflector=_udp_reflector)


class PhoneCallRequested(TLObject):
    CONSTRUCTOR_ID = 0x83761ce4
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_hash, protocol):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_hash:
        :param PhoneCallProtocol protocol:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_a_hash = g_a_hash  # type: bytes
        self.protocol = protocol  # type: TypePhoneCallProtocol

    def to_dict(self):
        return {
            '_': 'PhoneCallRequested',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_hash': self.g_a_hash,
            'protocol': None if self.protocol is None else self.protocol.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4\x1cv\x83',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            TLObject.serialize_bytes(self.g_a_hash),
            bytes(self.protocol),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_hash = reader.tgread_bytes()
        _protocol = reader.tgread_object()
        return PhoneCallRequested(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_hash=_g_a_hash, protocol=_protocol)


class PhoneCallWaiting(TLObject):
    CONSTRUCTOR_ID = 0x1b8f4ad1
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, protocol, receive_date=None):
        """
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param int admin_id:
        :param int participant_id:
        :param PhoneCallProtocol protocol:
        :param datetime.datetime | None receive_date:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        super().__init__()

        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.protocol = protocol  # type: TypePhoneCallProtocol
        self.receive_date = receive_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'PhoneCallWaiting',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'protocol': None if self.protocol is None else self.protocol.to_dict(),
            'receive_date': self.receive_date
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1J\x8f\x1b',
            struct.pack('<I', (0 if self.receive_date is None or self.receive_date is False else 1)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            bytes(self.protocol),
            b'' if self.receive_date is None or self.receive_date is False else (TLObject.serialize_datetime(self.receive_date)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _protocol = reader.tgread_object()
        if flags & 1:
            _receive_date = reader.tgread_date()
        else:
            _receive_date = None
        return PhoneCallWaiting(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, protocol=_protocol, receive_date=_receive_date)


class PhoneConnection(TLObject):
    CONSTRUCTOR_ID = 0x9d4c17c0
    SUBCLASS_OF_ID = 0xaa8de40d

    def __init__(self, id, ip, ipv6, port, peer_tag):
        """
        :param int id:
        :param str ip:
        :param str ipv6:
        :param int port:
        :param bytes peer_tag:

        Constructor for PhoneConnection: Instance of PhoneConnection.
        """
        super().__init__()

        self.id = id  # type: int
        self.ip = ip  # type: str
        self.ipv6 = ipv6  # type: str
        self.port = port  # type: int
        self.peer_tag = peer_tag  # type: bytes

    def to_dict(self):
        return {
            '_': 'PhoneConnection',
            'id': self.id,
            'ip': self.ip,
            'ipv6': self.ipv6,
            'port': self.port,
            'peer_tag': self.peer_tag
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0\x17L\x9d',
            struct.pack('<q', self.id),
            TLObject.serialize_bytes(self.ip),
            TLObject.serialize_bytes(self.ipv6),
            struct.pack('<i', self.port),
            TLObject.serialize_bytes(self.peer_tag),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _ip = reader.tgread_string()
        _ipv6 = reader.tgread_string()
        _port = reader.read_int()
        _peer_tag = reader.tgread_bytes()
        return PhoneConnection(id=_id, ip=_ip, ipv6=_ipv6, port=_port, peer_tag=_peer_tag)


class Photo(TLObject):
    CONSTRUCTOR_ID = 0x9288dd29
    SUBCLASS_OF_ID = 0xd576ab1c

    def __init__(self, id, access_hash, date, sizes, has_stickers=None):
        """
        :param bool | None has_stickers:
        :param int id:
        :param int access_hash:
        :param datetime.datetime | None date:
        :param list[PhotoSize] sizes:

        Constructor for Photo: Instance of either PhotoEmpty, Photo.
        """
        super().__init__()

        self.has_stickers = has_stickers  # type: Optional[bool]
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.sizes = sizes  # type: List[TypePhotoSize]

    def to_dict(self):
        return {
            '_': 'Photo',
            'has_stickers': self.has_stickers,
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'sizes': [] if self.sizes is None else [None if x is None else x.to_dict() for x in self.sizes]
        }

    def __bytes__(self):
        return b''.join((
            b')\xdd\x88\x92',
            struct.pack('<I', (0 if self.has_stickers is None or self.has_stickers is False else 1)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_datetime(self.date),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sizes)),b''.join(bytes(x) for x in self.sizes),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _has_stickers = bool(flags & 1)
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        reader.read_int()
        _sizes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sizes.append(_x)

        return Photo(id=_id, access_hash=_access_hash, date=_date, sizes=_sizes, has_stickers=_has_stickers)


class PhotoCachedSize(TLObject):
    CONSTRUCTOR_ID = 0xe9a734fa
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type, location, w, h, bytes):
        """
        :param str type:
        :param FileLocation location:
        :param int w:
        :param int h:
        :param bytes bytes:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type  # type: str
        self.location = location  # type: TypeFileLocation
        self.w = w  # type: int
        self.h = h  # type: int
        self.bytes = bytes  # type: bytes

    def to_dict(self):
        return {
            '_': 'PhotoCachedSize',
            'type': self.type,
            'location': None if self.location is None else self.location.to_dict(),
            'w': self.w,
            'h': self.h,
            'bytes': self.bytes
        }

    def __bytes__(self):
        return b''.join((
            b'\xfa4\xa7\xe9',
            TLObject.serialize_bytes(self.type),
            bytes(self.location),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            TLObject.serialize_bytes(self.bytes),
        ))

    @staticmethod
    def from_reader(reader):
        _type = reader.tgread_string()
        _location = reader.tgread_object()
        _w = reader.read_int()
        _h = reader.read_int()
        _bytes = reader.tgread_bytes()
        return PhotoCachedSize(type=_type, location=_location, w=_w, h=_h, bytes=_bytes)


class PhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x2331b22d
    SUBCLASS_OF_ID = 0xd576ab1c

    def __init__(self, id):
        """
        :param int id:

        Constructor for Photo: Instance of either PhotoEmpty, Photo.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'PhotoEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'-\xb21#',
            struct.pack('<q', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        return PhotoEmpty(id=_id)


class PhotoSize(TLObject):
    CONSTRUCTOR_ID = 0x77bfb61b
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type, location, w, h, size):
        """
        :param str type:
        :param FileLocation location:
        :param int w:
        :param int h:
        :param int size:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type  # type: str
        self.location = location  # type: TypeFileLocation
        self.w = w  # type: int
        self.h = h  # type: int
        self.size = size  # type: int

    def to_dict(self):
        return {
            '_': 'PhotoSize',
            'type': self.type,
            'location': None if self.location is None else self.location.to_dict(),
            'w': self.w,
            'h': self.h,
            'size': self.size
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b\xb6\xbfw',
            TLObject.serialize_bytes(self.type),
            bytes(self.location),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            struct.pack('<i', self.size),
        ))

    @staticmethod
    def from_reader(reader):
        _type = reader.tgread_string()
        _location = reader.tgread_object()
        _w = reader.read_int()
        _h = reader.read_int()
        _size = reader.read_int()
        return PhotoSize(type=_type, location=_location, w=_w, h=_h, size=_size)


class PhotoSizeEmpty(TLObject):
    CONSTRUCTOR_ID = 0xe17e23c
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type):
        """
        :param str type:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        super().__init__()

        self.type = type  # type: str

    def to_dict(self):
        return {
            '_': 'PhotoSizeEmpty',
            'type': self.type
        }

    def __bytes__(self):
        return b''.join((
            b'<\xe2\x17\x0e',
            TLObject.serialize_bytes(self.type),
        ))

    @staticmethod
    def from_reader(reader):
        _type = reader.tgread_string()
        return PhotoSizeEmpty(type=_type)


class Pong(TLObject):
    CONSTRUCTOR_ID = 0x347773c5
    SUBCLASS_OF_ID = 0x816aee71

    def __init__(self, msg_id, ping_id):
        """
        :param int msg_id:
        :param int ping_id:

        Constructor for Pong: Instance of Pong.
        """
        super().__init__()

        self.msg_id = msg_id  # type: int
        self.ping_id = ping_id  # type: int

    def to_dict(self):
        return {
            '_': 'Pong',
            'msg_id': self.msg_id,
            'ping_id': self.ping_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5sw4',
            struct.pack('<q', self.msg_id),
            struct.pack('<q', self.ping_id),
        ))

    @staticmethod
    def from_reader(reader):
        _msg_id = reader.read_long()
        _ping_id = reader.read_long()
        return Pong(msg_id=_msg_id, ping_id=_ping_id)


class PopularContact(TLObject):
    CONSTRUCTOR_ID = 0x5ce14175
    SUBCLASS_OF_ID = 0x409255a

    def __init__(self, client_id, importers):
        """
        :param int client_id:
        :param int importers:

        Constructor for PopularContact: Instance of PopularContact.
        """
        super().__init__()

        self.client_id = client_id  # type: int
        self.importers = importers  # type: int

    def to_dict(self):
        return {
            '_': 'PopularContact',
            'client_id': self.client_id,
            'importers': self.importers
        }

    def __bytes__(self):
        return b''.join((
            b'uA\xe1\\',
            struct.pack('<q', self.client_id),
            struct.pack('<i', self.importers),
        ))

    @staticmethod
    def from_reader(reader):
        _client_id = reader.read_long()
        _importers = reader.read_int()
        return PopularContact(client_id=_client_id, importers=_importers)


class PostAddress(TLObject):
    CONSTRUCTOR_ID = 0x1e8caaeb
    SUBCLASS_OF_ID = 0x8d7eda2c

    def __init__(self, street_line1, street_line2, city, state, country_iso2, post_code):
        """
        :param str street_line1:
        :param str street_line2:
        :param str city:
        :param str state:
        :param str country_iso2:
        :param str post_code:

        Constructor for PostAddress: Instance of PostAddress.
        """
        super().__init__()

        self.street_line1 = street_line1  # type: str
        self.street_line2 = street_line2  # type: str
        self.city = city  # type: str
        self.state = state  # type: str
        self.country_iso2 = country_iso2  # type: str
        self.post_code = post_code  # type: str

    def to_dict(self):
        return {
            '_': 'PostAddress',
            'street_line1': self.street_line1,
            'street_line2': self.street_line2,
            'city': self.city,
            'state': self.state,
            'country_iso2': self.country_iso2,
            'post_code': self.post_code
        }

    def __bytes__(self):
        return b''.join((
            b'\xeb\xaa\x8c\x1e',
            TLObject.serialize_bytes(self.street_line1),
            TLObject.serialize_bytes(self.street_line2),
            TLObject.serialize_bytes(self.city),
            TLObject.serialize_bytes(self.state),
            TLObject.serialize_bytes(self.country_iso2),
            TLObject.serialize_bytes(self.post_code),
        ))

    @staticmethod
    def from_reader(reader):
        _street_line1 = reader.tgread_string()
        _street_line2 = reader.tgread_string()
        _city = reader.tgread_string()
        _state = reader.tgread_string()
        _country_iso2 = reader.tgread_string()
        _post_code = reader.tgread_string()
        return PostAddress(street_line1=_street_line1, street_line2=_street_line2, city=_city, state=_state, country_iso2=_country_iso2, post_code=_post_code)


class PrivacyKeyChatInvite(TLObject):
    CONSTRUCTOR_ID = 0x500e6dfa
    SUBCLASS_OF_ID = 0x824651c3

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PrivacyKeyChatInvite'
        }

    def __bytes__(self):
        return b''.join((
            b'\xfam\x0eP',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyKeyChatInvite()


class PrivacyKeyPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x3d662b7b
    SUBCLASS_OF_ID = 0x824651c3

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PrivacyKeyPhoneCall'
        }

    def __bytes__(self):
        return b''.join((
            b'{+f=',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyKeyPhoneCall()


class PrivacyKeyStatusTimestamp(TLObject):
    CONSTRUCTOR_ID = 0xbc2eab30
    SUBCLASS_OF_ID = 0x824651c3

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PrivacyKeyStatusTimestamp'
        }

    def __bytes__(self):
        return b''.join((
            b'0\xab.\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyKeyStatusTimestamp()


class PrivacyValueAllowAll(TLObject):
    CONSTRUCTOR_ID = 0x65427b82
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PrivacyValueAllowAll'
        }

    def __bytes__(self):
        return b''.join((
            b'\x82{Be',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyValueAllowAll()


class PrivacyValueAllowContacts(TLObject):
    CONSTRUCTOR_ID = 0xfffe1bac
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PrivacyValueAllowContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'\xac\x1b\xfe\xff',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyValueAllowContacts()


class PrivacyValueAllowUsers(TLObject):
    CONSTRUCTOR_ID = 0x4d5bbe0c
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self, users):
        """
        :param list[int] users:

        Constructor for PrivacyRule: Instance of either PrivacyValueAllowContacts, PrivacyValueAllowAll, PrivacyValueAllowUsers, PrivacyValueDisallowContacts, PrivacyValueDisallowAll, PrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users  # type: List[int]

    def to_dict(self):
        return {
            '_': 'PrivacyValueAllowUsers',
            'users': [] if self.users is None else self.users[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c\xbe[M',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return PrivacyValueAllowUsers(users=_users)


class PrivacyValueDisallowAll(TLObject):
    CONSTRUCTOR_ID = 0x8b73e763
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PrivacyValueDisallowAll'
        }

    def __bytes__(self):
        return b''.join((
            b'c\xe7s\x8b',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyValueDisallowAll()


class PrivacyValueDisallowContacts(TLObject):
    CONSTRUCTOR_ID = 0xf888fa1a
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'PrivacyValueDisallowContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1a\xfa\x88\xf8',
        ))

    @staticmethod
    def from_reader(reader):
        return PrivacyValueDisallowContacts()


class PrivacyValueDisallowUsers(TLObject):
    CONSTRUCTOR_ID = 0xc7f49b7
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self, users):
        """
        :param list[int] users:

        Constructor for PrivacyRule: Instance of either PrivacyValueAllowContacts, PrivacyValueAllowAll, PrivacyValueAllowUsers, PrivacyValueDisallowContacts, PrivacyValueDisallowAll, PrivacyValueDisallowUsers.
        """
        super().__init__()

        self.users = users  # type: List[int]

    def to_dict(self):
        return {
            '_': 'PrivacyValueDisallowUsers',
            'users': [] if self.users is None else self.users[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7I\x7f\x0c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return PrivacyValueDisallowUsers(users=_users)


class ReceivedNotifyMessage(TLObject):
    CONSTRUCTOR_ID = 0xa384b779
    SUBCLASS_OF_ID = 0xa962381e

    def __init__(self, id, flags):
        """
        :param int id:
        :param int flags:

        Constructor for ReceivedNotifyMessage: Instance of ReceivedNotifyMessage.
        """
        super().__init__()

        self.id = id  # type: int
        self.flags = flags  # type: int

    def to_dict(self):
        return {
            '_': 'ReceivedNotifyMessage',
            'id': self.id,
            'flags': self.flags
        }

    def __bytes__(self):
        return b''.join((
            b'y\xb7\x84\xa3',
            struct.pack('<i', self.id),
            struct.pack('<i', self.flags),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _flags = reader.read_int()
        return ReceivedNotifyMessage(id=_id, flags=_flags)


class RecentMeUrlChat(TLObject):
    CONSTRUCTOR_ID = 0xa01b22f9
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url, chat_id):
        """
        :param str url:
        :param int chat_id:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        super().__init__()

        self.url = url  # type: str
        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'RecentMeUrlChat',
            'url': self.url,
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xf9"\x1b\xa0',
            TLObject.serialize_bytes(self.url),
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _chat_id = reader.read_int()
        return RecentMeUrlChat(url=_url, chat_id=_chat_id)


class RecentMeUrlChatInvite(TLObject):
    CONSTRUCTOR_ID = 0xeb49081d
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url, chat_invite):
        """
        :param str url:
        :param ChatInvite chat_invite:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        super().__init__()

        self.url = url  # type: str
        self.chat_invite = chat_invite  # type: TypeChatInvite

    def to_dict(self):
        return {
            '_': 'RecentMeUrlChatInvite',
            'url': self.url,
            'chat_invite': None if self.chat_invite is None else self.chat_invite.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1d\x08I\xeb',
            TLObject.serialize_bytes(self.url),
            bytes(self.chat_invite),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _chat_invite = reader.tgread_object()
        return RecentMeUrlChatInvite(url=_url, chat_invite=_chat_invite)


class RecentMeUrlStickerSet(TLObject):
    CONSTRUCTOR_ID = 0xbc0a57dc
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url, set):
        """
        :param str url:
        :param StickerSetCovered set:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        super().__init__()

        self.url = url  # type: str
        self.set = set  # type: TypeStickerSetCovered

    def to_dict(self):
        return {
            '_': 'RecentMeUrlStickerSet',
            'url': self.url,
            'set': None if self.set is None else self.set.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xdcW\n\xbc',
            TLObject.serialize_bytes(self.url),
            bytes(self.set),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _set = reader.tgread_object()
        return RecentMeUrlStickerSet(url=_url, set=_set)


class RecentMeUrlUnknown(TLObject):
    CONSTRUCTOR_ID = 0x46e1d13d
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url):
        """
        :param str url:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        super().__init__()

        self.url = url  # type: str

    def to_dict(self):
        return {
            '_': 'RecentMeUrlUnknown',
            'url': self.url
        }

    def __bytes__(self):
        return b''.join((
            b'=\xd1\xe1F',
            TLObject.serialize_bytes(self.url),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        return RecentMeUrlUnknown(url=_url)


class RecentMeUrlUser(TLObject):
    CONSTRUCTOR_ID = 0x8dbc3336
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url, user_id):
        """
        :param str url:
        :param int user_id:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        super().__init__()

        self.url = url  # type: str
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'RecentMeUrlUser',
            'url': self.url,
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'63\xbc\x8d',
            TLObject.serialize_bytes(self.url),
            struct.pack('<i', self.user_id),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _user_id = reader.read_int()
        return RecentMeUrlUser(url=_url, user_id=_user_id)


class ReplyInlineMarkup(TLObject):
    CONSTRUCTOR_ID = 0x48a30254
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, rows):
        """
        :param list[KeyboardButtonRow] rows:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.rows = rows  # type: List[TypeKeyboardButtonRow]

    def to_dict(self):
        return {
            '_': 'ReplyInlineMarkup',
            'rows': [] if self.rows is None else [None if x is None else x.to_dict() for x in self.rows]
        }

    def __bytes__(self):
        return b''.join((
            b'T\x02\xa3H',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rows)),b''.join(bytes(x) for x in self.rows),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _rows = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rows.append(_x)

        return ReplyInlineMarkup(rows=_rows)


class ReplyKeyboardForceReply(TLObject):
    CONSTRUCTOR_ID = 0xf4108aa0
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, single_use=None, selective=None):
        """
        :param bool | None single_use:
        :param bool | None selective:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.single_use = single_use  # type: Optional[bool]
        self.selective = selective  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ReplyKeyboardForceReply',
            'single_use': self.single_use,
            'selective': self.selective
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\x8a\x10\xf4',
            struct.pack('<I', (0 if self.single_use is None or self.single_use is False else 2) | (0 if self.selective is None or self.selective is False else 4)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _single_use = bool(flags & 2)
        _selective = bool(flags & 4)
        return ReplyKeyboardForceReply(single_use=_single_use, selective=_selective)


class ReplyKeyboardHide(TLObject):
    CONSTRUCTOR_ID = 0xa03e5b85
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, selective=None):
        """
        :param bool | None selective:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.selective = selective  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ReplyKeyboardHide',
            'selective': self.selective
        }

    def __bytes__(self):
        return b''.join((
            b'\x85[>\xa0',
            struct.pack('<I', (0 if self.selective is None or self.selective is False else 4)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _selective = bool(flags & 4)
        return ReplyKeyboardHide(selective=_selective)


class ReplyKeyboardMarkup(TLObject):
    CONSTRUCTOR_ID = 0x3502758c
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, rows, resize=None, single_use=None, selective=None):
        """
        :param bool | None resize:
        :param bool | None single_use:
        :param bool | None selective:
        :param list[KeyboardButtonRow] rows:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        super().__init__()

        self.resize = resize  # type: Optional[bool]
        self.single_use = single_use  # type: Optional[bool]
        self.selective = selective  # type: Optional[bool]
        self.rows = rows  # type: List[TypeKeyboardButtonRow]

    def to_dict(self):
        return {
            '_': 'ReplyKeyboardMarkup',
            'resize': self.resize,
            'single_use': self.single_use,
            'selective': self.selective,
            'rows': [] if self.rows is None else [None if x is None else x.to_dict() for x in self.rows]
        }

    def __bytes__(self):
        return b''.join((
            b'\x8cu\x025',
            struct.pack('<I', (0 if self.resize is None or self.resize is False else 1) | (0 if self.single_use is None or self.single_use is False else 2) | (0 if self.selective is None or self.selective is False else 4)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rows)),b''.join(bytes(x) for x in self.rows),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _resize = bool(flags & 1)
        _single_use = bool(flags & 2)
        _selective = bool(flags & 4)
        reader.read_int()
        _rows = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rows.append(_x)

        return ReplyKeyboardMarkup(rows=_rows, resize=_resize, single_use=_single_use, selective=_selective)


class ResPQ(TLObject):
    CONSTRUCTOR_ID = 0x5162463
    SUBCLASS_OF_ID = 0x786986b8

    def __init__(self, nonce, server_nonce, pq, server_public_key_fingerprints):
        """
        :param int nonce:
        :param int server_nonce:
        :param bytes pq:
        :param list[int] server_public_key_fingerprints:

        Constructor for ResPQ: Instance of ResPQ.
        """
        super().__init__()

        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.pq = pq  # type: bytes
        self.server_public_key_fingerprints = server_public_key_fingerprints  # type: List[int]

    def to_dict(self):
        return {
            '_': 'ResPQ',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'pq': self.pq,
            'server_public_key_fingerprints': [] if self.server_public_key_fingerprints is None else self.server_public_key_fingerprints[:]
        }

    def __bytes__(self):
        return b''.join((
            b'c$\x16\x05',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            TLObject.serialize_bytes(self.pq),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.server_public_key_fingerprints)),b''.join(struct.pack('<q', x) for x in self.server_public_key_fingerprints),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _pq = reader.tgread_bytes()
        reader.read_int()
        _server_public_key_fingerprints = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _server_public_key_fingerprints.append(_x)

        return ResPQ(nonce=_nonce, server_nonce=_server_nonce, pq=_pq, server_public_key_fingerprints=_server_public_key_fingerprints)


class RpcAnswerDropped(TLObject):
    CONSTRUCTOR_ID = 0xa43ad8b7
    SUBCLASS_OF_ID = 0x4bca7570

    def __init__(self, msg_id, seq_no, bytes):
        """
        :param int msg_id:
        :param int seq_no:
        :param int bytes:

        Constructor for RpcDropAnswer: Instance of either RpcAnswerUnknown, RpcAnswerDroppedRunning, RpcAnswerDropped.
        """
        super().__init__()

        self.msg_id = msg_id  # type: int
        self.seq_no = seq_no  # type: int
        self.bytes = bytes  # type: int

    def to_dict(self):
        return {
            '_': 'RpcAnswerDropped',
            'msg_id': self.msg_id,
            'seq_no': self.seq_no,
            'bytes': self.bytes
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7\xd8:\xa4',
            struct.pack('<q', self.msg_id),
            struct.pack('<i', self.seq_no),
            struct.pack('<i', self.bytes),
        ))

    @staticmethod
    def from_reader(reader):
        _msg_id = reader.read_long()
        _seq_no = reader.read_int()
        _bytes = reader.read_int()
        return RpcAnswerDropped(msg_id=_msg_id, seq_no=_seq_no, bytes=_bytes)


class RpcAnswerDroppedRunning(TLObject):
    CONSTRUCTOR_ID = 0xcd78e586
    SUBCLASS_OF_ID = 0x4bca7570

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'RpcAnswerDroppedRunning'
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\xe5x\xcd',
        ))

    @staticmethod
    def from_reader(reader):
        return RpcAnswerDroppedRunning()


class RpcAnswerUnknown(TLObject):
    CONSTRUCTOR_ID = 0x5e2ad36e
    SUBCLASS_OF_ID = 0x4bca7570

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'RpcAnswerUnknown'
        }

    def __bytes__(self):
        return b''.join((
            b'n\xd3*^',
        ))

    @staticmethod
    def from_reader(reader):
        return RpcAnswerUnknown()


class RpcError(TLObject):
    CONSTRUCTOR_ID = 0x2144ca19
    SUBCLASS_OF_ID = 0x4a17e265

    def __init__(self, error_code, error_message):
        """
        :param int error_code:
        :param str error_message:

        Constructor for RpcError: Instance of RpcError.
        """
        super().__init__()

        self.error_code = error_code  # type: int
        self.error_message = error_message  # type: str

    def to_dict(self):
        return {
            '_': 'RpcError',
            'error_code': self.error_code,
            'error_message': self.error_message
        }

    def __bytes__(self):
        return b''.join((
            b'\x19\xcaD!',
            struct.pack('<i', self.error_code),
            TLObject.serialize_bytes(self.error_message),
        ))

    @staticmethod
    def from_reader(reader):
        _error_code = reader.read_int()
        _error_message = reader.tgread_string()
        return RpcError(error_code=_error_code, error_message=_error_message)


class SendMessageCancelAction(TLObject):
    CONSTRUCTOR_ID = 0xfd5ec8f5
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SendMessageCancelAction'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf5\xc8^\xfd',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageCancelAction()


class SendMessageChooseContactAction(TLObject):
    CONSTRUCTOR_ID = 0x628cbc6f
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SendMessageChooseContactAction'
        }

    def __bytes__(self):
        return b''.join((
            b'o\xbc\x8cb',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageChooseContactAction()


class SendMessageGamePlayAction(TLObject):
    CONSTRUCTOR_ID = 0xdd6a8f48
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SendMessageGamePlayAction'
        }

    def __bytes__(self):
        return b''.join((
            b'H\x8fj\xdd',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageGamePlayAction()


class SendMessageGeoLocationAction(TLObject):
    CONSTRUCTOR_ID = 0x176f8ba1
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SendMessageGeoLocationAction'
        }

    def __bytes__(self):
        return b''.join((
            b'\xa1\x8bo\x17',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageGeoLocationAction()


class SendMessageRecordAudioAction(TLObject):
    CONSTRUCTOR_ID = 0xd52f73f7
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SendMessageRecordAudioAction'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf7s/\xd5',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageRecordAudioAction()


class SendMessageRecordRoundAction(TLObject):
    CONSTRUCTOR_ID = 0x88f27fbc
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SendMessageRecordRoundAction'
        }

    def __bytes__(self):
        return b''.join((
            b'\xbc\x7f\xf2\x88',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageRecordRoundAction()


class SendMessageRecordVideoAction(TLObject):
    CONSTRUCTOR_ID = 0xa187d66f
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SendMessageRecordVideoAction'
        }

    def __bytes__(self):
        return b''.join((
            b'o\xd6\x87\xa1',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageRecordVideoAction()


class SendMessageTypingAction(TLObject):
    CONSTRUCTOR_ID = 0x16bf744e
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SendMessageTypingAction'
        }

    def __bytes__(self):
        return b''.join((
            b'Nt\xbf\x16',
        ))

    @staticmethod
    def from_reader(reader):
        return SendMessageTypingAction()


class SendMessageUploadAudioAction(TLObject):
    CONSTRUCTOR_ID = 0xf351d7ab
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadAudioAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'\xab\xd7Q\xf3',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadAudioAction(progress=_progress)


class SendMessageUploadDocumentAction(TLObject):
    CONSTRUCTOR_ID = 0xaa0cd9e4
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadDocumentAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4\xd9\x0c\xaa',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadDocumentAction(progress=_progress)


class SendMessageUploadPhotoAction(TLObject):
    CONSTRUCTOR_ID = 0xd1d34a26
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadPhotoAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'&J\xd3\xd1',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadPhotoAction(progress=_progress)


class SendMessageUploadRoundAction(TLObject):
    CONSTRUCTOR_ID = 0x243e1c66
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadRoundAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'f\x1c>$',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadRoundAction(progress=_progress)


class SendMessageUploadVideoAction(TLObject):
    CONSTRUCTOR_ID = 0xe9763aec
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        super().__init__()

        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadVideoAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'\xec:v\xe9',
            struct.pack('<i', self.progress),
        ))

    @staticmethod
    def from_reader(reader):
        _progress = reader.read_int()
        return SendMessageUploadVideoAction(progress=_progress)


class ServerDHInnerData(TLObject):
    CONSTRUCTOR_ID = 0xb5890dba
    SUBCLASS_OF_ID = 0xc69a67bc

    def __init__(self, nonce, server_nonce, g, dh_prime, g_a, server_time):
        """
        :param int nonce:
        :param int server_nonce:
        :param int g:
        :param bytes dh_prime:
        :param bytes g_a:
        :param int server_time:

        Constructor for Server_DH_inner_data: Instance of ServerDHInnerData.
        """
        super().__init__()

        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.g = g  # type: int
        self.dh_prime = dh_prime  # type: bytes
        self.g_a = g_a  # type: bytes
        self.server_time = server_time  # type: int

    def to_dict(self):
        return {
            '_': 'ServerDHInnerData',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'g': self.g,
            'dh_prime': self.dh_prime,
            'g_a': self.g_a,
            'server_time': self.server_time
        }

    def __bytes__(self):
        return b''.join((
            b'\xba\r\x89\xb5',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            struct.pack('<i', self.g),
            TLObject.serialize_bytes(self.dh_prime),
            TLObject.serialize_bytes(self.g_a),
            struct.pack('<i', self.server_time),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _g = reader.read_int()
        _dh_prime = reader.tgread_bytes()
        _g_a = reader.tgread_bytes()
        _server_time = reader.read_int()
        return ServerDHInnerData(nonce=_nonce, server_nonce=_server_nonce, g=_g, dh_prime=_dh_prime, g_a=_g_a, server_time=_server_time)


class ServerDHParamsFail(TLObject):
    CONSTRUCTOR_ID = 0x79cb045d
    SUBCLASS_OF_ID = 0xa6188d9e

    def __init__(self, nonce, server_nonce, new_nonce_hash):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash:

        Constructor for Server_DH_Params: Instance of either ServerDHParamsFail, ServerDHParamsOk.
        """
        super().__init__()

        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce_hash = new_nonce_hash  # type: int

    def to_dict(self):
        return {
            '_': 'ServerDHParamsFail',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash': self.new_nonce_hash
        }

    def __bytes__(self):
        return b''.join((
            b']\x04\xcby',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash.to_bytes(16, 'little', signed=True),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash = reader.read_large_int(bits=128)
        return ServerDHParamsFail(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash=_new_nonce_hash)


class ServerDHParamsOk(TLObject):
    CONSTRUCTOR_ID = 0xd0e8075c
    SUBCLASS_OF_ID = 0xa6188d9e

    def __init__(self, nonce, server_nonce, encrypted_answer):
        """
        :param int nonce:
        :param int server_nonce:
        :param bytes encrypted_answer:

        Constructor for Server_DH_Params: Instance of either ServerDHParamsFail, ServerDHParamsOk.
        """
        super().__init__()

        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.encrypted_answer = encrypted_answer  # type: bytes

    def to_dict(self):
        return {
            '_': 'ServerDHParamsOk',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'encrypted_answer': self.encrypted_answer
        }

    def __bytes__(self):
        return b''.join((
            b'\\\x07\xe8\xd0',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            TLObject.serialize_bytes(self.encrypted_answer),
        ))

    @staticmethod
    def from_reader(reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _encrypted_answer = reader.tgread_bytes()
        return ServerDHParamsOk(nonce=_nonce, server_nonce=_server_nonce, encrypted_answer=_encrypted_answer)


class ShippingOption(TLObject):
    CONSTRUCTOR_ID = 0xb6213cdf
    SUBCLASS_OF_ID = 0xf4e94c78

    def __init__(self, id, title, prices):
        """
        :param str id:
        :param str title:
        :param list[LabeledPrice] prices:

        Constructor for ShippingOption: Instance of ShippingOption.
        """
        super().__init__()

        self.id = id  # type: str
        self.title = title  # type: str
        self.prices = prices  # type: List[TypeLabeledPrice]

    def to_dict(self):
        return {
            '_': 'ShippingOption',
            'id': self.id,
            'title': self.title,
            'prices': [] if self.prices is None else [None if x is None else x.to_dict() for x in self.prices]
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf<!\xb6',
            TLObject.serialize_bytes(self.id),
            TLObject.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.prices)),b''.join(bytes(x) for x in self.prices),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.tgread_string()
        _title = reader.tgread_string()
        reader.read_int()
        _prices = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _prices.append(_x)

        return ShippingOption(id=_id, title=_title, prices=_prices)


class StickerPack(TLObject):
    CONSTRUCTOR_ID = 0x12b299d4
    SUBCLASS_OF_ID = 0x9fefa4d4

    def __init__(self, emoticon, documents):
        """
        :param str emoticon:
        :param list[int] documents:

        Constructor for StickerPack: Instance of StickerPack.
        """
        super().__init__()

        self.emoticon = emoticon  # type: str
        self.documents = documents  # type: List[int]

    def to_dict(self):
        return {
            '_': 'StickerPack',
            'emoticon': self.emoticon,
            'documents': [] if self.documents is None else self.documents[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd4\x99\xb2\x12',
            TLObject.serialize_bytes(self.emoticon),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(struct.pack('<q', x) for x in self.documents),
        ))

    @staticmethod
    def from_reader(reader):
        _emoticon = reader.tgread_string()
        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _documents.append(_x)

        return StickerPack(emoticon=_emoticon, documents=_documents)


class StickerSet(TLObject):
    CONSTRUCTOR_ID = 0xcd303b41
    SUBCLASS_OF_ID = 0xbad3ff91

    def __init__(self, id, access_hash, title, short_name, count, hash, installed=None, archived=None, official=None, masks=None):
        """
        :param bool | None installed:
        :param bool | None archived:
        :param bool | None official:
        :param bool | None masks:
        :param int id:
        :param int access_hash:
        :param str title:
        :param str short_name:
        :param int count:
        :param int hash:

        Constructor for StickerSet: Instance of StickerSet.
        """
        super().__init__()

        self.installed = installed  # type: Optional[bool]
        self.archived = archived  # type: Optional[bool]
        self.official = official  # type: Optional[bool]
        self.masks = masks  # type: Optional[bool]
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.title = title  # type: str
        self.short_name = short_name  # type: str
        self.count = count  # type: int
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'StickerSet',
            'installed': self.installed,
            'archived': self.archived,
            'official': self.official,
            'masks': self.masks,
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'short_name': self.short_name,
            'count': self.count,
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'A;0\xcd',
            struct.pack('<I', (0 if self.installed is None or self.installed is False else 1) | (0 if self.archived is None or self.archived is False else 2) | (0 if self.official is None or self.official is False else 4) | (0 if self.masks is None or self.masks is False else 8)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            TLObject.serialize_bytes(self.title),
            TLObject.serialize_bytes(self.short_name),
            struct.pack('<i', self.count),
            struct.pack('<i', self.hash),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _installed = bool(flags & 1)
        _archived = bool(flags & 2)
        _official = bool(flags & 4)
        _masks = bool(flags & 8)
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _title = reader.tgread_string()
        _short_name = reader.tgread_string()
        _count = reader.read_int()
        _hash = reader.read_int()
        return StickerSet(id=_id, access_hash=_access_hash, title=_title, short_name=_short_name, count=_count, hash=_hash, installed=_installed, archived=_archived, official=_official, masks=_masks)


class StickerSetCovered(TLObject):
    CONSTRUCTOR_ID = 0x6410a5d2
    SUBCLASS_OF_ID = 0x7f86e4e5

    def __init__(self, set, cover):
        """
        :param StickerSet set:
        :param Document cover:

        Constructor for StickerSetCovered: Instance of either StickerSetCovered, StickerSetMultiCovered.
        """
        super().__init__()

        self.set = set  # type: TypeStickerSet
        self.cover = cover  # type: TypeDocument

    def to_dict(self):
        return {
            '_': 'StickerSetCovered',
            'set': None if self.set is None else self.set.to_dict(),
            'cover': None if self.cover is None else self.cover.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd2\xa5\x10d',
            bytes(self.set),
            bytes(self.cover),
        ))

    @staticmethod
    def from_reader(reader):
        _set = reader.tgread_object()
        _cover = reader.tgread_object()
        return StickerSetCovered(set=_set, cover=_cover)


class StickerSetMultiCovered(TLObject):
    CONSTRUCTOR_ID = 0x3407e51b
    SUBCLASS_OF_ID = 0x7f86e4e5

    def __init__(self, set, covers):
        """
        :param StickerSet set:
        :param list[Document] covers:

        Constructor for StickerSetCovered: Instance of either StickerSetCovered, StickerSetMultiCovered.
        """
        super().__init__()

        self.set = set  # type: TypeStickerSet
        self.covers = covers  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'StickerSetMultiCovered',
            'set': None if self.set is None else self.set.to_dict(),
            'covers': [] if self.covers is None else [None if x is None else x.to_dict() for x in self.covers]
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b\xe5\x074',
            bytes(self.set),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.covers)),b''.join(bytes(x) for x in self.covers),
        ))

    @staticmethod
    def from_reader(reader):
        _set = reader.tgread_object()
        reader.read_int()
        _covers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _covers.append(_x)

        return StickerSetMultiCovered(set=_set, covers=_covers)


class TextBold(TLObject):
    CONSTRUCTOR_ID = 0x6724abc4
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextBold',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xab$g',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextBold(text=_text)


class TextConcat(TLObject):
    CONSTRUCTOR_ID = 0x7e6260d7
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, texts):
        """
        :param list[RichText] texts:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.texts = texts  # type: List[TypeRichText]

    def to_dict(self):
        return {
            '_': 'TextConcat',
            'texts': [] if self.texts is None else [None if x is None else x.to_dict() for x in self.texts]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7`b~',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.texts)),b''.join(bytes(x) for x in self.texts),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _texts = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _texts.append(_x)

        return TextConcat(texts=_texts)


class TextEmail(TLObject):
    CONSTRUCTOR_ID = 0xde5a0dd6
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text, email):
        """
        :param RichText text:
        :param str email:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text  # type: TypeRichText
        self.email = email  # type: str

    def to_dict(self):
        return {
            '_': 'TextEmail',
            'text': None if self.text is None else self.text.to_dict(),
            'email': self.email
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6\rZ\xde',
            bytes(self.text),
            TLObject.serialize_bytes(self.email),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _email = reader.tgread_string()
        return TextEmail(text=_text, email=_email)


class TextEmpty(TLObject):
    CONSTRUCTOR_ID = 0xdc3d824f
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'TextEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'O\x82=\xdc',
        ))

    @staticmethod
    def from_reader(reader):
        return TextEmpty()


class TextFixed(TLObject):
    CONSTRUCTOR_ID = 0x6c3f19b9
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextFixed',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\x19?l',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextFixed(text=_text)


class TextItalic(TLObject):
    CONSTRUCTOR_ID = 0xd912a59c
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextItalic',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9c\xa5\x12\xd9',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextItalic(text=_text)


class TextPlain(TLObject):
    CONSTRUCTOR_ID = 0x744694e0
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param str text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'TextPlain',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0\x94Ft',
            TLObject.serialize_bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_string()
        return TextPlain(text=_text)


class TextStrike(TLObject):
    CONSTRUCTOR_ID = 0x9bf8bb95
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextStrike',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xbb\xf8\x9b',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextStrike(text=_text)


class TextUnderline(TLObject):
    CONSTRUCTOR_ID = 0xc12622c4
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param RichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextUnderline',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4"&\xc1',
            bytes(self.text),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        return TextUnderline(text=_text)


class TextUrl(TLObject):
    CONSTRUCTOR_ID = 0x3c2884c1
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text, url, webpage_id):
        """
        :param RichText text:
        :param str url:
        :param int webpage_id:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        super().__init__()

        self.text = text  # type: TypeRichText
        self.url = url  # type: str
        self.webpage_id = webpage_id  # type: int

    def to_dict(self):
        return {
            '_': 'TextUrl',
            'text': None if self.text is None else self.text.to_dict(),
            'url': self.url,
            'webpage_id': self.webpage_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\x84(<',
            bytes(self.text),
            TLObject.serialize_bytes(self.url),
            struct.pack('<q', self.webpage_id),
        ))

    @staticmethod
    def from_reader(reader):
        _text = reader.tgread_object()
        _url = reader.tgread_string()
        _webpage_id = reader.read_long()
        return TextUrl(text=_text, url=_url, webpage_id=_webpage_id)


class TopPeer(TLObject):
    CONSTRUCTOR_ID = 0xedcdc05b
    SUBCLASS_OF_ID = 0x6916c601

    def __init__(self, peer, rating):
        """
        :param Peer peer:
        :param double rating:

        Constructor for TopPeer: Instance of TopPeer.
        """
        super().__init__()

        self.peer = peer  # type: TypePeer
        self.rating = rating  # type: Typedouble

    def to_dict(self):
        return {
            '_': 'TopPeer',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'rating': self.rating
        }

    def __bytes__(self):
        return b''.join((
            b'[\xc0\xcd\xed',
            bytes(self.peer),
            struct.pack('<d', self.rating),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _rating = reader.read_double()
        return TopPeer(peer=_peer, rating=_rating)


class TopPeerCategoryBotsInline(TLObject):
    CONSTRUCTOR_ID = 0x148677e2
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryBotsInline'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe2w\x86\x14',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryBotsInline()


class TopPeerCategoryBotsPM(TLObject):
    CONSTRUCTOR_ID = 0xab661b5b
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryBotsPM'
        }

    def __bytes__(self):
        return b''.join((
            b'[\x1bf\xab',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryBotsPM()


class TopPeerCategoryChannels(TLObject):
    CONSTRUCTOR_ID = 0x161d9628
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryChannels'
        }

    def __bytes__(self):
        return b''.join((
            b'(\x96\x1d\x16',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryChannels()


class TopPeerCategoryCorrespondents(TLObject):
    CONSTRUCTOR_ID = 0x637b7ed
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryCorrespondents'
        }

    def __bytes__(self):
        return b''.join((
            b'\xed\xb77\x06',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryCorrespondents()


class TopPeerCategoryGroups(TLObject):
    CONSTRUCTOR_ID = 0xbd17a14a
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryGroups'
        }

    def __bytes__(self):
        return b''.join((
            b'J\xa1\x17\xbd',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryGroups()


class TopPeerCategoryPeers(TLObject):
    CONSTRUCTOR_ID = 0xfb834291
    SUBCLASS_OF_ID = 0x4aec930

    def __init__(self, category, count, peers):
        """
        :param TopPeerCategory category:
        :param int count:
        :param list[TopPeer] peers:

        Constructor for TopPeerCategoryPeers: Instance of TopPeerCategoryPeers.
        """
        super().__init__()

        self.category = category  # type: TypeTopPeerCategory
        self.count = count  # type: int
        self.peers = peers  # type: List[TypeTopPeer]

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryPeers',
            'category': None if self.category is None else self.category.to_dict(),
            'count': self.count,
            'peers': [] if self.peers is None else [None if x is None else x.to_dict() for x in self.peers]
        }

    def __bytes__(self):
        return b''.join((
            b'\x91B\x83\xfb',
            bytes(self.category),
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.peers)),b''.join(bytes(x) for x in self.peers),
        ))

    @staticmethod
    def from_reader(reader):
        _category = reader.tgread_object()
        _count = reader.read_int()
        reader.read_int()
        _peers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _peers.append(_x)

        return TopPeerCategoryPeers(category=_category, count=_count, peers=_peers)


class TopPeerCategoryPhoneCalls(TLObject):
    CONSTRUCTOR_ID = 0x1e76a78c
    SUBCLASS_OF_ID = 0xddf02502

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryPhoneCalls'
        }

    def __bytes__(self):
        return b''.join((
            b'\x8c\xa7v\x1e',
        ))

    @staticmethod
    def from_reader(reader):
        return TopPeerCategoryPhoneCalls()


class UpdateBotCallbackQuery(TLObject):
    CONSTRUCTOR_ID = 0xe73547e1
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, peer, msg_id, chat_instance, data=None, game_short_name=None):
        """
        :param int query_id:
        :param int user_id:
        :param Peer peer:
        :param int msg_id:
        :param int chat_instance:
        :param bytes | None data:
        :param str | None game_short_name:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.peer = peer  # type: TypePeer
        self.msg_id = msg_id  # type: int
        self.chat_instance = chat_instance  # type: int
        self.data = data  # type: Optional[bytes]
        self.game_short_name = game_short_name  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'UpdateBotCallbackQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'msg_id': self.msg_id,
            'chat_instance': self.chat_instance,
            'data': self.data,
            'game_short_name': self.game_short_name
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1G5\xe7',
            struct.pack('<I', (0 if self.data is None or self.data is False else 1) | (0 if self.game_short_name is None or self.game_short_name is False else 2)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            bytes(self.peer),
            struct.pack('<i', self.msg_id),
            struct.pack('<q', self.chat_instance),
            b'' if self.data is None or self.data is False else (TLObject.serialize_bytes(self.data)),
            b'' if self.game_short_name is None or self.game_short_name is False else (TLObject.serialize_bytes(self.game_short_name)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _peer = reader.tgread_object()
        _msg_id = reader.read_int()
        _chat_instance = reader.read_long()
        if flags & 1:
            _data = reader.tgread_bytes()
        else:
            _data = None
        if flags & 2:
            _game_short_name = reader.tgread_string()
        else:
            _game_short_name = None
        return UpdateBotCallbackQuery(query_id=_query_id, user_id=_user_id, peer=_peer, msg_id=_msg_id, chat_instance=_chat_instance, data=_data, game_short_name=_game_short_name)


class UpdateBotInlineQuery(TLObject):
    CONSTRUCTOR_ID = 0x54826690
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, query, offset, geo=None):
        """
        :param int query_id:
        :param int user_id:
        :param str query:
        :param GeoPoint | None geo:
        :param str offset:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.query = query  # type: str
        self.geo = geo  # type: Optional[TypeGeoPoint]
        self.offset = offset  # type: str

    def to_dict(self):
        return {
            '_': 'UpdateBotInlineQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'query': self.query,
            'geo': None if self.geo is None else self.geo.to_dict(),
            'offset': self.offset
        }

    def __bytes__(self):
        return b''.join((
            b'\x90f\x82T',
            struct.pack('<I', (0 if self.geo is None or self.geo is False else 1)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.query),
            b'' if self.geo is None or self.geo is False else (bytes(self.geo)),
            TLObject.serialize_bytes(self.offset),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _query = reader.tgread_string()
        if flags & 1:
            _geo = reader.tgread_object()
        else:
            _geo = None
        _offset = reader.tgread_string()
        return UpdateBotInlineQuery(query_id=_query_id, user_id=_user_id, query=_query, offset=_offset, geo=_geo)


class UpdateBotInlineSend(TLObject):
    CONSTRUCTOR_ID = 0xe48f964
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, query, id, geo=None, msg_id=None):
        """
        :param int user_id:
        :param str query:
        :param GeoPoint | None geo:
        :param str id:
        :param InputBotInlineMessageID | None msg_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.query = query  # type: str
        self.geo = geo  # type: Optional[TypeGeoPoint]
        self.id = id  # type: str
        self.msg_id = msg_id  # type: Optional[TypeInputBotInlineMessageID]

    def to_dict(self):
        return {
            '_': 'UpdateBotInlineSend',
            'user_id': self.user_id,
            'query': self.query,
            'geo': None if self.geo is None else self.geo.to_dict(),
            'id': self.id,
            'msg_id': None if self.msg_id is None else self.msg_id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'd\xf9H\x0e',
            struct.pack('<I', (0 if self.geo is None or self.geo is False else 1) | (0 if self.msg_id is None or self.msg_id is False else 2)),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.query),
            b'' if self.geo is None or self.geo is False else (bytes(self.geo)),
            TLObject.serialize_bytes(self.id),
            b'' if self.msg_id is None or self.msg_id is False else (bytes(self.msg_id)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _user_id = reader.read_int()
        _query = reader.tgread_string()
        if flags & 1:
            _geo = reader.tgread_object()
        else:
            _geo = None
        _id = reader.tgread_string()
        if flags & 2:
            _msg_id = reader.tgread_object()
        else:
            _msg_id = None
        return UpdateBotInlineSend(user_id=_user_id, query=_query, id=_id, geo=_geo, msg_id=_msg_id)


class UpdateBotPrecheckoutQuery(TLObject):
    CONSTRUCTOR_ID = 0x5d2f3aa9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, payload, currency, total_amount, info=None, shipping_option_id=None):
        """
        :param int query_id:
        :param int user_id:
        :param bytes payload:
        :param PaymentRequestedInfo | None info:
        :param str | None shipping_option_id:
        :param str currency:
        :param int total_amount:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.payload = payload  # type: bytes
        self.info = info  # type: Optional[TypePaymentRequestedInfo]
        self.shipping_option_id = shipping_option_id  # type: Optional[str]
        self.currency = currency  # type: str
        self.total_amount = total_amount  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateBotPrecheckoutQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'payload': self.payload,
            'info': None if self.info is None else self.info.to_dict(),
            'shipping_option_id': self.shipping_option_id,
            'currency': self.currency,
            'total_amount': self.total_amount
        }

    def __bytes__(self):
        return b''.join((
            b'\xa9:/]',
            struct.pack('<I', (0 if self.info is None or self.info is False else 1) | (0 if self.shipping_option_id is None or self.shipping_option_id is False else 2)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.payload),
            b'' if self.info is None or self.info is False else (bytes(self.info)),
            b'' if self.shipping_option_id is None or self.shipping_option_id is False else (TLObject.serialize_bytes(self.shipping_option_id)),
            TLObject.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _payload = reader.tgread_bytes()
        if flags & 1:
            _info = reader.tgread_object()
        else:
            _info = None
        if flags & 2:
            _shipping_option_id = reader.tgread_string()
        else:
            _shipping_option_id = None
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        return UpdateBotPrecheckoutQuery(query_id=_query_id, user_id=_user_id, payload=_payload, currency=_currency, total_amount=_total_amount, info=_info, shipping_option_id=_shipping_option_id)


class UpdateBotShippingQuery(TLObject):
    CONSTRUCTOR_ID = 0xe0cdc940
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, payload, shipping_address):
        """
        :param int query_id:
        :param int user_id:
        :param bytes payload:
        :param PostAddress shipping_address:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.payload = payload  # type: bytes
        self.shipping_address = shipping_address  # type: TypePostAddress

    def to_dict(self):
        return {
            '_': 'UpdateBotShippingQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'payload': self.payload,
            'shipping_address': None if self.shipping_address is None else self.shipping_address.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'@\xc9\xcd\xe0',
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.payload),
            bytes(self.shipping_address),
        ))

    @staticmethod
    def from_reader(reader):
        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _payload = reader.tgread_bytes()
        _shipping_address = reader.tgread_object()
        return UpdateBotShippingQuery(query_id=_query_id, user_id=_user_id, payload=_payload, shipping_address=_shipping_address)


class UpdateBotWebhookJSON(TLObject):
    CONSTRUCTOR_ID = 0x8317c0c3
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, data):
        """
        :param DataJSON data:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.data = data  # type: TypeDataJSON

    def to_dict(self):
        return {
            '_': 'UpdateBotWebhookJSON',
            'data': None if self.data is None else self.data.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\xc0\x17\x83',
            bytes(self.data),
        ))

    @staticmethod
    def from_reader(reader):
        _data = reader.tgread_object()
        return UpdateBotWebhookJSON(data=_data)


class UpdateBotWebhookJSONQuery(TLObject):
    CONSTRUCTOR_ID = 0x9b9240a6
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, data, timeout):
        """
        :param int query_id:
        :param DataJSON data:
        :param int timeout:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.query_id = query_id  # type: int
        self.data = data  # type: TypeDataJSON
        self.timeout = timeout  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateBotWebhookJSONQuery',
            'query_id': self.query_id,
            'data': None if self.data is None else self.data.to_dict(),
            'timeout': self.timeout
        }

    def __bytes__(self):
        return b''.join((
            b'\xa6@\x92\x9b',
            struct.pack('<q', self.query_id),
            bytes(self.data),
            struct.pack('<i', self.timeout),
        ))

    @staticmethod
    def from_reader(reader):
        _query_id = reader.read_long()
        _data = reader.tgread_object()
        _timeout = reader.read_int()
        return UpdateBotWebhookJSONQuery(query_id=_query_id, data=_data, timeout=_timeout)


class UpdateChannel(TLObject):
    CONSTRUCTOR_ID = 0xb6d45656
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannel',
            'channel_id': self.channel_id
        }

    def __bytes__(self):
        return b''.join((
            b'VV\xd4\xb6',
            struct.pack('<i', self.channel_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        return UpdateChannel(channel_id=_channel_id)


class UpdateChannelAvailableMessages(TLObject):
    CONSTRUCTOR_ID = 0x70db6837
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, available_min_id):
        """
        :param int channel_id:
        :param int available_min_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.available_min_id = available_min_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannelAvailableMessages',
            'channel_id': self.channel_id,
            'available_min_id': self.available_min_id
        }

    def __bytes__(self):
        return b''.join((
            b'7h\xdbp',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.available_min_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _available_min_id = reader.read_int()
        return UpdateChannelAvailableMessages(channel_id=_channel_id, available_min_id=_available_min_id)


class UpdateChannelMessageViews(TLObject):
    CONSTRUCTOR_ID = 0x98a12b4b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, id, views):
        """
        :param int channel_id:
        :param int id:
        :param int views:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.id = id  # type: int
        self.views = views  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannelMessageViews',
            'channel_id': self.channel_id,
            'id': self.id,
            'views': self.views
        }

    def __bytes__(self):
        return b''.join((
            b'K+\xa1\x98',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.id),
            struct.pack('<i', self.views),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _id = reader.read_int()
        _views = reader.read_int()
        return UpdateChannelMessageViews(channel_id=_channel_id, id=_id, views=_views)


class UpdateChannelPinnedMessage(TLObject):
    CONSTRUCTOR_ID = 0x98592475
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, id):
        """
        :param int channel_id:
        :param int id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannelPinnedMessage',
            'channel_id': self.channel_id,
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'u$Y\x98',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _id = reader.read_int()
        return UpdateChannelPinnedMessage(channel_id=_channel_id, id=_id)


class UpdateChannelReadMessagesContents(TLObject):
    CONSTRUCTOR_ID = 0x89893b45
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, messages):
        """
        :param int channel_id:
        :param list[int] messages:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.messages = messages  # type: List[int]

    def to_dict(self):
        return {
            '_': 'UpdateChannelReadMessagesContents',
            'channel_id': self.channel_id,
            'messages': [] if self.messages is None else self.messages[:]
        }

    def __bytes__(self):
        return b''.join((
            b'E;\x89\x89',
            struct.pack('<i', self.channel_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        return UpdateChannelReadMessagesContents(channel_id=_channel_id, messages=_messages)


class UpdateChannelTooLong(TLObject):
    CONSTRUCTOR_ID = 0xeb0467fb
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, pts=None):
        """
        :param int channel_id:
        :param int | None pts:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.pts = pts  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'UpdateChannelTooLong',
            'channel_id': self.channel_id,
            'pts': self.pts
        }

    def __bytes__(self):
        return b''.join((
            b'\xfbg\x04\xeb',
            struct.pack('<I', (0 if self.pts is None or self.pts is False else 1)),
            struct.pack('<i', self.channel_id),
            b'' if self.pts is None or self.pts is False else (struct.pack('<i', self.pts)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _channel_id = reader.read_int()
        if flags & 1:
            _pts = reader.read_int()
        else:
            _pts = None
        return UpdateChannelTooLong(channel_id=_channel_id, pts=_pts)


class UpdateChannelWebPage(TLObject):
    CONSTRUCTOR_ID = 0x40771900
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, webpage, pts, pts_count):
        """
        :param int channel_id:
        :param WebPage webpage:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.webpage = webpage  # type: TypeWebPage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannelWebPage',
            'channel_id': self.channel_id,
            'webpage': None if self.webpage is None else self.webpage.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\x19w@',
            struct.pack('<i', self.channel_id),
            bytes(self.webpage),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _webpage = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateChannelWebPage(channel_id=_channel_id, webpage=_webpage, pts=_pts, pts_count=_pts_count)


class UpdateChatAdmins(TLObject):
    CONSTRUCTOR_ID = 0x6e947941
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, enabled, version):
        """
        :param int chat_id:
        :param Bool enabled:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.enabled = enabled  # type: TypeBool
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChatAdmins',
            'chat_id': self.chat_id,
            'enabled': self.enabled,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'Ay\x94n',
            struct.pack('<i', self.chat_id),
            b'\xb5ur\x99' if self.enabled else b'7\x97y\xbc',
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _enabled = reader.tgread_bool()
        _version = reader.read_int()
        return UpdateChatAdmins(chat_id=_chat_id, enabled=_enabled, version=_version)


class UpdateChatParticipantAdd(TLObject):
    CONSTRUCTOR_ID = 0xea4b0e5c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, inviter_id, date, version):
        """
        :param int chat_id:
        :param int user_id:
        :param int inviter_id:
        :param datetime.datetime | None date:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChatParticipantAdd',
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'\\\x0eK\xea',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        _version = reader.read_int()
        return UpdateChatParticipantAdd(chat_id=_chat_id, user_id=_user_id, inviter_id=_inviter_id, date=_date, version=_version)


class UpdateChatParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xb6901959
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, is_admin, version):
        """
        :param int chat_id:
        :param int user_id:
        :param Bool is_admin:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: int
        self.is_admin = is_admin  # type: TypeBool
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChatParticipantAdmin',
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'is_admin': self.is_admin,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'Y\x19\x90\xb6',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.is_admin else b'7\x97y\xbc',
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _is_admin = reader.tgread_bool()
        _version = reader.read_int()
        return UpdateChatParticipantAdmin(chat_id=_chat_id, user_id=_user_id, is_admin=_is_admin, version=_version)


class UpdateChatParticipantDelete(TLObject):
    CONSTRUCTOR_ID = 0x6e5f8c22
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, version):
        """
        :param int chat_id:
        :param int user_id:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: int
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChatParticipantDelete',
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'"\x8c_n',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.version),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _version = reader.read_int()
        return UpdateChatParticipantDelete(chat_id=_chat_id, user_id=_user_id, version=_version)


class UpdateChatParticipants(TLObject):
    CONSTRUCTOR_ID = 0x7761198
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, participants):
        """
        :param ChatParticipants participants:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.participants = participants  # type: TypeChatParticipants

    def to_dict(self):
        return {
            '_': 'UpdateChatParticipants',
            'participants': None if self.participants is None else self.participants.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x98\x11v\x07',
            bytes(self.participants),
        ))

    @staticmethod
    def from_reader(reader):
        _participants = reader.tgread_object()
        return UpdateChatParticipants(participants=_participants)


class UpdateChatUserTyping(TLObject):
    CONSTRUCTOR_ID = 0x9a65ea1f
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, action):
        """
        :param int chat_id:
        :param int user_id:
        :param SendMessageAction action:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: int
        self.action = action  # type: TypeSendMessageAction

    def to_dict(self):
        return {
            '_': 'UpdateChatUserTyping',
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\xeae\x9a',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return UpdateChatUserTyping(chat_id=_chat_id, user_id=_user_id, action=_action)


class UpdateConfig(TLObject):
    CONSTRUCTOR_ID = 0xa229dd06
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdateConfig'
        }

    def __bytes__(self):
        return b''.join((
            b'\x06\xdd)\xa2',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateConfig()


class UpdateContactLink(TLObject):
    CONSTRUCTOR_ID = 0x9d2e67c5
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, my_link, foreign_link):
        """
        :param int user_id:
        :param ContactLink my_link:
        :param ContactLink foreign_link:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.my_link = my_link  # type: TypeContactLink
        self.foreign_link = foreign_link  # type: TypeContactLink

    def to_dict(self):
        return {
            '_': 'UpdateContactLink',
            'user_id': self.user_id,
            'my_link': None if self.my_link is None else self.my_link.to_dict(),
            'foreign_link': None if self.foreign_link is None else self.foreign_link.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5g.\x9d',
            struct.pack('<i', self.user_id),
            bytes(self.my_link),
            bytes(self.foreign_link),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _my_link = reader.tgread_object()
        _foreign_link = reader.tgread_object()
        return UpdateContactLink(user_id=_user_id, my_link=_my_link, foreign_link=_foreign_link)


class UpdateContactRegistered(TLObject):
    CONSTRUCTOR_ID = 0x2575bbb9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param datetime.datetime | None date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateContactRegistered',
            'user_id': self.user_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\xbbu%',
            struct.pack('<i', self.user_id),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return UpdateContactRegistered(user_id=_user_id, date=_date)


class UpdateContactsReset(TLObject):
    CONSTRUCTOR_ID = 0x7084a7be
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdateContactsReset'
        }

    def __bytes__(self):
        return b''.join((
            b'\xbe\xa7\x84p',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateContactsReset()


class UpdateDcOptions(TLObject):
    CONSTRUCTOR_ID = 0x8e5e9873
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, dc_options):
        """
        :param list[DcOption] dc_options:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.dc_options = dc_options  # type: List[TypeDcOption]

    def to_dict(self):
        return {
            '_': 'UpdateDcOptions',
            'dc_options': [] if self.dc_options is None else [None if x is None else x.to_dict() for x in self.dc_options]
        }

    def __bytes__(self):
        return b''.join((
            b's\x98^\x8e',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dc_options)),b''.join(bytes(x) for x in self.dc_options),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _dc_options = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dc_options.append(_x)

        return UpdateDcOptions(dc_options=_dc_options)


class UpdateDeleteChannelMessages(TLObject):
    CONSTRUCTOR_ID = 0xc37521c9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, messages, pts, pts_count):
        """
        :param int channel_id:
        :param list[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.messages = messages  # type: List[int]
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateDeleteChannelMessages',
            'channel_id': self.channel_id,
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9!u\xc3',
            struct.pack('<i', self.channel_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateDeleteChannelMessages(channel_id=_channel_id, messages=_messages, pts=_pts, pts_count=_pts_count)


class UpdateDeleteMessages(TLObject):
    CONSTRUCTOR_ID = 0xa20db0e5
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, messages, pts, pts_count):
        """
        :param list[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.messages = messages  # type: List[int]
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateDeleteMessages',
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\xb0\r\xa2',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateDeleteMessages(messages=_messages, pts=_pts, pts_count=_pts_count)


class UpdateDialogPinned(TLObject):
    CONSTRUCTOR_ID = 0xd711a2cc
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, pinned=None):
        """
        :param bool | None pinned:
        :param Peer peer:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.pinned = pinned  # type: Optional[bool]
        self.peer = peer  # type: TypePeer

    def to_dict(self):
        return {
            '_': 'UpdateDialogPinned',
            'pinned': self.pinned,
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xcc\xa2\x11\xd7',
            struct.pack('<I', (0 if self.pinned is None or self.pinned is False else 1)),
            bytes(self.peer),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _pinned = bool(flags & 1)
        _peer = reader.tgread_object()
        return UpdateDialogPinned(peer=_peer, pinned=_pinned)


class UpdateDraftMessage(TLObject):
    CONSTRUCTOR_ID = 0xee2bb969
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, draft):
        """
        :param Peer peer:
        :param DraftMessage draft:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.peer = peer  # type: TypePeer
        self.draft = draft  # type: TypeDraftMessage

    def to_dict(self):
        return {
            '_': 'UpdateDraftMessage',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'draft': None if self.draft is None else self.draft.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'i\xb9+\xee',
            bytes(self.peer),
            bytes(self.draft),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _draft = reader.tgread_object()
        return UpdateDraftMessage(peer=_peer, draft=_draft)


class UpdateEditChannelMessage(TLObject):
    CONSTRUCTOR_ID = 0x1b3f4df7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param Message message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.message = message  # type: TypeMessage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateEditChannelMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xf7M?\x1b',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateEditChannelMessage(message=_message, pts=_pts, pts_count=_pts_count)


class UpdateEditMessage(TLObject):
    CONSTRUCTOR_ID = 0xe40370a3
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param Message message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.message = message  # type: TypeMessage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateEditMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xa3p\x03\xe4',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateEditMessage(message=_message, pts=_pts, pts_count=_pts_count)


class UpdateEncryptedChatTyping(TLObject):
    CONSTRUCTOR_ID = 0x1710f156
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateEncryptedChatTyping',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'V\xf1\x10\x17',
            struct.pack('<i', self.chat_id),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        return UpdateEncryptedChatTyping(chat_id=_chat_id)


class UpdateEncryptedMessagesRead(TLObject):
    CONSTRUCTOR_ID = 0x38fe25b7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, max_date, date):
        """
        :param int chat_id:
        :param datetime.datetime | None max_date:
        :param datetime.datetime | None date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.chat_id = chat_id  # type: int
        self.max_date = max_date  # type: Optional[datetime]
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateEncryptedMessagesRead',
            'chat_id': self.chat_id,
            'max_date': self.max_date,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7%\xfe8',
            struct.pack('<i', self.chat_id),
            TLObject.serialize_datetime(self.max_date),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _chat_id = reader.read_int()
        _max_date = reader.tgread_date()
        _date = reader.tgread_date()
        return UpdateEncryptedMessagesRead(chat_id=_chat_id, max_date=_max_date, date=_date)


class UpdateEncryption(TLObject):
    CONSTRUCTOR_ID = 0xb4a2e88d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat, date):
        """
        :param EncryptedChat chat:
        :param datetime.datetime | None date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.chat = chat  # type: TypeEncryptedChat
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateEncryption',
            'chat': None if self.chat is None else self.chat.to_dict(),
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\x8d\xe8\xa2\xb4',
            bytes(self.chat),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _chat = reader.tgread_object()
        _date = reader.tgread_date()
        return UpdateEncryption(chat=_chat, date=_date)


class UpdateFavedStickers(TLObject):
    CONSTRUCTOR_ID = 0xe511996d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdateFavedStickers'
        }

    def __bytes__(self):
        return b''.join((
            b'm\x99\x11\xe5',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateFavedStickers()


class UpdateInlineBotCallbackQuery(TLObject):
    CONSTRUCTOR_ID = 0xf9d27a5a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, msg_id, chat_instance, data=None, game_short_name=None):
        """
        :param int query_id:
        :param int user_id:
        :param InputBotInlineMessageID msg_id:
        :param int chat_instance:
        :param bytes | None data:
        :param str | None game_short_name:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.msg_id = msg_id  # type: TypeInputBotInlineMessageID
        self.chat_instance = chat_instance  # type: int
        self.data = data  # type: Optional[bytes]
        self.game_short_name = game_short_name  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'UpdateInlineBotCallbackQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'msg_id': None if self.msg_id is None else self.msg_id.to_dict(),
            'chat_instance': self.chat_instance,
            'data': self.data,
            'game_short_name': self.game_short_name
        }

    def __bytes__(self):
        return b''.join((
            b'Zz\xd2\xf9',
            struct.pack('<I', (0 if self.data is None or self.data is False else 1) | (0 if self.game_short_name is None or self.game_short_name is False else 2)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            bytes(self.msg_id),
            struct.pack('<q', self.chat_instance),
            b'' if self.data is None or self.data is False else (TLObject.serialize_bytes(self.data)),
            b'' if self.game_short_name is None or self.game_short_name is False else (TLObject.serialize_bytes(self.game_short_name)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _msg_id = reader.tgread_object()
        _chat_instance = reader.read_long()
        if flags & 1:
            _data = reader.tgread_bytes()
        else:
            _data = None
        if flags & 2:
            _game_short_name = reader.tgread_string()
        else:
            _game_short_name = None
        return UpdateInlineBotCallbackQuery(query_id=_query_id, user_id=_user_id, msg_id=_msg_id, chat_instance=_chat_instance, data=_data, game_short_name=_game_short_name)


class UpdateLangPack(TLObject):
    CONSTRUCTOR_ID = 0x56022f4d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, difference):
        """
        :param LangPackDifference difference:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.difference = difference  # type: TypeLangPackDifference

    def to_dict(self):
        return {
            '_': 'UpdateLangPack',
            'difference': None if self.difference is None else self.difference.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'M/\x02V',
            bytes(self.difference),
        ))

    @staticmethod
    def from_reader(reader):
        _difference = reader.tgread_object()
        return UpdateLangPack(difference=_difference)


class UpdateLangPackTooLong(TLObject):
    CONSTRUCTOR_ID = 0x10c2404b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdateLangPackTooLong'
        }

    def __bytes__(self):
        return b''.join((
            b'K@\xc2\x10',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateLangPackTooLong()


class UpdateMessageID(TLObject):
    CONSTRUCTOR_ID = 0x4e90bfd6
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, id, random_id=None):
        """
        :param int id:
        :param int random_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.id = id  # type: int
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            '_': 'UpdateMessageID',
            'id': self.id,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6\xbf\x90N',
            struct.pack('<i', self.id),
            struct.pack('<q', self.random_id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _random_id = reader.read_long()
        return UpdateMessageID(id=_id, random_id=_random_id)


class UpdateNewChannelMessage(TLObject):
    CONSTRUCTOR_ID = 0x62ba04d9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param Message message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.message = message  # type: TypeMessage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateNewChannelMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xd9\x04\xbab',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateNewChannelMessage(message=_message, pts=_pts, pts_count=_pts_count)


class UpdateNewEncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0x12bcbd9a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, qts):
        """
        :param EncryptedMessage message:
        :param int qts:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.message = message  # type: TypeEncryptedMessage
        self.qts = qts  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateNewEncryptedMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'qts': self.qts
        }

    def __bytes__(self):
        return b''.join((
            b'\x9a\xbd\xbc\x12',
            bytes(self.message),
            struct.pack('<i', self.qts),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _qts = reader.read_int()
        return UpdateNewEncryptedMessage(message=_message, qts=_qts)


class UpdateNewMessage(TLObject):
    CONSTRUCTOR_ID = 0x1f2b0afd
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param Message message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.message = message  # type: TypeMessage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateNewMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\n+\x1f',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateNewMessage(message=_message, pts=_pts, pts_count=_pts_count)


class UpdateNewStickerSet(TLObject):
    CONSTRUCTOR_ID = 0x688a30aa
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, stickerset):
        """
        :param messages.StickerSet stickerset:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.stickerset = stickerset  # type: TypeStickerSet

    def to_dict(self):
        return {
            '_': 'UpdateNewStickerSet',
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xaa0\x8ah',
            bytes(self.stickerset),
        ))

    @staticmethod
    def from_reader(reader):
        _stickerset = reader.tgread_object()
        return UpdateNewStickerSet(stickerset=_stickerset)


class UpdateNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0xbec268ef
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, notify_settings):
        """
        :param NotifyPeer peer:
        :param PeerNotifySettings notify_settings:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.peer = peer  # type: TypeNotifyPeer
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings

    def to_dict(self):
        return {
            '_': 'UpdateNotifySettings',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xefh\xc2\xbe',
            bytes(self.peer),
            bytes(self.notify_settings),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        return UpdateNotifySettings(peer=_peer, notify_settings=_notify_settings)


class UpdatePhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xab0f6b1e
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, phone_call):
        """
        :param PhoneCall phone_call:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.phone_call = phone_call  # type: TypePhoneCall

    def to_dict(self):
        return {
            '_': 'UpdatePhoneCall',
            'phone_call': None if self.phone_call is None else self.phone_call.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1ek\x0f\xab',
            bytes(self.phone_call),
        ))

    @staticmethod
    def from_reader(reader):
        _phone_call = reader.tgread_object()
        return UpdatePhoneCall(phone_call=_phone_call)


class UpdatePinnedDialogs(TLObject):
    CONSTRUCTOR_ID = 0xd8caf68d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, order=None):
        """
        :param list[Peer] | None order:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.order = order  # type: Optional[List[TypePeer]]

    def to_dict(self):
        return {
            '_': 'UpdatePinnedDialogs',
            'order': [] if self.order is None else [None if x is None else x.to_dict() for x in self.order]
        }

    def __bytes__(self):
        return b''.join((
            b'\x8d\xf6\xca\xd8',
            struct.pack('<I', (0 if self.order is None or self.order is False else 1)),
            b'' if self.order is None or self.order is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(bytes(x) for x in self.order))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        if flags & 1:
            reader.read_int()
            _order = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _order.append(_x)

        else:
            _order = None
        return UpdatePinnedDialogs(order=_order)


class UpdatePrivacy(TLObject):
    CONSTRUCTOR_ID = 0xee3b272a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, key, rules):
        """
        :param PrivacyKey key:
        :param list[PrivacyRule] rules:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.key = key  # type: TypePrivacyKey
        self.rules = rules  # type: List[TypePrivacyRule]

    def to_dict(self):
        return {
            '_': 'UpdatePrivacy',
            'key': None if self.key is None else self.key.to_dict(),
            'rules': [] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules]
        }

    def __bytes__(self):
        return b''.join((
            b"*';\xee",
            bytes(self.key),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rules)),b''.join(bytes(x) for x in self.rules),
        ))

    @staticmethod
    def from_reader(reader):
        _key = reader.tgread_object()
        reader.read_int()
        _rules = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rules.append(_x)

        return UpdatePrivacy(key=_key, rules=_rules)


class UpdatePtsChanged(TLObject):
    CONSTRUCTOR_ID = 0x3354678f
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdatePtsChanged'
        }

    def __bytes__(self):
        return b''.join((
            b'\x8fgT3',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdatePtsChanged()


class UpdateReadChannelInbox(TLObject):
    CONSTRUCTOR_ID = 0x4214f37f
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, max_id):
        """
        :param int channel_id:
        :param int max_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.max_id = max_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadChannelInbox',
            'channel_id': self.channel_id,
            'max_id': self.max_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf3\x14B',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _max_id = reader.read_int()
        return UpdateReadChannelInbox(channel_id=_channel_id, max_id=_max_id)


class UpdateReadChannelOutbox(TLObject):
    CONSTRUCTOR_ID = 0x25d6c9c7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, max_id):
        """
        :param int channel_id:
        :param int max_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.channel_id = channel_id  # type: int
        self.max_id = max_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadChannelOutbox',
            'channel_id': self.channel_id,
            'max_id': self.max_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\xc9\xd6%',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.max_id),
        ))

    @staticmethod
    def from_reader(reader):
        _channel_id = reader.read_int()
        _max_id = reader.read_int()
        return UpdateReadChannelOutbox(channel_id=_channel_id, max_id=_max_id)


class UpdateReadFeaturedStickers(TLObject):
    CONSTRUCTOR_ID = 0x571d2742
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdateReadFeaturedStickers'
        }

    def __bytes__(self):
        return b''.join((
            b"B'\x1dW",
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateReadFeaturedStickers()


class UpdateReadHistoryInbox(TLObject):
    CONSTRUCTOR_ID = 0x9961fd5c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, max_id, pts, pts_count):
        """
        :param Peer peer:
        :param int max_id:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.peer = peer  # type: TypePeer
        self.max_id = max_id  # type: int
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadHistoryInbox',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\\\xfda\x99',
            bytes(self.peer),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateReadHistoryInbox(peer=_peer, max_id=_max_id, pts=_pts, pts_count=_pts_count)


class UpdateReadHistoryOutbox(TLObject):
    CONSTRUCTOR_ID = 0x2f2f21bf
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, max_id, pts, pts_count):
        """
        :param Peer peer:
        :param int max_id:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.peer = peer  # type: TypePeer
        self.max_id = max_id  # type: int
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadHistoryOutbox',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xbf!//',
            bytes(self.peer),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateReadHistoryOutbox(peer=_peer, max_id=_max_id, pts=_pts, pts_count=_pts_count)


class UpdateReadMessagesContents(TLObject):
    CONSTRUCTOR_ID = 0x68c13933
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, messages, pts, pts_count):
        """
        :param list[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.messages = messages  # type: List[int]
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadMessagesContents',
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'39\xc1h',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateReadMessagesContents(messages=_messages, pts=_pts, pts_count=_pts_count)


class UpdateRecentStickers(TLObject):
    CONSTRUCTOR_ID = 0x9a422c20
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdateRecentStickers'
        }

    def __bytes__(self):
        return b''.join((
            b' ,B\x9a',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateRecentStickers()


class UpdateSavedGifs(TLObject):
    CONSTRUCTOR_ID = 0x9375341e
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdateSavedGifs'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1e4u\x93',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateSavedGifs()


class UpdateServiceNotification(TLObject):
    CONSTRUCTOR_ID = 0xebe46819
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, type, message, media, entities, popup=None, inbox_date=None):
        """
        :param bool | None popup:
        :param datetime.datetime | None inbox_date:
        :param str type:
        :param str message:
        :param MessageMedia media:
        :param list[MessageEntity] entities:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.popup = popup  # type: Optional[bool]
        self.inbox_date = inbox_date  # type: Optional[datetime]
        self.type = type  # type: str
        self.message = message  # type: str
        self.media = media  # type: TypeMessageMedia
        self.entities = entities  # type: List[TypeMessageEntity]

    def to_dict(self):
        return {
            '_': 'UpdateServiceNotification',
            'popup': self.popup,
            'inbox_date': self.inbox_date,
            'type': self.type,
            'message': self.message,
            'media': None if self.media is None else self.media.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x19h\xe4\xeb',
            struct.pack('<I', (0 if self.popup is None or self.popup is False else 1) | (0 if self.inbox_date is None or self.inbox_date is False else 2)),
            b'' if self.inbox_date is None or self.inbox_date is False else (TLObject.serialize_datetime(self.inbox_date)),
            TLObject.serialize_bytes(self.type),
            TLObject.serialize_bytes(self.message),
            bytes(self.media),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _popup = bool(flags & 1)
        if flags & 2:
            _inbox_date = reader.tgread_date()
        else:
            _inbox_date = None
        _type = reader.tgread_string()
        _message = reader.tgread_string()
        _media = reader.tgread_object()
        reader.read_int()
        _entities = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _entities.append(_x)

        return UpdateServiceNotification(type=_type, message=_message, media=_media, entities=_entities, popup=_popup, inbox_date=_inbox_date)


class UpdateShort(TLObject):
    CONSTRUCTOR_ID = 0x78d4dec1
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, update, date):
        """
        :param Update update:
        :param datetime.datetime | None date:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.update = update  # type: TypeUpdate
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateShort',
            'update': None if self.update is None else self.update.to_dict(),
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\xde\xd4x',
            bytes(self.update),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _update = reader.tgread_object()
        _date = reader.tgread_date()
        return UpdateShort(update=_update, date=_date)


class UpdateShortChatMessage(TLObject):
    CONSTRUCTOR_ID = 0x16812688
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, from_id, chat_id, message, pts, pts_count, date, out=None, mentioned=None, media_unread=None, silent=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, entities=None):
        """
        :param bool | None out:
        :param bool | None mentioned:
        :param bool | None media_unread:
        :param bool | None silent:
        :param int id:
        :param int from_id:
        :param int chat_id:
        :param str message:
        :param int pts:
        :param int pts_count:
        :param datetime.datetime | None date:
        :param MessageFwdHeader | None fwd_from:
        :param int | None via_bot_id:
        :param int | None reply_to_msg_id:
        :param list[MessageEntity] | None entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out  # type: Optional[bool]
        self.mentioned = mentioned  # type: Optional[bool]
        self.media_unread = media_unread  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.id = id  # type: int
        self.from_id = from_id  # type: int
        self.chat_id = chat_id  # type: int
        self.message = message  # type: str
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int
        self.date = date  # type: Optional[datetime]
        self.fwd_from = fwd_from  # type: Optional[TypeMessageFwdHeader]
        self.via_bot_id = via_bot_id  # type: Optional[int]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'UpdateShortChatMessage',
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'id': self.id,
            'from_id': self.from_id,
            'chat_id': self.chat_id,
            'message': self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'fwd_from': None if self.fwd_from is None else self.fwd_from.to_dict(),
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x88&\x81\x16',
            struct.pack('<I', (0 if self.out is None or self.out is False else 2) | (0 if self.mentioned is None or self.mentioned is False else 16) | (0 if self.media_unread is None or self.media_unread is False else 32) | (0 if self.silent is None or self.silent is False else 8192) | (0 if self.fwd_from is None or self.fwd_from is False else 4) | (0 if self.via_bot_id is None or self.via_bot_id is False else 2048) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 8) | (0 if self.entities is None or self.entities is False else 128)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.from_id),
            struct.pack('<i', self.chat_id),
            TLObject.serialize_bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            TLObject.serialize_datetime(self.date),
            b'' if self.fwd_from is None or self.fwd_from is False else (bytes(self.fwd_from)),
            b'' if self.via_bot_id is None or self.via_bot_id is False else (struct.pack('<i', self.via_bot_id)),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _id = reader.read_int()
        _from_id = reader.read_int()
        _chat_id = reader.read_int()
        _message = reader.tgread_string()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 4:
            _fwd_from = reader.tgread_object()
        else:
            _fwd_from = None
        if flags & 2048:
            _via_bot_id = reader.read_int()
        else:
            _via_bot_id = None
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return UpdateShortChatMessage(id=_id, from_id=_from_id, chat_id=_chat_id, message=_message, pts=_pts, pts_count=_pts_count, date=_date, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, fwd_from=_fwd_from, via_bot_id=_via_bot_id, reply_to_msg_id=_reply_to_msg_id, entities=_entities)


class UpdateShortMessage(TLObject):
    CONSTRUCTOR_ID = 0x914fbf11
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, user_id, message, pts, pts_count, date, out=None, mentioned=None, media_unread=None, silent=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, entities=None):
        """
        :param bool | None out:
        :param bool | None mentioned:
        :param bool | None media_unread:
        :param bool | None silent:
        :param int id:
        :param int user_id:
        :param str message:
        :param int pts:
        :param int pts_count:
        :param datetime.datetime | None date:
        :param MessageFwdHeader | None fwd_from:
        :param int | None via_bot_id:
        :param int | None reply_to_msg_id:
        :param list[MessageEntity] | None entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out  # type: Optional[bool]
        self.mentioned = mentioned  # type: Optional[bool]
        self.media_unread = media_unread  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.id = id  # type: int
        self.user_id = user_id  # type: int
        self.message = message  # type: str
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int
        self.date = date  # type: Optional[datetime]
        self.fwd_from = fwd_from  # type: Optional[TypeMessageFwdHeader]
        self.via_bot_id = via_bot_id  # type: Optional[int]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'UpdateShortMessage',
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'id': self.id,
            'user_id': self.user_id,
            'message': self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'fwd_from': None if self.fwd_from is None else self.fwd_from.to_dict(),
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xbfO\x91',
            struct.pack('<I', (0 if self.out is None or self.out is False else 2) | (0 if self.mentioned is None or self.mentioned is False else 16) | (0 if self.media_unread is None or self.media_unread is False else 32) | (0 if self.silent is None or self.silent is False else 8192) | (0 if self.fwd_from is None or self.fwd_from is False else 4) | (0 if self.via_bot_id is None or self.via_bot_id is False else 2048) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 8) | (0 if self.entities is None or self.entities is False else 128)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            TLObject.serialize_datetime(self.date),
            b'' if self.fwd_from is None or self.fwd_from is False else (bytes(self.fwd_from)),
            b'' if self.via_bot_id is None or self.via_bot_id is False else (struct.pack('<i', self.via_bot_id)),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _id = reader.read_int()
        _user_id = reader.read_int()
        _message = reader.tgread_string()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 4:
            _fwd_from = reader.tgread_object()
        else:
            _fwd_from = None
        if flags & 2048:
            _via_bot_id = reader.read_int()
        else:
            _via_bot_id = None
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return UpdateShortMessage(id=_id, user_id=_user_id, message=_message, pts=_pts, pts_count=_pts_count, date=_date, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, fwd_from=_fwd_from, via_bot_id=_via_bot_id, reply_to_msg_id=_reply_to_msg_id, entities=_entities)


class UpdateShortSentMessage(TLObject):
    CONSTRUCTOR_ID = 0x11f1331c
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, pts, pts_count, date, out=None, media=None, entities=None):
        """
        :param bool | None out:
        :param int id:
        :param int pts:
        :param int pts_count:
        :param datetime.datetime | None date:
        :param MessageMedia | None media:
        :param list[MessageEntity] | None entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.out = out  # type: Optional[bool]
        self.id = id  # type: int
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int
        self.date = date  # type: Optional[datetime]
        self.media = media  # type: Optional[TypeMessageMedia]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'UpdateShortSentMessage',
            'out': self.out,
            'id': self.id,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'media': None if self.media is None else self.media.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c3\xf1\x11',
            struct.pack('<I', (0 if self.out is None or self.out is False else 2) | (0 if self.media is None or self.media is False else 512) | (0 if self.entities is None or self.entities is False else 128)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            TLObject.serialize_datetime(self.date),
            b'' if self.media is None or self.media is False else (bytes(self.media)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 512:
            _media = reader.tgread_object()
        else:
            _media = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return UpdateShortSentMessage(id=_id, pts=_pts, pts_count=_pts_count, date=_date, out=_out, media=_media, entities=_entities)


class UpdateStickerSets(TLObject):
    CONSTRUCTOR_ID = 0x43ae3dec
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdateStickerSets'
        }

    def __bytes__(self):
        return b''.join((
            b'\xec=\xaeC',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdateStickerSets()


class UpdateStickerSetsOrder(TLObject):
    CONSTRUCTOR_ID = 0xbb2d201
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, order, masks=None):
        """
        :param bool | None masks:
        :param list[int] order:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.masks = masks  # type: Optional[bool]
        self.order = order  # type: List[int]

    def to_dict(self):
        return {
            '_': 'UpdateStickerSetsOrder',
            'masks': self.masks,
            'order': [] if self.order is None else self.order[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x01\xd2\xb2\x0b',
            struct.pack('<I', (0 if self.masks is None or self.masks is False else 1)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(struct.pack('<q', x) for x in self.order),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _masks = bool(flags & 1)
        reader.read_int()
        _order = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _order.append(_x)

        return UpdateStickerSetsOrder(order=_order, masks=_masks)


class UpdateUserBlocked(TLObject):
    CONSTRUCTOR_ID = 0x80ece81a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, blocked):
        """
        :param int user_id:
        :param Bool blocked:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.blocked = blocked  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'UpdateUserBlocked',
            'user_id': self.user_id,
            'blocked': self.blocked
        }

    def __bytes__(self):
        return b''.join((
            b'\x1a\xe8\xec\x80',
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.blocked else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _blocked = reader.tgread_bool()
        return UpdateUserBlocked(user_id=_user_id, blocked=_blocked)


class UpdateUserName(TLObject):
    CONSTRUCTOR_ID = 0xa7332b73
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, first_name, last_name, username):
        """
        :param int user_id:
        :param str first_name:
        :param str last_name:
        :param str username:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.username = username  # type: str

    def to_dict(self):
        return {
            '_': 'UpdateUserName',
            'user_id': self.user_id,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'username': self.username
        }

    def __bytes__(self):
        return b''.join((
            b's+3\xa7',
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.first_name),
            TLObject.serialize_bytes(self.last_name),
            TLObject.serialize_bytes(self.username),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _username = reader.tgread_string()
        return UpdateUserName(user_id=_user_id, first_name=_first_name, last_name=_last_name, username=_username)


class UpdateUserPhone(TLObject):
    CONSTRUCTOR_ID = 0x12b9417b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, phone):
        """
        :param int user_id:
        :param str phone:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.phone = phone  # type: str

    def to_dict(self):
        return {
            '_': 'UpdateUserPhone',
            'user_id': self.user_id,
            'phone': self.phone
        }

    def __bytes__(self):
        return b''.join((
            b'{A\xb9\x12',
            struct.pack('<i', self.user_id),
            TLObject.serialize_bytes(self.phone),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _phone = reader.tgread_string()
        return UpdateUserPhone(user_id=_user_id, phone=_phone)


class UpdateUserPhoto(TLObject):
    CONSTRUCTOR_ID = 0x95313b0c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, date, photo, previous):
        """
        :param int user_id:
        :param datetime.datetime | None date:
        :param UserProfilePhoto photo:
        :param Bool previous:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.photo = photo  # type: TypeUserProfilePhoto
        self.previous = previous  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'UpdateUserPhoto',
            'user_id': self.user_id,
            'date': self.date,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'previous': self.previous
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c;1\x95',
            struct.pack('<i', self.user_id),
            TLObject.serialize_datetime(self.date),
            bytes(self.photo),
            b'\xb5ur\x99' if self.previous else b'7\x97y\xbc',
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        _photo = reader.tgread_object()
        _previous = reader.tgread_bool()
        return UpdateUserPhoto(user_id=_user_id, date=_date, photo=_photo, previous=_previous)


class UpdateUserStatus(TLObject):
    CONSTRUCTOR_ID = 0x1bfbd823
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, status):
        """
        :param int user_id:
        :param UserStatus status:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.status = status  # type: TypeUserStatus

    def to_dict(self):
        return {
            '_': 'UpdateUserStatus',
            'user_id': self.user_id,
            'status': None if self.status is None else self.status.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'#\xd8\xfb\x1b',
            struct.pack('<i', self.user_id),
            bytes(self.status),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _status = reader.tgread_object()
        return UpdateUserStatus(user_id=_user_id, status=_status)


class UpdateUserTyping(TLObject):
    CONSTRUCTOR_ID = 0x5c486927
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, action):
        """
        :param int user_id:
        :param SendMessageAction action:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.user_id = user_id  # type: int
        self.action = action  # type: TypeSendMessageAction

    def to_dict(self):
        return {
            '_': 'UpdateUserTyping',
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b"'iH\\",
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @staticmethod
    def from_reader(reader):
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return UpdateUserTyping(user_id=_user_id, action=_action)


class UpdateWebPage(TLObject):
    CONSTRUCTOR_ID = 0x7f891213
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, webpage, pts, pts_count):
        """
        :param WebPage webpage:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages.
        """
        super().__init__()

        self.webpage = webpage  # type: TypeWebPage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateWebPage',
            'webpage': None if self.webpage is None else self.webpage.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\x13\x12\x89\x7f',
            bytes(self.webpage),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _webpage = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return UpdateWebPage(webpage=_webpage, pts=_pts, pts_count=_pts_count)


class Updates(TLObject):
    CONSTRUCTOR_ID = 0x74ae4240
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, updates, users, chats, date, seq):
        """
        :param list[Update] updates:
        :param list[User] users:
        :param list[Chat] chats:
        :param datetime.datetime | None date:
        :param int seq:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.updates = updates  # type: List[TypeUpdate]
        self.users = users  # type: List[TypeUser]
        self.chats = chats  # type: List[TypeChat]
        self.date = date  # type: Optional[datetime]
        self.seq = seq  # type: int

    def to_dict(self):
        return {
            '_': 'Updates',
            'updates': [] if self.updates is None else [None if x is None else x.to_dict() for x in self.updates],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'date': self.date,
            'seq': self.seq
        }

    def __bytes__(self):
        return b''.join((
            b'@B\xaet',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.updates)),b''.join(bytes(x) for x in self.updates),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.seq),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _updates = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _updates.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        _date = reader.tgread_date()
        _seq = reader.read_int()
        return Updates(updates=_updates, users=_users, chats=_chats, date=_date, seq=_seq)


class UpdatesCombined(TLObject):
    CONSTRUCTOR_ID = 0x725b04c3
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, updates, users, chats, date, seq_start, seq):
        """
        :param list[Update] updates:
        :param list[User] users:
        :param list[Chat] chats:
        :param datetime.datetime | None date:
        :param int seq_start:
        :param int seq:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        super().__init__()

        self.updates = updates  # type: List[TypeUpdate]
        self.users = users  # type: List[TypeUser]
        self.chats = chats  # type: List[TypeChat]
        self.date = date  # type: Optional[datetime]
        self.seq_start = seq_start  # type: int
        self.seq = seq  # type: int

    def to_dict(self):
        return {
            '_': 'UpdatesCombined',
            'updates': [] if self.updates is None else [None if x is None else x.to_dict() for x in self.updates],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'date': self.date,
            'seq_start': self.seq_start,
            'seq': self.seq
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\x04[r',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.updates)),b''.join(bytes(x) for x in self.updates),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            TLObject.serialize_datetime(self.date),
            struct.pack('<i', self.seq_start),
            struct.pack('<i', self.seq),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _updates = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _updates.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        _date = reader.tgread_date()
        _seq_start = reader.read_int()
        _seq = reader.read_int()
        return UpdatesCombined(updates=_updates, users=_users, chats=_chats, date=_date, seq_start=_seq_start, seq=_seq)


class UpdatesTooLong(TLObject):
    CONSTRUCTOR_ID = 0xe317af7e
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UpdatesTooLong'
        }

    def __bytes__(self):
        return b''.join((
            b'~\xaf\x17\xe3',
        ))

    @staticmethod
    def from_reader(reader):
        return UpdatesTooLong()


class User(TLObject):
    CONSTRUCTOR_ID = 0x2e13f4c3
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, id, is_self=None, contact=None, mutual_contact=None, deleted=None, bot=None, bot_chat_history=None, bot_nochats=None, verified=None, restricted=None, min=None, bot_inline_geo=None, access_hash=None, first_name=None, last_name=None, username=None, phone=None, photo=None, status=None, bot_info_version=None, restriction_reason=None, bot_inline_placeholder=None, lang_code=None):
        """
        :param bool | None is_self:
        :param bool | None contact:
        :param bool | None mutual_contact:
        :param bool | None deleted:
        :param bool | None bot:
        :param bool | None bot_chat_history:
        :param bool | None bot_nochats:
        :param bool | None verified:
        :param bool | None restricted:
        :param bool | None min:
        :param bool | None bot_inline_geo:
        :param int id:
        :param int | None access_hash:
        :param str | None first_name:
        :param str | None last_name:
        :param str | None username:
        :param str | None phone:
        :param UserProfilePhoto | None photo:
        :param UserStatus | None status:
        :param int | None bot_info_version:
        :param str | None restriction_reason:
        :param str | None bot_inline_placeholder:
        :param str | None lang_code:

        Constructor for User: Instance of either UserEmpty, User.
        """
        super().__init__()

        self.is_self = is_self  # type: Optional[bool]
        self.contact = contact  # type: Optional[bool]
        self.mutual_contact = mutual_contact  # type: Optional[bool]
        self.deleted = deleted  # type: Optional[bool]
        self.bot = bot  # type: Optional[bool]
        self.bot_chat_history = bot_chat_history  # type: Optional[bool]
        self.bot_nochats = bot_nochats  # type: Optional[bool]
        self.verified = verified  # type: Optional[bool]
        self.restricted = restricted  # type: Optional[bool]
        self.min = min  # type: Optional[bool]
        self.bot_inline_geo = bot_inline_geo  # type: Optional[bool]
        self.id = id  # type: int
        self.access_hash = access_hash  # type: Optional[int]
        self.first_name = first_name  # type: Optional[str]
        self.last_name = last_name  # type: Optional[str]
        self.username = username  # type: Optional[str]
        self.phone = phone  # type: Optional[str]
        self.photo = photo  # type: Optional[TypeUserProfilePhoto]
        self.status = status  # type: Optional[TypeUserStatus]
        self.bot_info_version = bot_info_version  # type: Optional[int]
        self.restriction_reason = restriction_reason  # type: Optional[str]
        self.bot_inline_placeholder = bot_inline_placeholder  # type: Optional[str]
        self.lang_code = lang_code  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'User',
            'is_self': self.is_self,
            'contact': self.contact,
            'mutual_contact': self.mutual_contact,
            'deleted': self.deleted,
            'bot': self.bot,
            'bot_chat_history': self.bot_chat_history,
            'bot_nochats': self.bot_nochats,
            'verified': self.verified,
            'restricted': self.restricted,
            'min': self.min,
            'bot_inline_geo': self.bot_inline_geo,
            'id': self.id,
            'access_hash': self.access_hash,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'username': self.username,
            'phone': self.phone,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'status': None if self.status is None else self.status.to_dict(),
            'bot_info_version': self.bot_info_version,
            'restriction_reason': self.restriction_reason,
            'bot_inline_placeholder': self.bot_inline_placeholder,
            'lang_code': self.lang_code
        }

    def __bytes__(self):
        assert ((self.bot or self.bot is not None) and (self.bot_info_version or self.bot_info_version is not None)) or ((self.bot is None or self.bot is False) and (self.bot_info_version is None or self.bot_info_version is False)), 'bot, bot_info_version parameters must all be False-y (like None) or all me True-y'
        assert ((self.restricted or self.restricted is not None) and (self.restriction_reason or self.restriction_reason is not None)) or ((self.restricted is None or self.restricted is False) and (self.restriction_reason is None or self.restriction_reason is False)), 'restricted, restriction_reason parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xc3\xf4\x13.',
            struct.pack('<I', (0 if self.is_self is None or self.is_self is False else 1024) | (0 if self.contact is None or self.contact is False else 2048) | (0 if self.mutual_contact is None or self.mutual_contact is False else 4096) | (0 if self.deleted is None or self.deleted is False else 8192) | (0 if self.bot is None or self.bot is False else 16384) | (0 if self.bot_chat_history is None or self.bot_chat_history is False else 32768) | (0 if self.bot_nochats is None or self.bot_nochats is False else 65536) | (0 if self.verified is None or self.verified is False else 131072) | (0 if self.restricted is None or self.restricted is False else 262144) | (0 if self.min is None or self.min is False else 1048576) | (0 if self.bot_inline_geo is None or self.bot_inline_geo is False else 2097152) | (0 if self.access_hash is None or self.access_hash is False else 1) | (0 if self.first_name is None or self.first_name is False else 2) | (0 if self.last_name is None or self.last_name is False else 4) | (0 if self.username is None or self.username is False else 8) | (0 if self.phone is None or self.phone is False else 16) | (0 if self.photo is None or self.photo is False else 32) | (0 if self.status is None or self.status is False else 64) | (0 if self.bot_info_version is None or self.bot_info_version is False else 16384) | (0 if self.restriction_reason is None or self.restriction_reason is False else 262144) | (0 if self.bot_inline_placeholder is None or self.bot_inline_placeholder is False else 524288) | (0 if self.lang_code is None or self.lang_code is False else 4194304)),
            struct.pack('<i', self.id),
            b'' if self.access_hash is None or self.access_hash is False else (struct.pack('<q', self.access_hash)),
            b'' if self.first_name is None or self.first_name is False else (TLObject.serialize_bytes(self.first_name)),
            b'' if self.last_name is None or self.last_name is False else (TLObject.serialize_bytes(self.last_name)),
            b'' if self.username is None or self.username is False else (TLObject.serialize_bytes(self.username)),
            b'' if self.phone is None or self.phone is False else (TLObject.serialize_bytes(self.phone)),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.status is None or self.status is False else (bytes(self.status)),
            b'' if self.bot_info_version is None or self.bot_info_version is False else (struct.pack('<i', self.bot_info_version)),
            b'' if self.restriction_reason is None or self.restriction_reason is False else (TLObject.serialize_bytes(self.restriction_reason)),
            b'' if self.bot_inline_placeholder is None or self.bot_inline_placeholder is False else (TLObject.serialize_bytes(self.bot_inline_placeholder)),
            b'' if self.lang_code is None or self.lang_code is False else (TLObject.serialize_bytes(self.lang_code)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _is_self = bool(flags & 1024)
        _contact = bool(flags & 2048)
        _mutual_contact = bool(flags & 4096)
        _deleted = bool(flags & 8192)
        _bot = bool(flags & 16384)
        _bot_chat_history = bool(flags & 32768)
        _bot_nochats = bool(flags & 65536)
        _verified = bool(flags & 131072)
        _restricted = bool(flags & 262144)
        _min = bool(flags & 1048576)
        _bot_inline_geo = bool(flags & 2097152)
        _id = reader.read_int()
        if flags & 1:
            _access_hash = reader.read_long()
        else:
            _access_hash = None
        if flags & 2:
            _first_name = reader.tgread_string()
        else:
            _first_name = None
        if flags & 4:
            _last_name = reader.tgread_string()
        else:
            _last_name = None
        if flags & 8:
            _username = reader.tgread_string()
        else:
            _username = None
        if flags & 16:
            _phone = reader.tgread_string()
        else:
            _phone = None
        if flags & 32:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 64:
            _status = reader.tgread_object()
        else:
            _status = None
        if flags & 16384:
            _bot_info_version = reader.read_int()
        else:
            _bot_info_version = None
        if flags & 262144:
            _restriction_reason = reader.tgread_string()
        else:
            _restriction_reason = None
        if flags & 524288:
            _bot_inline_placeholder = reader.tgread_string()
        else:
            _bot_inline_placeholder = None
        if flags & 4194304:
            _lang_code = reader.tgread_string()
        else:
            _lang_code = None
        return User(id=_id, is_self=_is_self, contact=_contact, mutual_contact=_mutual_contact, deleted=_deleted, bot=_bot, bot_chat_history=_bot_chat_history, bot_nochats=_bot_nochats, verified=_verified, restricted=_restricted, min=_min, bot_inline_geo=_bot_inline_geo, access_hash=_access_hash, first_name=_first_name, last_name=_last_name, username=_username, phone=_phone, photo=_photo, status=_status, bot_info_version=_bot_info_version, restriction_reason=_restriction_reason, bot_inline_placeholder=_bot_inline_placeholder, lang_code=_lang_code)


class UserEmpty(TLObject):
    CONSTRUCTOR_ID = 0x200250ba
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, id):
        """
        :param int id:

        Constructor for User: Instance of either UserEmpty, User.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'UserEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\xbaP\x02 ',
            struct.pack('<i', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        return UserEmpty(id=_id)


class UserFull(TLObject):
    CONSTRUCTOR_ID = 0xf220f3f
    SUBCLASS_OF_ID = 0x1f4661b9

    def __init__(self, user, link, notify_settings, common_chats_count, blocked=None, phone_calls_available=None, phone_calls_private=None, about=None, profile_photo=None, bot_info=None):
        """
        :param bool | None blocked:
        :param bool | None phone_calls_available:
        :param bool | None phone_calls_private:
        :param User user:
        :param str | None about:
        :param contacts.Link link:
        :param Photo | None profile_photo:
        :param PeerNotifySettings notify_settings:
        :param BotInfo | None bot_info:
        :param int common_chats_count:

        Constructor for UserFull: Instance of UserFull.
        """
        super().__init__()

        self.blocked = blocked  # type: Optional[bool]
        self.phone_calls_available = phone_calls_available  # type: Optional[bool]
        self.phone_calls_private = phone_calls_private  # type: Optional[bool]
        self.user = user  # type: TypeUser
        self.about = about  # type: Optional[str]
        self.link = link  # type: TypeLink
        self.profile_photo = profile_photo  # type: Optional[TypePhoto]
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings
        self.bot_info = bot_info  # type: Optional[TypeBotInfo]
        self.common_chats_count = common_chats_count  # type: int

    def to_dict(self):
        return {
            '_': 'UserFull',
            'blocked': self.blocked,
            'phone_calls_available': self.phone_calls_available,
            'phone_calls_private': self.phone_calls_private,
            'user': None if self.user is None else self.user.to_dict(),
            'about': self.about,
            'link': None if self.link is None else self.link.to_dict(),
            'profile_photo': None if self.profile_photo is None else self.profile_photo.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'bot_info': None if self.bot_info is None else self.bot_info.to_dict(),
            'common_chats_count': self.common_chats_count
        }

    def __bytes__(self):
        return b''.join((
            b'?\x0f"\x0f',
            struct.pack('<I', (0 if self.blocked is None or self.blocked is False else 1) | (0 if self.phone_calls_available is None or self.phone_calls_available is False else 16) | (0 if self.phone_calls_private is None or self.phone_calls_private is False else 32) | (0 if self.about is None or self.about is False else 2) | (0 if self.profile_photo is None or self.profile_photo is False else 4) | (0 if self.bot_info is None or self.bot_info is False else 8)),
            bytes(self.user),
            b'' if self.about is None or self.about is False else (TLObject.serialize_bytes(self.about)),
            bytes(self.link),
            b'' if self.profile_photo is None or self.profile_photo is False else (bytes(self.profile_photo)),
            bytes(self.notify_settings),
            b'' if self.bot_info is None or self.bot_info is False else (bytes(self.bot_info)),
            struct.pack('<i', self.common_chats_count),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _blocked = bool(flags & 1)
        _phone_calls_available = bool(flags & 16)
        _phone_calls_private = bool(flags & 32)
        _user = reader.tgread_object()
        if flags & 2:
            _about = reader.tgread_string()
        else:
            _about = None
        _link = reader.tgread_object()
        if flags & 4:
            _profile_photo = reader.tgread_object()
        else:
            _profile_photo = None
        _notify_settings = reader.tgread_object()
        if flags & 8:
            _bot_info = reader.tgread_object()
        else:
            _bot_info = None
        _common_chats_count = reader.read_int()
        return UserFull(user=_user, link=_link, notify_settings=_notify_settings, common_chats_count=_common_chats_count, blocked=_blocked, phone_calls_available=_phone_calls_available, phone_calls_private=_phone_calls_private, about=_about, profile_photo=_profile_photo, bot_info=_bot_info)


class UserProfilePhoto(TLObject):
    CONSTRUCTOR_ID = 0xd559d8c8
    SUBCLASS_OF_ID = 0xc6338f7d

    def __init__(self, photo_id, photo_small, photo_big):
        """
        :param int photo_id:
        :param FileLocation photo_small:
        :param FileLocation photo_big:

        Constructor for UserProfilePhoto: Instance of either UserProfilePhotoEmpty, UserProfilePhoto.
        """
        super().__init__()

        self.photo_id = photo_id  # type: int
        self.photo_small = photo_small  # type: TypeFileLocation
        self.photo_big = photo_big  # type: TypeFileLocation

    def to_dict(self):
        return {
            '_': 'UserProfilePhoto',
            'photo_id': self.photo_id,
            'photo_small': None if self.photo_small is None else self.photo_small.to_dict(),
            'photo_big': None if self.photo_big is None else self.photo_big.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xd8Y\xd5',
            struct.pack('<q', self.photo_id),
            bytes(self.photo_small),
            bytes(self.photo_big),
        ))

    @staticmethod
    def from_reader(reader):
        _photo_id = reader.read_long()
        _photo_small = reader.tgread_object()
        _photo_big = reader.tgread_object()
        return UserProfilePhoto(photo_id=_photo_id, photo_small=_photo_small, photo_big=_photo_big)


class UserProfilePhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x4f11bae1
    SUBCLASS_OF_ID = 0xc6338f7d

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UserProfilePhotoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xba\x11O',
        ))

    @staticmethod
    def from_reader(reader):
        return UserProfilePhotoEmpty()


class UserStatusEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9d05049
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UserStatusEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'IP\xd0\t',
        ))

    @staticmethod
    def from_reader(reader):
        return UserStatusEmpty()


class UserStatusLastMonth(TLObject):
    CONSTRUCTOR_ID = 0x77ebc742
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UserStatusLastMonth'
        }

    def __bytes__(self):
        return b''.join((
            b'B\xc7\xebw',
        ))

    @staticmethod
    def from_reader(reader):
        return UserStatusLastMonth()


class UserStatusLastWeek(TLObject):
    CONSTRUCTOR_ID = 0x7bf09fc
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UserStatusLastWeek'
        }

    def __bytes__(self):
        return b''.join((
            b'\xfc\t\xbf\x07',
        ))

    @staticmethod
    def from_reader(reader):
        return UserStatusLastWeek()


class UserStatusOffline(TLObject):
    CONSTRUCTOR_ID = 0x8c703f
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self, was_online):
        """
        :param datetime.datetime | None was_online:

        Constructor for UserStatus: Instance of either UserStatusEmpty, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth.
        """
        super().__init__()

        self.was_online = was_online  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UserStatusOffline',
            'was_online': self.was_online
        }

    def __bytes__(self):
        return b''.join((
            b'?p\x8c\x00',
            TLObject.serialize_datetime(self.was_online),
        ))

    @staticmethod
    def from_reader(reader):
        _was_online = reader.tgread_date()
        return UserStatusOffline(was_online=_was_online)


class UserStatusOnline(TLObject):
    CONSTRUCTOR_ID = 0xedb93949
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self, expires):
        """
        :param datetime.datetime | None expires:

        Constructor for UserStatus: Instance of either UserStatusEmpty, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth.
        """
        super().__init__()

        self.expires = expires  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UserStatusOnline',
            'expires': self.expires
        }

    def __bytes__(self):
        return b''.join((
            b'I9\xb9\xed',
            TLObject.serialize_datetime(self.expires),
        ))

    @staticmethod
    def from_reader(reader):
        _expires = reader.tgread_date()
        return UserStatusOnline(expires=_expires)


class UserStatusRecently(TLObject):
    CONSTRUCTOR_ID = 0xe26f42f1
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'UserStatusRecently'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf1Bo\xe2',
        ))

    @staticmethod
    def from_reader(reader):
        return UserStatusRecently()


class WallPaper(TLObject):
    CONSTRUCTOR_ID = 0xccb03657
    SUBCLASS_OF_ID = 0x96a2c98b

    def __init__(self, id, title, sizes, color):
        """
        :param int id:
        :param str title:
        :param list[PhotoSize] sizes:
        :param int color:

        Constructor for WallPaper: Instance of either WallPaper, WallPaperSolid.
        """
        super().__init__()

        self.id = id  # type: int
        self.title = title  # type: str
        self.sizes = sizes  # type: List[TypePhotoSize]
        self.color = color  # type: int

    def to_dict(self):
        return {
            '_': 'WallPaper',
            'id': self.id,
            'title': self.title,
            'sizes': [] if self.sizes is None else [None if x is None else x.to_dict() for x in self.sizes],
            'color': self.color
        }

    def __bytes__(self):
        return b''.join((
            b'W6\xb0\xcc',
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sizes)),b''.join(bytes(x) for x in self.sizes),
            struct.pack('<i', self.color),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        reader.read_int()
        _sizes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sizes.append(_x)

        _color = reader.read_int()
        return WallPaper(id=_id, title=_title, sizes=_sizes, color=_color)


class WallPaperSolid(TLObject):
    CONSTRUCTOR_ID = 0x63117f24
    SUBCLASS_OF_ID = 0x96a2c98b

    def __init__(self, id, title, bg_color, color):
        """
        :param int id:
        :param str title:
        :param int bg_color:
        :param int color:

        Constructor for WallPaper: Instance of either WallPaper, WallPaperSolid.
        """
        super().__init__()

        self.id = id  # type: int
        self.title = title  # type: str
        self.bg_color = bg_color  # type: int
        self.color = color  # type: int

    def to_dict(self):
        return {
            '_': 'WallPaperSolid',
            'id': self.id,
            'title': self.title,
            'bg_color': self.bg_color,
            'color': self.color
        }

    def __bytes__(self):
        return b''.join((
            b'$\x7f\x11c',
            struct.pack('<i', self.id),
            TLObject.serialize_bytes(self.title),
            struct.pack('<i', self.bg_color),
            struct.pack('<i', self.color),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        _bg_color = reader.read_int()
        _color = reader.read_int()
        return WallPaperSolid(id=_id, title=_title, bg_color=_bg_color, color=_color)


class WebDocument(TLObject):
    CONSTRUCTOR_ID = 0xc61acbd8
    SUBCLASS_OF_ID = 0x3b642814

    def __init__(self, url, access_hash, size, mime_type, attributes, dc_id):
        """
        :param str url:
        :param int access_hash:
        :param int size:
        :param str mime_type:
        :param list[DocumentAttribute] attributes:
        :param int dc_id:

        Constructor for WebDocument: Instance of WebDocument.
        """
        super().__init__()

        self.url = url  # type: str
        self.access_hash = access_hash  # type: int
        self.size = size  # type: int
        self.mime_type = mime_type  # type: str
        self.attributes = attributes  # type: List[TypeDocumentAttribute]
        self.dc_id = dc_id  # type: int

    def to_dict(self):
        return {
            '_': 'WebDocument',
            'url': self.url,
            'access_hash': self.access_hash,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes],
            'dc_id': self.dc_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8\xcb\x1a\xc6',
            TLObject.serialize_bytes(self.url),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.size),
            TLObject.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
            struct.pack('<i', self.dc_id),
        ))

    @staticmethod
    def from_reader(reader):
        _url = reader.tgread_string()
        _access_hash = reader.read_long()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        _dc_id = reader.read_int()
        return WebDocument(url=_url, access_hash=_access_hash, size=_size, mime_type=_mime_type, attributes=_attributes, dc_id=_dc_id)


class WebPage(TLObject):
    CONSTRUCTOR_ID = 0x5f07b4bc
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id, url, display_url, hash, type=None, site_name=None, title=None, description=None, photo=None, embed_url=None, embed_type=None, embed_width=None, embed_height=None, duration=None, author=None, document=None, cached_page=None):
        """
        :param int id:
        :param str url:
        :param str display_url:
        :param int hash:
        :param str | None type:
        :param str | None site_name:
        :param str | None title:
        :param str | None description:
        :param Photo | None photo:
        :param str | None embed_url:
        :param str | None embed_type:
        :param int | None embed_width:
        :param int | None embed_height:
        :param int | None duration:
        :param str | None author:
        :param Document | None document:
        :param Page | None cached_page:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id  # type: int
        self.url = url  # type: str
        self.display_url = display_url  # type: str
        self.hash = hash  # type: int
        self.type = type  # type: Optional[str]
        self.site_name = site_name  # type: Optional[str]
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.photo = photo  # type: Optional[TypePhoto]
        self.embed_url = embed_url  # type: Optional[str]
        self.embed_type = embed_type  # type: Optional[str]
        self.embed_width = embed_width  # type: Optional[int]
        self.embed_height = embed_height  # type: Optional[int]
        self.duration = duration  # type: Optional[int]
        self.author = author  # type: Optional[str]
        self.document = document  # type: Optional[TypeDocument]
        self.cached_page = cached_page  # type: Optional[TypePage]

    def to_dict(self):
        return {
            '_': 'WebPage',
            'id': self.id,
            'url': self.url,
            'display_url': self.display_url,
            'hash': self.hash,
            'type': self.type,
            'site_name': self.site_name,
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'embed_url': self.embed_url,
            'embed_type': self.embed_type,
            'embed_width': self.embed_width,
            'embed_height': self.embed_height,
            'duration': self.duration,
            'author': self.author,
            'document': None if self.document is None else self.document.to_dict(),
            'cached_page': None if self.cached_page is None else self.cached_page.to_dict()
        }

    def __bytes__(self):
        assert ((self.embed_url or self.embed_url is not None) and (self.embed_type or self.embed_type is not None)) or ((self.embed_url is None or self.embed_url is False) and (self.embed_type is None or self.embed_type is False)), 'embed_url, embed_type parameters must all be False-y (like None) or all me True-y'
        assert ((self.embed_width or self.embed_width is not None) and (self.embed_height or self.embed_height is not None)) or ((self.embed_width is None or self.embed_width is False) and (self.embed_height is None or self.embed_height is False)), 'embed_width, embed_height parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xbc\xb4\x07_',
            struct.pack('<I', (0 if self.type is None or self.type is False else 1) | (0 if self.site_name is None or self.site_name is False else 2) | (0 if self.title is None or self.title is False else 4) | (0 if self.description is None or self.description is False else 8) | (0 if self.photo is None or self.photo is False else 16) | (0 if self.embed_url is None or self.embed_url is False else 32) | (0 if self.embed_type is None or self.embed_type is False else 32) | (0 if self.embed_width is None or self.embed_width is False else 64) | (0 if self.embed_height is None or self.embed_height is False else 64) | (0 if self.duration is None or self.duration is False else 128) | (0 if self.author is None or self.author is False else 256) | (0 if self.document is None or self.document is False else 512) | (0 if self.cached_page is None or self.cached_page is False else 1024)),
            struct.pack('<q', self.id),
            TLObject.serialize_bytes(self.url),
            TLObject.serialize_bytes(self.display_url),
            struct.pack('<i', self.hash),
            b'' if self.type is None or self.type is False else (TLObject.serialize_bytes(self.type)),
            b'' if self.site_name is None or self.site_name is False else (TLObject.serialize_bytes(self.site_name)),
            b'' if self.title is None or self.title is False else (TLObject.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (TLObject.serialize_bytes(self.description)),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.embed_url is None or self.embed_url is False else (TLObject.serialize_bytes(self.embed_url)),
            b'' if self.embed_type is None or self.embed_type is False else (TLObject.serialize_bytes(self.embed_type)),
            b'' if self.embed_width is None or self.embed_width is False else (struct.pack('<i', self.embed_width)),
            b'' if self.embed_height is None or self.embed_height is False else (struct.pack('<i', self.embed_height)),
            b'' if self.duration is None or self.duration is False else (struct.pack('<i', self.duration)),
            b'' if self.author is None or self.author is False else (TLObject.serialize_bytes(self.author)),
            b'' if self.document is None or self.document is False else (bytes(self.document)),
            b'' if self.cached_page is None or self.cached_page is False else (bytes(self.cached_page)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _url = reader.tgread_string()
        _display_url = reader.tgread_string()
        _hash = reader.read_int()
        if flags & 1:
            _type = reader.tgread_string()
        else:
            _type = None
        if flags & 2:
            _site_name = reader.tgread_string()
        else:
            _site_name = None
        if flags & 4:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 8:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 16:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 32:
            _embed_url = reader.tgread_string()
        else:
            _embed_url = None
        if flags & 32:
            _embed_type = reader.tgread_string()
        else:
            _embed_type = None
        if flags & 64:
            _embed_width = reader.read_int()
        else:
            _embed_width = None
        if flags & 64:
            _embed_height = reader.read_int()
        else:
            _embed_height = None
        if flags & 128:
            _duration = reader.read_int()
        else:
            _duration = None
        if flags & 256:
            _author = reader.tgread_string()
        else:
            _author = None
        if flags & 512:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 1024:
            _cached_page = reader.tgread_object()
        else:
            _cached_page = None
        return WebPage(id=_id, url=_url, display_url=_display_url, hash=_hash, type=_type, site_name=_site_name, title=_title, description=_description, photo=_photo, embed_url=_embed_url, embed_type=_embed_type, embed_width=_embed_width, embed_height=_embed_height, duration=_duration, author=_author, document=_document, cached_page=_cached_page)


class WebPageEmpty(TLObject):
    CONSTRUCTOR_ID = 0xeb1477e8
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id):
        """
        :param int id:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'WebPageEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\xe8w\x14\xeb',
            struct.pack('<q', self.id),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        return WebPageEmpty(id=_id)


class WebPageNotModified(TLObject):
    CONSTRUCTOR_ID = 0x85849473
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'WebPageNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b's\x94\x84\x85',
        ))

    @staticmethod
    def from_reader(reader):
        return WebPageNotModified()


class WebPagePending(TLObject):
    CONSTRUCTOR_ID = 0xc586da1c
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id, date):
        """
        :param int id:
        :param datetime.datetime | None date:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        super().__init__()

        self.id = id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'WebPagePending',
            'id': self.id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\xda\x86\xc5',
            struct.pack('<q', self.id),
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _id = reader.read_long()
        _date = reader.tgread_date()
        return WebPagePending(id=_id, date=_date)

TypeAccountDaysTTL = AccountDaysTTL
TypeAuthorization = Authorization
TypeBadMsgNotification = Union[BadMsgNotification,BadServerSalt]
TypeBotCommand = BotCommand
TypeBotInfo = BotInfo
TypeBotInlineResult = Union[BotInlineResult,BotInlineMediaResult]
TypeBotInlineMessage = Union[BotInlineMessageMediaAuto,BotInlineMessageText,BotInlineMessageMediaGeo,BotInlineMessageMediaVenue,BotInlineMessageMediaContact]
TypeCdnConfig = CdnConfig
TypeCdnFileHash = CdnFileHash
TypeCdnPublicKey = CdnPublicKey
TypeChat = Union[ChatEmpty,Chat,ChatForbidden,Channel,ChannelForbidden]
TypeChannelAdminLogEvent = ChannelAdminLogEvent
TypeChannelAdminLogEventAction = Union[ChannelAdminLogEventActionChangeTitle,ChannelAdminLogEventActionChangeAbout,ChannelAdminLogEventActionChangeUsername,ChannelAdminLogEventActionChangePhoto,ChannelAdminLogEventActionToggleInvites,ChannelAdminLogEventActionToggleSignatures,ChannelAdminLogEventActionUpdatePinned,ChannelAdminLogEventActionEditMessage,ChannelAdminLogEventActionDeleteMessage,ChannelAdminLogEventActionParticipantJoin,ChannelAdminLogEventActionParticipantLeave,ChannelAdminLogEventActionParticipantInvite,ChannelAdminLogEventActionParticipantToggleBan,ChannelAdminLogEventActionParticipantToggleAdmin,ChannelAdminLogEventActionChangeStickerSet,ChannelAdminLogEventActionTogglePreHistoryHidden]
TypeChannelAdminLogEventsFilter = ChannelAdminLogEventsFilter
TypeChannelAdminRights = ChannelAdminRights
TypeChannelBannedRights = ChannelBannedRights
TypeChatFull = Union[ChatFull,ChannelFull]
TypeChannelMessagesFilter = Union[ChannelMessagesFilterEmpty,ChannelMessagesFilter]
TypeChannelParticipant = Union[ChannelParticipant,ChannelParticipantSelf,ChannelParticipantCreator,ChannelParticipantAdmin,ChannelParticipantBanned]
TypeChannelParticipantsFilter = Union[ChannelParticipantsRecent,ChannelParticipantsAdmins,ChannelParticipantsKicked,ChannelParticipantsBots,ChannelParticipantsBanned,ChannelParticipantsSearch]
TypeChatInvite = Union[ChatInviteAlready,ChatInvite]
TypeExportedChatInvite = Union[ChatInviteEmpty,ChatInviteExported]
TypeChatParticipant = Union[ChatParticipant,ChatParticipantCreator,ChatParticipantAdmin]
TypeChatParticipants = Union[ChatParticipantsForbidden,ChatParticipants]
TypeChatPhoto = Union[ChatPhotoEmpty,ChatPhoto]
TypeClient_DH_Inner_Data = ClientDHInnerData
TypeConfig = Config
TypeContact = Contact
TypeContactBlocked = ContactBlocked
TypeContactLink = Union[ContactLinkUnknown,ContactLinkNone,ContactLinkHasPhone,ContactLinkContact]
TypeContactStatus = ContactStatus
TypeDataJSON = DataJSON
TypeDcOption = DcOption
TypeDestroyAuthKeyRes = Union[DestroyAuthKeyOk,DestroyAuthKeyNone,DestroyAuthKeyFail]
TypeDestroySessionRes = Union[DestroySessionOk,DestroySessionNone]
TypeSet_client_DH_params_answer = Union[DhGenOk,DhGenRetry,DhGenFail]
TypeDialog = Dialog
TypeDisabledFeature = DisabledFeature
TypeDocument = Union[DocumentEmpty,Document]
TypeDocumentAttribute = Union[DocumentAttributeImageSize,DocumentAttributeAnimated,DocumentAttributeSticker,DocumentAttributeVideo,DocumentAttributeAudio,DocumentAttributeFilename,DocumentAttributeHasStickers]
TypeDraftMessage = Union[DraftMessageEmpty,DraftMessage]
TypeEncryptedChat = Union[EncryptedChatEmpty,EncryptedChatWaiting,EncryptedChatRequested,EncryptedChat,EncryptedChatDiscarded]
TypeEncryptedFile = Union[EncryptedFileEmpty,EncryptedFile]
TypeEncryptedMessage = Union[EncryptedMessage,EncryptedMessageService]
TypeError = Error
TypeExportedMessageLink = ExportedMessageLink
TypeFileLocation = Union[FileLocationUnavailable,FileLocation]
TypeFoundGif = Union[FoundGif,FoundGifCached]
TypeFutureSalt = FutureSalt
TypeFutureSalts = FutureSalts
TypeGame = Game
TypeGeoPoint = Union[GeoPointEmpty,GeoPoint]
TypeHighScore = HighScore
TypeHttpWait = HttpWait
TypeImportedContact = ImportedContact
TypeInlineBotSwitchPM = InlineBotSwitchPM
TypeInputAppEvent = InputAppEvent
TypeInputBotInlineMessage = Union[InputBotInlineMessageMediaAuto,InputBotInlineMessageText,InputBotInlineMessageMediaGeo,InputBotInlineMessageMediaVenue,InputBotInlineMessageMediaContact,InputBotInlineMessageGame]
TypeInputBotInlineMessageID = InputBotInlineMessageID
TypeInputBotInlineResult = Union[InputBotInlineResult,InputBotInlineResultPhoto,InputBotInlineResultDocument,InputBotInlineResultGame]
TypeInputChannel = Union[InputChannelEmpty,InputChannel]
TypeInputChatPhoto = Union[InputChatPhotoEmpty,InputChatUploadedPhoto,InputChatPhoto]
TypeInputDocument = Union[InputDocumentEmpty,InputDocument]
TypeInputFileLocation = Union[InputFileLocation,InputEncryptedFileLocation,InputDocumentFileLocation]
TypeInputEncryptedChat = InputEncryptedChat
TypeInputEncryptedFile = Union[InputEncryptedFileEmpty,InputEncryptedFileUploaded,InputEncryptedFile,InputEncryptedFileBigUploaded]
TypeInputFile = Union[InputFile,InputFileBig]
TypeInputGame = Union[InputGameID,InputGameShortName]
TypeInputGeoPoint = Union[InputGeoPointEmpty,InputGeoPoint]
TypeInputMedia = Union[InputMediaEmpty,InputMediaUploadedPhoto,InputMediaPhoto,InputMediaGeoPoint,InputMediaContact,InputMediaUploadedDocument,InputMediaDocument,InputMediaVenue,InputMediaGifExternal,InputMediaPhotoExternal,InputMediaDocumentExternal,InputMediaGame,InputMediaInvoice,InputMediaGeoLive]
TypeMessageEntity = Union[MessageEntityUnknown,MessageEntityMention,MessageEntityHashtag,MessageEntityBotCommand,MessageEntityUrl,MessageEntityEmail,MessageEntityBold,MessageEntityItalic,MessageEntityCode,MessageEntityPre,MessageEntityTextUrl,MessageEntityMentionName,InputMessageEntityMentionName]
TypeMessagesFilter = Union[InputMessagesFilterEmpty,InputMessagesFilterPhotos,InputMessagesFilterVideo,InputMessagesFilterPhotoVideo,InputMessagesFilterDocument,InputMessagesFilterUrl,InputMessagesFilterGif,InputMessagesFilterVoice,InputMessagesFilterMusic,InputMessagesFilterChatPhotos,InputMessagesFilterPhoneCalls,InputMessagesFilterRoundVoice,InputMessagesFilterRoundVideo,InputMessagesFilterMyMentions,InputMessagesFilterGeo,InputMessagesFilterContacts]
TypeInputNotifyPeer = Union[InputNotifyPeer,InputNotifyUsers,InputNotifyChats,InputNotifyAll]
TypeInputPaymentCredentials = Union[InputPaymentCredentialsSaved,InputPaymentCredentials,InputPaymentCredentialsApplePay,InputPaymentCredentialsAndroidPay]
TypeInputPeer = Union[InputPeerEmpty,InputPeerSelf,InputPeerChat,InputPeerUser,InputPeerChannel]
TypeInputPeerNotifyEvents = Union[InputPeerNotifyEventsEmpty,InputPeerNotifyEventsAll]
TypeInputPeerNotifySettings = InputPeerNotifySettings
TypeInputPhoneCall = InputPhoneCall
TypeInputContact = InputPhoneContact
TypeInputPhoto = Union[InputPhotoEmpty,InputPhoto]
TypeInputPrivacyKey = Union[InputPrivacyKeyStatusTimestamp,InputPrivacyKeyChatInvite,InputPrivacyKeyPhoneCall]
TypeInputPrivacyRule = Union[InputPrivacyValueAllowContacts,InputPrivacyValueAllowAll,InputPrivacyValueAllowUsers,InputPrivacyValueDisallowContacts,InputPrivacyValueDisallowAll,InputPrivacyValueDisallowUsers]
TypeReportReason = Union[InputReportReasonSpam,InputReportReasonViolence,InputReportReasonPornography,InputReportReasonOther]
TypeInputSingleMedia = InputSingleMedia
TypeInputStickerSet = Union[InputStickerSetEmpty,InputStickerSetID,InputStickerSetShortName]
TypeInputStickerSetItem = InputStickerSetItem
TypeInputStickeredMedia = Union[InputStickeredMediaPhoto,InputStickeredMediaDocument]
TypeInputUser = Union[InputUserEmpty,InputUserSelf,InputUser]
TypeInputWebDocument = InputWebDocument
TypeInputWebFileLocation = InputWebFileLocation
TypeInvoice = Invoice
TypeIpPort = IpPort
TypeKeyboardButton = Union[KeyboardButton,KeyboardButtonUrl,KeyboardButtonCallback,KeyboardButtonRequestPhone,KeyboardButtonRequestGeoLocation,KeyboardButtonSwitchInline,KeyboardButtonGame,KeyboardButtonBuy]
TypeKeyboardButtonRow = KeyboardButtonRow
TypeLabeledPrice = LabeledPrice
TypeLangPackDifference = LangPackDifference
TypeLangPackLanguage = LangPackLanguage
TypeLangPackString = Union[LangPackString,LangPackStringPluralized,LangPackStringDeleted]
TypeMaskCoords = MaskCoords
TypeMessage = Union[MessageEmpty,Message,MessageService]
TypeMessageAction = Union[MessageActionEmpty,MessageActionChatCreate,MessageActionChatEditTitle,MessageActionChatEditPhoto,MessageActionChatDeletePhoto,MessageActionChatAddUser,MessageActionChatDeleteUser,MessageActionChatJoinedByLink,MessageActionChannelCreate,MessageActionChatMigrateTo,MessageActionChannelMigrateFrom,MessageActionPinMessage,MessageActionHistoryClear,MessageActionGameScore,MessageActionPaymentSentMe,MessageActionPaymentSent,MessageActionPhoneCall,MessageActionScreenshotTaken,MessageActionCustomAction]
TypeMessageFwdHeader = MessageFwdHeader
TypeMessageMedia = Union[MessageMediaEmpty,MessageMediaPhoto,MessageMediaGeo,MessageMediaContact,MessageMediaUnsupported,MessageMediaDocument,MessageMediaWebPage,MessageMediaVenue,MessageMediaGame,MessageMediaInvoice,MessageMediaGeoLive]
TypeMessageRange = MessageRange
TypeMsgDetailedInfo = Union[MsgDetailedInfo,MsgNewDetailedInfo]
TypeMsgResendReq = MsgResendReq
TypeMsgsAck = MsgsAck
TypeMsgsAllInfo = MsgsAllInfo
TypeMsgsStateInfo = MsgsStateInfo
TypeMsgsStateReq = MsgsStateReq
TypeNearestDc = NearestDc
TypeNewSession = NewSessionCreated
TypeNotifyPeer = Union[NotifyPeer,NotifyUsers,NotifyChats,NotifyAll]
TypeNull = Null
TypeP_Q_inner_data = PQInnerData
TypePageBlock = Union[PageBlockUnsupported,PageBlockTitle,PageBlockSubtitle,PageBlockAuthorDate,PageBlockHeader,PageBlockSubheader,PageBlockParagraph,PageBlockPreformatted,PageBlockFooter,PageBlockDivider,PageBlockAnchor,PageBlockList,PageBlockBlockquote,PageBlockPullquote,PageBlockPhoto,PageBlockVideo,PageBlockCover,PageBlockEmbed,PageBlockEmbedPost,PageBlockCollage,PageBlockSlideshow,PageBlockChannel,PageBlockAudio]
TypePage = Union[PagePart,PageFull]
TypePaymentCharge = PaymentCharge
TypePaymentRequestedInfo = PaymentRequestedInfo
TypePaymentSavedCredentials = PaymentSavedCredentialsCard
TypePeer = Union[PeerUser,PeerChat,PeerChannel]
TypePeerNotifyEvents = Union[PeerNotifyEventsEmpty,PeerNotifyEventsAll]
TypePeerNotifySettings = Union[PeerNotifySettingsEmpty,PeerNotifySettings]
TypePeerSettings = PeerSettings
TypePhoneCall = Union[PhoneCallEmpty,PhoneCallWaiting,PhoneCallRequested,PhoneCallAccepted,PhoneCall,PhoneCallDiscarded]
TypePhoneCallDiscardReason = Union[PhoneCallDiscardReasonMissed,PhoneCallDiscardReasonDisconnect,PhoneCallDiscardReasonHangup,PhoneCallDiscardReasonBusy]
TypePhoneCallProtocol = PhoneCallProtocol
TypePhoneConnection = PhoneConnection
TypePhoto = Union[PhotoEmpty,Photo]
TypePhotoSize = Union[PhotoSizeEmpty,PhotoSize,PhotoCachedSize]
TypePong = Pong
TypePopularContact = PopularContact
TypePostAddress = PostAddress
TypePrivacyKey = Union[PrivacyKeyStatusTimestamp,PrivacyKeyChatInvite,PrivacyKeyPhoneCall]
TypePrivacyRule = Union[PrivacyValueAllowContacts,PrivacyValueAllowAll,PrivacyValueAllowUsers,PrivacyValueDisallowContacts,PrivacyValueDisallowAll,PrivacyValueDisallowUsers]
TypeReceivedNotifyMessage = ReceivedNotifyMessage
TypeRecentMeUrl = Union[RecentMeUrlUnknown,RecentMeUrlUser,RecentMeUrlChat,RecentMeUrlChatInvite,RecentMeUrlStickerSet]
TypeReplyMarkup = Union[ReplyKeyboardHide,ReplyKeyboardForceReply,ReplyKeyboardMarkup,ReplyInlineMarkup]
TypeResPQ = ResPQ
TypeRpcDropAnswer = Union[RpcAnswerUnknown,RpcAnswerDroppedRunning,RpcAnswerDropped]
TypeRpcError = RpcError
TypeSendMessageAction = Union[SendMessageTypingAction,SendMessageCancelAction,SendMessageRecordVideoAction,SendMessageUploadVideoAction,SendMessageRecordAudioAction,SendMessageUploadAudioAction,SendMessageUploadPhotoAction,SendMessageUploadDocumentAction,SendMessageGeoLocationAction,SendMessageChooseContactAction,SendMessageGamePlayAction,SendMessageRecordRoundAction,SendMessageUploadRoundAction]
TypeServer_DH_inner_data = ServerDHInnerData
TypeServer_DH_Params = Union[ServerDHParamsFail,ServerDHParamsOk]
TypeShippingOption = ShippingOption
TypeStickerPack = StickerPack
TypeStickerSet = StickerSet
TypeStickerSetCovered = Union[StickerSetCovered,StickerSetMultiCovered]
TypeRichText = Union[TextEmpty,TextPlain,TextBold,TextItalic,TextUnderline,TextStrike,TextFixed,TextUrl,TextEmail,TextConcat]
TypeTopPeer = TopPeer
TypeTopPeerCategory = Union[TopPeerCategoryBotsPM,TopPeerCategoryBotsInline,TopPeerCategoryCorrespondents,TopPeerCategoryGroups,TopPeerCategoryChannels,TopPeerCategoryPhoneCalls]
TypeTopPeerCategoryPeers = TopPeerCategoryPeers
TypeUpdate = Union[UpdateNewMessage,UpdateMessageID,UpdateDeleteMessages,UpdateUserTyping,UpdateChatUserTyping,UpdateChatParticipants,UpdateUserStatus,UpdateUserName,UpdateUserPhoto,UpdateContactRegistered,UpdateContactLink,UpdateNewEncryptedMessage,UpdateEncryptedChatTyping,UpdateEncryption,UpdateEncryptedMessagesRead,UpdateChatParticipantAdd,UpdateChatParticipantDelete,UpdateDcOptions,UpdateUserBlocked,UpdateNotifySettings,UpdateServiceNotification,UpdatePrivacy,UpdateUserPhone,UpdateReadHistoryInbox,UpdateReadHistoryOutbox,UpdateWebPage,UpdateReadMessagesContents,UpdateChannelTooLong,UpdateChannel,UpdateNewChannelMessage,UpdateReadChannelInbox,UpdateDeleteChannelMessages,UpdateChannelMessageViews,UpdateChatAdmins,UpdateChatParticipantAdmin,UpdateNewStickerSet,UpdateStickerSetsOrder,UpdateStickerSets,UpdateSavedGifs,UpdateBotInlineQuery,UpdateBotInlineSend,UpdateEditChannelMessage,UpdateChannelPinnedMessage,UpdateBotCallbackQuery,UpdateEditMessage,UpdateInlineBotCallbackQuery,UpdateReadChannelOutbox,UpdateDraftMessage,UpdateReadFeaturedStickers,UpdateRecentStickers,UpdateConfig,UpdatePtsChanged,UpdateChannelWebPage,UpdateDialogPinned,UpdatePinnedDialogs,UpdateBotWebhookJSON,UpdateBotWebhookJSONQuery,UpdateBotShippingQuery,UpdateBotPrecheckoutQuery,UpdatePhoneCall,UpdateLangPackTooLong,UpdateLangPack,UpdateFavedStickers,UpdateChannelReadMessagesContents,UpdateContactsReset,UpdateChannelAvailableMessages]
TypeUpdates = Union[UpdatesTooLong,UpdateShortMessage,UpdateShortChatMessage,UpdateShort,UpdatesCombined,Updates,UpdateShortSentMessage]
TypeUser = Union[UserEmpty,User]
TypeUserFull = UserFull
TypeUserProfilePhoto = Union[UserProfilePhotoEmpty,UserProfilePhoto]
TypeUserStatus = Union[UserStatusEmpty,UserStatusOnline,UserStatusOffline,UserStatusRecently,UserStatusLastWeek,UserStatusLastMonth]
TypeWallPaper = Union[WallPaper,WallPaperSolid]
TypeWebDocument = WebDocument
TypeWebPage = Union[WebPageEmpty,WebPagePending,WebPage,WebPageNotModified]
